// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EJSRegisterMethodType {
	k_ejsregistermethodtype_invalid = 0
	k_ejsregistermethodtype_function = 1
	k_ejsregistermethodtype_callback = 2
	k_ejsregistermethodtype_promise = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_ejsregistermethodtype() EJSRegisterMethodType {
	return .k_ejsregistermethodtype_invalid
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_ejsregistermethodtype(e EJSRegisterMethodType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_ejsregistermethodtype_packed(e []EJSRegisterMethodType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_ejsregistermethodtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EJSRegisterMethodType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EJSRegisterMethodType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_ejsregistermethodtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EJSRegisterMethodType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgKeyUp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	keycode        u32
	modifiers      u32
	nativekeycode  u32
}

pub fn (o &CMsgKeyUp) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.keycode != u32(0) {
		res << vproto.pack_uint32_field(o.keycode, 2)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.nativekeycode != u32(0) {
		res << vproto.pack_uint32_field(o.nativekeycode, 4)
	}
	return res
}

pub fn cmsgkeyup_unpack(buf []byte) ?CMsgKeyUp {
	mut res := zzz_vproto_internal_new_cmsgkeyup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.keycode = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.nativekeycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgKeyUp) eq(b CMsgKeyUp) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.keycode == b.keycode && a.modifiers == b.modifiers &&
		a.nativekeycode == b.nativekeycode
}

[inline]
pub fn (a CMsgKeyUp) ne(b CMsgKeyUp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgKeyUp) eq(b []CMsgKeyUp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgKeyUp) ne(b []CMsgKeyUp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgkeyup() CMsgKeyUp {
	return CMsgKeyUp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgkeyup(o CMsgKeyUp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgkeyup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyUp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgkeyup_unpack(v)?
	return i, unpacked
}

pub struct CMsgKeyDown {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	keycode        u32
	modifiers      u32
	is_system_key  bool
	nativekeycode  u32
}

pub fn (o &CMsgKeyDown) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.keycode != u32(0) {
		res << vproto.pack_uint32_field(o.keycode, 2)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.is_system_key != bool(0) {
		res << vproto.pack_bool_field(o.is_system_key, 4)
	}
	if o.nativekeycode != u32(0) {
		res << vproto.pack_uint32_field(o.nativekeycode, 5)
	}
	return res
}

pub fn cmsgkeydown_unpack(buf []byte) ?CMsgKeyDown {
	mut res := zzz_vproto_internal_new_cmsgkeydown()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.keycode = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_system_key = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.nativekeycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgKeyDown) eq(b CMsgKeyDown) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.keycode == b.keycode && a.modifiers == b.modifiers &&
		a.is_system_key == b.is_system_key &&
		a.nativekeycode == b.nativekeycode
}

[inline]
pub fn (a CMsgKeyDown) ne(b CMsgKeyDown) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgKeyDown) eq(b []CMsgKeyDown) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgKeyDown) ne(b []CMsgKeyDown) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgkeydown() CMsgKeyDown {
	return CMsgKeyDown{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgkeydown(o CMsgKeyDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgkeydown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgkeydown_unpack(v)?
	return i, unpacked
}

pub struct CMsgKeyChar {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	unichar        u32
	modifiers      u32
	keycode        u32
	nativekeycode  u32
}

pub fn (o &CMsgKeyChar) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.unichar != u32(0) {
		res << vproto.pack_uint32_field(o.unichar, 2)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.keycode != u32(0) {
		res << vproto.pack_uint32_field(o.keycode, 4)
	}
	if o.nativekeycode != u32(0) {
		res << vproto.pack_uint32_field(o.nativekeycode, 5)
	}
	return res
}

pub fn cmsgkeychar_unpack(buf []byte) ?CMsgKeyChar {
	mut res := zzz_vproto_internal_new_cmsgkeychar()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unichar = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.keycode = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.nativekeycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgKeyChar) eq(b CMsgKeyChar) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.unichar == b.unichar && a.modifiers == b.modifiers &&
		a.keycode == b.keycode && a.nativekeycode == b.nativekeycode
}

[inline]
pub fn (a CMsgKeyChar) ne(b CMsgKeyChar) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgKeyChar) eq(b []CMsgKeyChar) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgKeyChar) ne(b []CMsgKeyChar) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgkeychar() CMsgKeyChar {
	return CMsgKeyChar{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgkeychar(o CMsgKeyChar, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgkeychar(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyChar) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgkeychar_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseDown {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	mouse_button   u32
	modifiers      u32
}

pub fn (o &CMsgMouseDown) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.mouse_button != u32(0) {
		res << vproto.pack_uint32_field(o.mouse_button, 2)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	return res
}

pub fn cmsgmousedown_unpack(buf []byte) ?CMsgMouseDown {
	mut res := zzz_vproto_internal_new_cmsgmousedown()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_button = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMouseDown) eq(b CMsgMouseDown) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.mouse_button == b.mouse_button &&
		a.modifiers == b.modifiers
}

[inline]
pub fn (a CMsgMouseDown) ne(b CMsgMouseDown) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMouseDown) eq(b []CMsgMouseDown) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMouseDown) ne(b []CMsgMouseDown) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmousedown() CMsgMouseDown {
	return CMsgMouseDown{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousedown(o CMsgMouseDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousedown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousedown_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseUp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	mouse_button   u32
	modifiers      u32
	is_off_panel   bool
	x              int
	y              int
}

pub fn (o &CMsgMouseUp) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.mouse_button != u32(0) {
		res << vproto.pack_uint32_field(o.mouse_button, 2)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.is_off_panel != bool(0) {
		res << vproto.pack_bool_field(o.is_off_panel, 4)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 5)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 6)
	}
	return res
}

pub fn cmsgmouseup_unpack(buf []byte) ?CMsgMouseUp {
	mut res := zzz_vproto_internal_new_cmsgmouseup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_button = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_off_panel = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMouseUp) eq(b CMsgMouseUp) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.mouse_button == b.mouse_button &&
		a.modifiers == b.modifiers && a.is_off_panel == b.is_off_panel &&
		a.x == b.x && a.y == b.y
}

[inline]
pub fn (a CMsgMouseUp) ne(b CMsgMouseUp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMouseUp) eq(b []CMsgMouseUp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMouseUp) ne(b []CMsgMouseUp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmouseup() CMsgMouseUp {
	return CMsgMouseUp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmouseup(o CMsgMouseUp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmouseup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseUp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmouseup_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseDblClick {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	mouse_button   u32
	modifiers      u32
}

pub fn (o &CMsgMouseDblClick) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.mouse_button != u32(0) {
		res << vproto.pack_uint32_field(o.mouse_button, 2)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	return res
}

pub fn cmsgmousedblclick_unpack(buf []byte) ?CMsgMouseDblClick {
	mut res := zzz_vproto_internal_new_cmsgmousedblclick()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_button = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMouseDblClick) eq(b CMsgMouseDblClick) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.mouse_button == b.mouse_button &&
		a.modifiers == b.modifiers
}

[inline]
pub fn (a CMsgMouseDblClick) ne(b CMsgMouseDblClick) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMouseDblClick) eq(b []CMsgMouseDblClick) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMouseDblClick) ne(b []CMsgMouseDblClick) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmousedblclick() CMsgMouseDblClick {
	return CMsgMouseDblClick{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousedblclick(o CMsgMouseDblClick, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousedblclick(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseDblClick) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousedblclick_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseWheel {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	deltax         int
	deltay         int
	modifiers      u32
}

pub fn (o &CMsgMouseWheel) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.deltax != int(0) {
		res << vproto.pack_int32_field(o.deltax, 2)
	}
	if o.deltay != int(0) {
		res << vproto.pack_int32_field(o.deltay, 3)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 4)
	}
	return res
}

pub fn cmsgmousewheel_unpack(buf []byte) ?CMsgMouseWheel {
	mut res := zzz_vproto_internal_new_cmsgmousewheel()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.deltax = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.deltay = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMouseWheel) eq(b CMsgMouseWheel) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.deltax == b.deltax && a.deltay == b.deltay &&
		a.modifiers == b.modifiers
}

[inline]
pub fn (a CMsgMouseWheel) ne(b CMsgMouseWheel) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMouseWheel) eq(b []CMsgMouseWheel) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMouseWheel) ne(b []CMsgMouseWheel) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmousewheel() CMsgMouseWheel {
	return CMsgMouseWheel{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousewheel(o CMsgMouseWheel, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousewheel(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseWheel) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousewheel_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseMove {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              int
	y              int
	modifiers      u32
}

pub fn (o &CMsgMouseMove) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.modifiers != u32(0) {
		res << vproto.pack_uint32_field(o.modifiers, 4)
	}
	return res
}

pub fn cmsgmousemove_unpack(buf []byte) ?CMsgMouseMove {
	mut res := zzz_vproto_internal_new_cmsgmousemove()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMouseMove) eq(b CMsgMouseMove) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.x == b.x && a.y == b.y && a.modifiers == b.modifiers
}

[inline]
pub fn (a CMsgMouseMove) ne(b CMsgMouseMove) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMouseMove) eq(b []CMsgMouseMove) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMouseMove) ne(b []CMsgMouseMove) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmousemove() CMsgMouseMove {
	return CMsgMouseMove{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmousemove(o CMsgMouseMove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmousemove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseMove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousemove_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseLeave {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgMouseLeave) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgmouseleave_unpack(buf []byte) ?CMsgMouseLeave {
	mut res := zzz_vproto_internal_new_cmsgmouseleave()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMouseLeave) eq(b CMsgMouseLeave) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgMouseLeave) ne(b CMsgMouseLeave) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMouseLeave) eq(b []CMsgMouseLeave) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMouseLeave) ne(b []CMsgMouseLeave) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmouseleave() CMsgMouseLeave {
	return CMsgMouseLeave{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmouseleave(o CMsgMouseLeave, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmouseleave(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseLeave) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmouseleave_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserCreate {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	request_id                u32
	useragent                 string
	user_css                  string
	native_dropdowns          bool
	dpi_scaling               f32
	offscreen                 bool = true
	initial_width             u32 = 0
	initial_height            u32 = 0
	window_icon               string
	borderless                bool = false
	vroverlay_key             string
	browser_type              u32 = 0
	initial_top               int = -2147483648
	initial_left              int = -2147483648
	only_allow_trusted_popups bool = false
	initial_url               string
	hwnd_parent               u64
}

pub fn (o &CMsgBrowserCreate) pack() []byte {
	mut res := []byte{}
	if o.request_id != u32(0) {
		res << vproto.pack_uint32_field(o.request_id, 1)
	}
	if o.useragent != '' {
		res << vproto.pack_string_field(o.useragent, 3)
	}
	if o.user_css != '' {
		res << vproto.pack_string_field(o.user_css, 5)
	}
	if o.native_dropdowns != bool(0) {
		res << vproto.pack_bool_field(o.native_dropdowns, 6)
	}
	if o.dpi_scaling != f32(0) {
		res << vproto.pack_float_field(o.dpi_scaling, 7)
	}
	if o.offscreen != bool(0) {
		res << vproto.pack_bool_field(o.offscreen, 8)
	}
	if o.initial_width != u32(0) {
		res << vproto.pack_uint32_field(o.initial_width, 9)
	}
	if o.initial_height != u32(0) {
		res << vproto.pack_uint32_field(o.initial_height, 10)
	}
	if o.window_icon != '' {
		res << vproto.pack_string_field(o.window_icon, 11)
	}
	if o.borderless != bool(0) {
		res << vproto.pack_bool_field(o.borderless, 12)
	}
	if o.vroverlay_key != '' {
		res << vproto.pack_string_field(o.vroverlay_key, 13)
	}
	if o.browser_type != u32(0) {
		res << vproto.pack_uint32_field(o.browser_type, 14)
	}
	if o.initial_top != int(0) {
		res << vproto.pack_int32_field(o.initial_top, 15)
	}
	if o.initial_left != int(0) {
		res << vproto.pack_int32_field(o.initial_left, 16)
	}
	if o.only_allow_trusted_popups != bool(0) {
		res << vproto.pack_bool_field(o.only_allow_trusted_popups, 17)
	}
	if o.initial_url != '' {
		res << vproto.pack_string_field(o.initial_url, 18)
	}
	if o.hwnd_parent != u64(0) {
		res << vproto.pack_64bit_field(o.hwnd_parent, 19)
	}
	return res
}

pub fn cmsgbrowsercreate_unpack(buf []byte) ?CMsgBrowserCreate {
	mut res := zzz_vproto_internal_new_cmsgbrowsercreate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.useragent = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.user_css = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.native_dropdowns = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.dpi_scaling = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.offscreen = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_width = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_height = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.window_icon = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.borderless = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vroverlay_key = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_type = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_top = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_left = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_allow_trusted_popups = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_url = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hwnd_parent = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserCreate) eq(b CMsgBrowserCreate) bool {
	return true && a.request_id == b.request_id &&
		a.useragent == b.useragent && a.user_css == b.user_css &&
		a.native_dropdowns == b.native_dropdowns &&
		a.dpi_scaling == b.dpi_scaling && a.offscreen == b.offscreen &&
		a.initial_width == b.initial_width &&
		a.initial_height == b.initial_height &&
		a.window_icon == b.window_icon && a.borderless == b.borderless &&
		a.vroverlay_key == b.vroverlay_key &&
		a.browser_type == b.browser_type &&
		a.initial_top == b.initial_top && a.initial_left == b.initial_left &&
		a.only_allow_trusted_popups == b.only_allow_trusted_popups &&
		a.initial_url == b.initial_url && a.hwnd_parent == b.hwnd_parent
}

[inline]
pub fn (a CMsgBrowserCreate) ne(b CMsgBrowserCreate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserCreate) eq(b []CMsgBrowserCreate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserCreate) ne(b []CMsgBrowserCreate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowsercreate() CMsgBrowserCreate {
	return CMsgBrowserCreate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsercreate(o CMsgBrowserCreate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsercreate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserCreate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsercreate_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserCreateResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	request_id     u32
}

pub fn (o &CMsgBrowserCreateResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.request_id != u32(0) {
		res << vproto.pack_uint32_field(o.request_id, 2)
	}
	return res
}

pub fn cmsgbrowsercreateresponse_unpack(buf []byte) ?CMsgBrowserCreateResponse {
	mut res := zzz_vproto_internal_new_cmsgbrowsercreateresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserCreateResponse) eq(b CMsgBrowserCreateResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.request_id == b.request_id
}

[inline]
pub fn (a CMsgBrowserCreateResponse) ne(b CMsgBrowserCreateResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserCreateResponse) eq(b []CMsgBrowserCreateResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserCreateResponse) ne(b []CMsgBrowserCreateResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowsercreateresponse() CMsgBrowserCreateResponse {
	return CMsgBrowserCreateResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsercreateresponse(o CMsgBrowserCreateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsercreateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserCreateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsercreateresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserRemove {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgBrowserRemove) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgbrowserremove_unpack(buf []byte) ?CMsgBrowserRemove {
	mut res := zzz_vproto_internal_new_cmsgbrowserremove()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserRemove) eq(b CMsgBrowserRemove) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgBrowserRemove) ne(b CMsgBrowserRemove) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserRemove) eq(b []CMsgBrowserRemove) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserRemove) ne(b []CMsgBrowserRemove) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowserremove() CMsgBrowserRemove {
	return CMsgBrowserRemove{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserremove(o CMsgBrowserRemove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserremove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserRemove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserremove_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetLocalFileRequestMapping_AdditionalRoute {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	relative_url       string
	local_path         string
	allowed_extensions string
}

pub fn (o &CMsgSetLocalFileRequestMapping_AdditionalRoute) pack() []byte {
	mut res := []byte{}
	if o.relative_url != '' {
		res << vproto.pack_string_field(o.relative_url, 1)
	}
	if o.local_path != '' {
		res << vproto.pack_string_field(o.local_path, 2)
	}
	if o.allowed_extensions != '' {
		res << vproto.pack_string_field(o.allowed_extensions, 3)
	}
	return res
}

pub fn cmsgsetlocalfilerequestmapping_additionalroute_unpack(buf []byte) ?CMsgSetLocalFileRequestMapping_AdditionalRoute {
	mut res := zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping_additionalroute()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.relative_url = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.local_path = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.allowed_extensions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetLocalFileRequestMapping_AdditionalRoute) eq(b CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
	return true && a.relative_url == b.relative_url &&
		a.local_path == b.local_path && a.allowed_extensions == b.allowed_extensions
}

[inline]
pub fn (a CMsgSetLocalFileRequestMapping_AdditionalRoute) ne(b CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetLocalFileRequestMapping_AdditionalRoute) eq(b []CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetLocalFileRequestMapping_AdditionalRoute) ne(b []CMsgSetLocalFileRequestMapping_AdditionalRoute) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping_additionalroute() CMsgSetLocalFileRequestMapping_AdditionalRoute {
	return CMsgSetLocalFileRequestMapping_AdditionalRoute{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping_additionalroute(o CMsgSetLocalFileRequestMapping_AdditionalRoute, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping_additionalroute(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetLocalFileRequestMapping_AdditionalRoute) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetlocalfilerequestmapping_additionalroute_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetLocalFileRequestMapping {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	request_url        string
	default_local_path string
	routes             []CMsgSetLocalFileRequestMapping_AdditionalRoute
}

pub fn (o &CMsgSetLocalFileRequestMapping) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.request_url != '' {
		res << vproto.pack_string_field(o.request_url, 2)
	}
	if o.default_local_path != '' {
		res << vproto.pack_string_field(o.default_local_path, 3)
	}
	// [packed=false]
	for _, x in o.routes {
		res << zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping_additionalroute(x, 4)
	}
	return res
}

pub fn cmsgsetlocalfilerequestmapping_unpack(buf []byte) ?CMsgSetLocalFileRequestMapping {
	mut res := zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.request_url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.default_local_path = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping_additionalroute(cur_buf,
					tag_wiretype.wire_type)?
				res.routes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetLocalFileRequestMapping) eq(b CMsgSetLocalFileRequestMapping) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.request_url == b.request_url &&
		a.default_local_path == b.default_local_path && a.routes.eq(b.routes)
}

[inline]
pub fn (a CMsgSetLocalFileRequestMapping) ne(b CMsgSetLocalFileRequestMapping) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetLocalFileRequestMapping) eq(b []CMsgSetLocalFileRequestMapping) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetLocalFileRequestMapping) ne(b []CMsgSetLocalFileRequestMapping) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping() CMsgSetLocalFileRequestMapping {
	return CMsgSetLocalFileRequestMapping{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping(o CMsgSetLocalFileRequestMapping, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetLocalFileRequestMapping) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetlocalfilerequestmapping_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserErrorStrings {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	title              string
	header             string
	cache_miss         string
	bad_url            string
	connection_problem string
	proxy_problem      string
	unknown            string
}

pub fn (o &CMsgBrowserErrorStrings) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.title != '' {
		res << vproto.pack_string_field(o.title, 2)
	}
	if o.header != '' {
		res << vproto.pack_string_field(o.header, 3)
	}
	if o.cache_miss != '' {
		res << vproto.pack_string_field(o.cache_miss, 4)
	}
	if o.bad_url != '' {
		res << vproto.pack_string_field(o.bad_url, 5)
	}
	if o.connection_problem != '' {
		res << vproto.pack_string_field(o.connection_problem, 6)
	}
	if o.proxy_problem != '' {
		res << vproto.pack_string_field(o.proxy_problem, 7)
	}
	if o.unknown != '' {
		res << vproto.pack_string_field(o.unknown, 8)
	}
	return res
}

pub fn cmsgbrowsererrorstrings_unpack(buf []byte) ?CMsgBrowserErrorStrings {
	mut res := zzz_vproto_internal_new_cmsgbrowsererrorstrings()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.header = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_miss = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.bad_url = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_problem = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.proxy_problem = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.unknown = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserErrorStrings) eq(b CMsgBrowserErrorStrings) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.title == b.title && a.header == b.header &&
		a.cache_miss == b.cache_miss && a.bad_url == b.bad_url &&
		a.connection_problem == b.connection_problem &&
		a.proxy_problem == b.proxy_problem &&
		a.unknown == b.unknown
}

[inline]
pub fn (a CMsgBrowserErrorStrings) ne(b CMsgBrowserErrorStrings) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserErrorStrings) eq(b []CMsgBrowserErrorStrings) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserErrorStrings) ne(b []CMsgBrowserErrorStrings) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowsererrorstrings() CMsgBrowserErrorStrings {
	return CMsgBrowserErrorStrings{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsererrorstrings(o CMsgBrowserErrorStrings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsererrorstrings(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserErrorStrings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsererrorstrings_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserSize {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	width          u32
	height         u32
}

pub fn (o &CMsgBrowserSize) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.width != u32(0) {
		res << vproto.pack_uint32_field(o.width, 2)
	}
	if o.height != u32(0) {
		res << vproto.pack_uint32_field(o.height, 3)
	}
	return res
}

pub fn cmsgbrowsersize_unpack(buf []byte) ?CMsgBrowserSize {
	mut res := zzz_vproto_internal_new_cmsgbrowsersize()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserSize) eq(b CMsgBrowserSize) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.width == b.width && a.height == b.height
}

[inline]
pub fn (a CMsgBrowserSize) ne(b CMsgBrowserSize) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserSize) eq(b []CMsgBrowserSize) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserSize) ne(b []CMsgBrowserSize) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowsersize() CMsgBrowserSize {
	return CMsgBrowserSize{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsersize(o CMsgBrowserSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsersize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsersize_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserSetMinSize {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	width          u32
	height         u32
}

pub fn (o &CMsgBrowserSetMinSize) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.width != u32(0) {
		res << vproto.pack_uint32_field(o.width, 2)
	}
	if o.height != u32(0) {
		res << vproto.pack_uint32_field(o.height, 3)
	}
	return res
}

pub fn cmsgbrowsersetminsize_unpack(buf []byte) ?CMsgBrowserSetMinSize {
	mut res := zzz_vproto_internal_new_cmsgbrowsersetminsize()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserSetMinSize) eq(b CMsgBrowserSetMinSize) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.width == b.width && a.height == b.height
}

[inline]
pub fn (a CMsgBrowserSetMinSize) ne(b CMsgBrowserSetMinSize) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserSetMinSize) eq(b []CMsgBrowserSetMinSize) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserSetMinSize) ne(b []CMsgBrowserSetMinSize) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowsersetminsize() CMsgBrowserSetMinSize {
	return CMsgBrowserSetMinSize{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowsersetminsize(o CMsgBrowserSetMinSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowsersetminsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserSetMinSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsersetminsize_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserPosition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              int
	y              int
	x_local        int
	y_local        int
}

pub fn (o &CMsgBrowserPosition) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.x_local != int(0) {
		res << vproto.pack_int32_field(o.x_local, 4)
	}
	if o.y_local != int(0) {
		res << vproto.pack_int32_field(o.y_local, 5)
	}
	return res
}

pub fn cmsgbrowserposition_unpack(buf []byte) ?CMsgBrowserPosition {
	mut res := zzz_vproto_internal_new_cmsgbrowserposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x_local = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y_local = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserPosition) eq(b CMsgBrowserPosition) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.x == b.x && a.y == b.y && a.x_local == b.x_local &&
		a.y_local == b.y_local
}

[inline]
pub fn (a CMsgBrowserPosition) ne(b CMsgBrowserPosition) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserPosition) eq(b []CMsgBrowserPosition) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserPosition) ne(b []CMsgBrowserPosition) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowserposition() CMsgBrowserPosition {
	return CMsgBrowserPosition{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserposition(o CMsgBrowserPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserResized {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              int
	y              int
	width          u32
	height         u32
}

pub fn (o &CMsgBrowserResized) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.width != u32(0) {
		res << vproto.pack_uint32_field(o.width, 4)
	}
	if o.height != u32(0) {
		res << vproto.pack_uint32_field(o.height, 5)
	}
	return res
}

pub fn cmsgbrowserresized_unpack(buf []byte) ?CMsgBrowserResized {
	mut res := zzz_vproto_internal_new_cmsgbrowserresized()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserResized) eq(b CMsgBrowserResized) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.x == b.x && a.y == b.y && a.width == b.width &&
		a.height == b.height
}

[inline]
pub fn (a CMsgBrowserResized) ne(b CMsgBrowserResized) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserResized) eq(b []CMsgBrowserResized) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserResized) ne(b []CMsgBrowserResized) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowserresized() CMsgBrowserResized {
	return CMsgBrowserResized{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserresized(o CMsgBrowserResized, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserresized(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserResized) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserresized_unpack(v)?
	return i, unpacked
}

pub struct CMsgPostURL {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	post           string
	pageserial     u32
}

pub fn (o &CMsgPostURL) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.post != '' {
		res << vproto.pack_string_field(o.post, 3)
	}
	if o.pageserial != u32(0) {
		res << vproto.pack_uint32_field(o.pageserial, 4)
	}
	return res
}

pub fn cmsgposturl_unpack(buf []byte) ?CMsgPostURL {
	mut res := zzz_vproto_internal_new_cmsgposturl()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.post = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPostURL) eq(b CMsgPostURL) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.post == b.post &&
		a.pageserial == b.pageserial
}

[inline]
pub fn (a CMsgPostURL) ne(b CMsgPostURL) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPostURL) eq(b []CMsgPostURL) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPostURL) ne(b []CMsgPostURL) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgposturl() CMsgPostURL {
	return CMsgPostURL{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgposturl(o CMsgPostURL, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgposturl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPostURL) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgposturl_unpack(v)?
	return i, unpacked
}

pub struct CMsgAddHeader {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	key            string
	value          string
}

pub fn (o &CMsgAddHeader) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 2)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 3)
	}
	return res
}

pub fn cmsgaddheader_unpack(buf []byte) ?CMsgAddHeader {
	mut res := zzz_vproto_internal_new_cmsgaddheader()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgAddHeader) eq(b CMsgAddHeader) bool {
	return true && a.browser_handle == b.browser_handle && a.key == b.key && a.value == b.value
}

[inline]
pub fn (a CMsgAddHeader) ne(b CMsgAddHeader) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgAddHeader) eq(b []CMsgAddHeader) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgAddHeader) ne(b []CMsgAddHeader) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgaddheader() CMsgAddHeader {
	return CMsgAddHeader{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgaddheader(o CMsgAddHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgaddheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAddHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgaddheader_unpack(v)?
	return i, unpacked
}

pub struct CMsgStopLoad {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgStopLoad) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgstopload_unpack(buf []byte) ?CMsgStopLoad {
	mut res := zzz_vproto_internal_new_cmsgstopload()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgStopLoad) eq(b CMsgStopLoad) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgStopLoad) ne(b CMsgStopLoad) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgStopLoad) eq(b []CMsgStopLoad) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgStopLoad) ne(b []CMsgStopLoad) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgstopload() CMsgStopLoad {
	return CMsgStopLoad{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstopload(o CMsgStopLoad, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstopload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStopLoad) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstopload_unpack(v)?
	return i, unpacked
}

pub struct CMsgReload {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgReload) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgreload_unpack(buf []byte) ?CMsgReload {
	mut res := zzz_vproto_internal_new_cmsgreload()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgReload) eq(b CMsgReload) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgReload) ne(b CMsgReload) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgReload) eq(b []CMsgReload) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgReload) ne(b []CMsgReload) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgreload() CMsgReload {
	return CMsgReload{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgreload(o CMsgReload, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgreload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgReload) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgreload_unpack(v)?
	return i, unpacked
}

pub struct CMsgGoForward {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgGoForward) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsggoforward_unpack(buf []byte) ?CMsgGoForward {
	mut res := zzz_vproto_internal_new_cmsggoforward()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGoForward) eq(b CMsgGoForward) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgGoForward) ne(b CMsgGoForward) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGoForward) eq(b []CMsgGoForward) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGoForward) ne(b []CMsgGoForward) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggoforward() CMsgGoForward {
	return CMsgGoForward{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggoforward(o CMsgGoForward, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggoforward(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGoForward) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggoforward_unpack(v)?
	return i, unpacked
}

pub struct CMsgGoBack {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgGoBack) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsggoback_unpack(buf []byte) ?CMsgGoBack {
	mut res := zzz_vproto_internal_new_cmsggoback()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGoBack) eq(b CMsgGoBack) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgGoBack) ne(b CMsgGoBack) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGoBack) eq(b []CMsgGoBack) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGoBack) ne(b []CMsgGoBack) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggoback() CMsgGoBack {
	return CMsgGoBack{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggoback(o CMsgGoBack, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggoback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGoBack) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggoback_unpack(v)?
	return i, unpacked
}

pub struct CMsgWasHidden {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	hidden         bool
}

pub fn (o &CMsgWasHidden) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.hidden != bool(0) {
		res << vproto.pack_bool_field(o.hidden, 2)
	}
	return res
}

pub fn cmsgwashidden_unpack(buf []byte) ?CMsgWasHidden {
	mut res := zzz_vproto_internal_new_cmsgwashidden()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgWasHidden) eq(b CMsgWasHidden) bool {
	return true && a.browser_handle == b.browser_handle && a.hidden == b.hidden
}

[inline]
pub fn (a CMsgWasHidden) ne(b CMsgWasHidden) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgWasHidden) eq(b []CMsgWasHidden) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgWasHidden) ne(b []CMsgWasHidden) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgwashidden() CMsgWasHidden {
	return CMsgWasHidden{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgwashidden(o CMsgWasHidden, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgwashidden(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgWasHidden) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgwashidden_unpack(v)?
	return i, unpacked
}

pub struct CMsgClearHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgClearHistory) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclearhistory_unpack(buf []byte) ?CMsgClearHistory {
	mut res := zzz_vproto_internal_new_cmsgclearhistory()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClearHistory) eq(b CMsgClearHistory) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgClearHistory) ne(b CMsgClearHistory) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClearHistory) eq(b []CMsgClearHistory) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClearHistory) ne(b []CMsgClearHistory) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclearhistory() CMsgClearHistory {
	return CMsgClearHistory{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclearhistory(o CMsgClearHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclearhistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclearhistory_unpack(v)?
	return i, unpacked
}

pub struct CMsgClearAllBrowsingData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgClearAllBrowsingData) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclearallbrowsingdata_unpack(buf []byte) ?CMsgClearAllBrowsingData {
	mut res := zzz_vproto_internal_new_cmsgclearallbrowsingdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClearAllBrowsingData) eq(b CMsgClearAllBrowsingData) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgClearAllBrowsingData) ne(b CMsgClearAllBrowsingData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClearAllBrowsingData) eq(b []CMsgClearAllBrowsingData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClearAllBrowsingData) ne(b []CMsgClearAllBrowsingData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclearallbrowsingdata() CMsgClearAllBrowsingData {
	return CMsgClearAllBrowsingData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclearallbrowsingdata(o CMsgClearAllBrowsingData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclearallbrowsingdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearAllBrowsingData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclearallbrowsingdata_unpack(v)?
	return i, unpacked
}

pub struct CMsgCopy {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgCopy) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgcopy_unpack(buf []byte) ?CMsgCopy {
	mut res := zzz_vproto_internal_new_cmsgcopy()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgCopy) eq(b CMsgCopy) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgCopy) ne(b CMsgCopy) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgCopy) eq(b []CMsgCopy) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgCopy) ne(b []CMsgCopy) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgcopy() CMsgCopy {
	return CMsgCopy{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgcopy(o CMsgCopy, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgcopy(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCopy) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcopy_unpack(v)?
	return i, unpacked
}

pub struct CMsgPaste {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgPaste) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgpaste_unpack(buf []byte) ?CMsgPaste {
	mut res := zzz_vproto_internal_new_cmsgpaste()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPaste) eq(b CMsgPaste) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgPaste) ne(b CMsgPaste) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPaste) eq(b []CMsgPaste) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPaste) ne(b []CMsgPaste) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpaste() CMsgPaste {
	return CMsgPaste{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpaste(o CMsgPaste, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpaste(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPaste) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpaste_unpack(v)?
	return i, unpacked
}

pub struct CMsgExecuteJavaScript {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	script         string
}

pub fn (o &CMsgExecuteJavaScript) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.script != '' {
		res << vproto.pack_string_field(o.script, 2)
	}
	return res
}

pub fn cmsgexecutejavascript_unpack(buf []byte) ?CMsgExecuteJavaScript {
	mut res := zzz_vproto_internal_new_cmsgexecutejavascript()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.script = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgExecuteJavaScript) eq(b CMsgExecuteJavaScript) bool {
	return true && a.browser_handle == b.browser_handle && a.script == b.script
}

[inline]
pub fn (a CMsgExecuteJavaScript) ne(b CMsgExecuteJavaScript) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgExecuteJavaScript) eq(b []CMsgExecuteJavaScript) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgExecuteJavaScript) ne(b []CMsgExecuteJavaScript) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgexecutejavascript() CMsgExecuteJavaScript {
	return CMsgExecuteJavaScript{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgexecutejavascript(o CMsgExecuteJavaScript, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgexecutejavascript(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgExecuteJavaScript) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgexecutejavascript_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetFocus {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	focus          bool
}

pub fn (o &CMsgSetFocus) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.focus != bool(0) {
		res << vproto.pack_bool_field(o.focus, 2)
	}
	return res
}

pub fn cmsgsetfocus_unpack(buf []byte) ?CMsgSetFocus {
	mut res := zzz_vproto_internal_new_cmsgsetfocus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.focus = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetFocus) eq(b CMsgSetFocus) bool {
	return true && a.browser_handle == b.browser_handle && a.focus == b.focus
}

[inline]
pub fn (a CMsgSetFocus) ne(b CMsgSetFocus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetFocus) eq(b []CMsgSetFocus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetFocus) ne(b []CMsgSetFocus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetfocus() CMsgSetFocus {
	return CMsgSetFocus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetfocus(o CMsgSetFocus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetfocus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetFocus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetfocus_unpack(v)?
	return i, unpacked
}

pub struct CMsgHorizontalScrollBarSize {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgHorizontalScrollBarSize) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghorizontalscrollbarsize_unpack(buf []byte) ?CMsgHorizontalScrollBarSize {
	mut res := zzz_vproto_internal_new_cmsghorizontalscrollbarsize()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgHorizontalScrollBarSize) eq(b CMsgHorizontalScrollBarSize) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgHorizontalScrollBarSize) ne(b CMsgHorizontalScrollBarSize) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgHorizontalScrollBarSize) eq(b []CMsgHorizontalScrollBarSize) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgHorizontalScrollBarSize) ne(b []CMsgHorizontalScrollBarSize) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsghorizontalscrollbarsize() CMsgHorizontalScrollBarSize {
	return CMsgHorizontalScrollBarSize{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghorizontalscrollbarsize(o CMsgHorizontalScrollBarSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghorizontalscrollbarsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHorizontalScrollBarSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghorizontalscrollbarsize_unpack(v)?
	return i, unpacked
}

pub struct CMsgHorizontalScrollBarSizeResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scroll_max     u32
	scroll         u32
	zoom           f32
	visible        bool
	page_size      u32
}

pub fn (o &CMsgHorizontalScrollBarSizeResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scroll_max != u32(0) {
		res << vproto.pack_uint32_field(o.scroll_max, 6)
	}
	if o.scroll != u32(0) {
		res << vproto.pack_uint32_field(o.scroll, 7)
	}
	if o.zoom != f32(0) {
		res << vproto.pack_float_field(o.zoom, 8)
	}
	if o.visible != bool(0) {
		res << vproto.pack_bool_field(o.visible, 9)
	}
	if o.page_size != u32(0) {
		res << vproto.pack_uint32_field(o.page_size, 10)
	}
	return res
}

pub fn cmsghorizontalscrollbarsizeresponse_unpack(buf []byte) ?CMsgHorizontalScrollBarSizeResponse {
	mut res := zzz_vproto_internal_new_cmsghorizontalscrollbarsizeresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll_max = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.visible = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgHorizontalScrollBarSizeResponse) eq(b CMsgHorizontalScrollBarSizeResponse) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.scroll_max == b.scroll_max && a.scroll == b.scroll &&
		a.zoom == b.zoom && a.visible == b.visible &&
		a.page_size == b.page_size
}

[inline]
pub fn (a CMsgHorizontalScrollBarSizeResponse) ne(b CMsgHorizontalScrollBarSizeResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgHorizontalScrollBarSizeResponse) eq(b []CMsgHorizontalScrollBarSizeResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgHorizontalScrollBarSizeResponse) ne(b []CMsgHorizontalScrollBarSizeResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsghorizontalscrollbarsizeresponse() CMsgHorizontalScrollBarSizeResponse {
	return CMsgHorizontalScrollBarSizeResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghorizontalscrollbarsizeresponse(o CMsgHorizontalScrollBarSizeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghorizontalscrollbarsizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHorizontalScrollBarSizeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghorizontalscrollbarsizeresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgVerticalScrollBarSize {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgVerticalScrollBarSize) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgverticalscrollbarsize_unpack(buf []byte) ?CMsgVerticalScrollBarSize {
	mut res := zzz_vproto_internal_new_cmsgverticalscrollbarsize()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgVerticalScrollBarSize) eq(b CMsgVerticalScrollBarSize) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgVerticalScrollBarSize) ne(b CMsgVerticalScrollBarSize) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgVerticalScrollBarSize) eq(b []CMsgVerticalScrollBarSize) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgVerticalScrollBarSize) ne(b []CMsgVerticalScrollBarSize) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgverticalscrollbarsize() CMsgVerticalScrollBarSize {
	return CMsgVerticalScrollBarSize{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgverticalscrollbarsize(o CMsgVerticalScrollBarSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgverticalscrollbarsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgVerticalScrollBarSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgverticalscrollbarsize_unpack(v)?
	return i, unpacked
}

pub struct CMsgVerticalScrollBarSizeResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scroll_max     u32
	scroll         u32
	zoom           f32
	visible        bool
	page_size      u32
}

pub fn (o &CMsgVerticalScrollBarSizeResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scroll_max != u32(0) {
		res << vproto.pack_uint32_field(o.scroll_max, 6)
	}
	if o.scroll != u32(0) {
		res << vproto.pack_uint32_field(o.scroll, 7)
	}
	if o.zoom != f32(0) {
		res << vproto.pack_float_field(o.zoom, 8)
	}
	if o.visible != bool(0) {
		res << vproto.pack_bool_field(o.visible, 9)
	}
	if o.page_size != u32(0) {
		res << vproto.pack_uint32_field(o.page_size, 10)
	}
	return res
}

pub fn cmsgverticalscrollbarsizeresponse_unpack(buf []byte) ?CMsgVerticalScrollBarSizeResponse {
	mut res := zzz_vproto_internal_new_cmsgverticalscrollbarsizeresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll_max = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.visible = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgVerticalScrollBarSizeResponse) eq(b CMsgVerticalScrollBarSizeResponse) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.scroll_max == b.scroll_max && a.scroll == b.scroll &&
		a.zoom == b.zoom && a.visible == b.visible &&
		a.page_size == b.page_size
}

[inline]
pub fn (a CMsgVerticalScrollBarSizeResponse) ne(b CMsgVerticalScrollBarSizeResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgVerticalScrollBarSizeResponse) eq(b []CMsgVerticalScrollBarSizeResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgVerticalScrollBarSizeResponse) ne(b []CMsgVerticalScrollBarSizeResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgverticalscrollbarsizeresponse() CMsgVerticalScrollBarSizeResponse {
	return CMsgVerticalScrollBarSizeResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgverticalscrollbarsizeresponse(o CMsgVerticalScrollBarSizeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgverticalscrollbarsizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgVerticalScrollBarSizeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgverticalscrollbarsizeresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgFind {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	find           string
	infind         bool
	reverse        bool = false
}

pub fn (o &CMsgFind) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.find != '' {
		res << vproto.pack_string_field(o.find, 2)
	}
	if o.infind != bool(0) {
		res << vproto.pack_bool_field(o.infind, 3)
	}
	if o.reverse != bool(0) {
		res << vproto.pack_bool_field(o.reverse, 4)
	}
	return res
}

pub fn cmsgfind_unpack(buf []byte) ?CMsgFind {
	mut res := zzz_vproto_internal_new_cmsgfind()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.find = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.infind = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reverse = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFind) eq(b CMsgFind) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.find == b.find && a.infind == b.infind &&
		a.reverse == b.reverse
}

[inline]
pub fn (a CMsgFind) ne(b CMsgFind) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFind) eq(b []CMsgFind) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFind) ne(b []CMsgFind) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfind() CMsgFind {
	return CMsgFind{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfind(o CMsgFind, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfind(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFind) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfind_unpack(v)?
	return i, unpacked
}

pub struct CMsgStopFind {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgStopFind) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgstopfind_unpack(buf []byte) ?CMsgStopFind {
	mut res := zzz_vproto_internal_new_cmsgstopfind()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgStopFind) eq(b CMsgStopFind) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgStopFind) ne(b CMsgStopFind) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgStopFind) eq(b []CMsgStopFind) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgStopFind) ne(b []CMsgStopFind) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgstopfind() CMsgStopFind {
	return CMsgStopFind{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstopfind(o CMsgStopFind, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstopfind(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStopFind) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstopfind_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetHorizontalScroll {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scroll         u32
}

pub fn (o &CMsgSetHorizontalScroll) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scroll != u32(0) {
		res << vproto.pack_uint32_field(o.scroll, 2)
	}
	return res
}

pub fn cmsgsethorizontalscroll_unpack(buf []byte) ?CMsgSetHorizontalScroll {
	mut res := zzz_vproto_internal_new_cmsgsethorizontalscroll()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetHorizontalScroll) eq(b CMsgSetHorizontalScroll) bool {
	return true && a.browser_handle == b.browser_handle && a.scroll == b.scroll
}

[inline]
pub fn (a CMsgSetHorizontalScroll) ne(b CMsgSetHorizontalScroll) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetHorizontalScroll) eq(b []CMsgSetHorizontalScroll) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetHorizontalScroll) ne(b []CMsgSetHorizontalScroll) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsethorizontalscroll() CMsgSetHorizontalScroll {
	return CMsgSetHorizontalScroll{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsethorizontalscroll(o CMsgSetHorizontalScroll, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsethorizontalscroll(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetHorizontalScroll) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsethorizontalscroll_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetVerticalScroll {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scroll         u32
}

pub fn (o &CMsgSetVerticalScroll) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scroll != u32(0) {
		res << vproto.pack_uint32_field(o.scroll, 2)
	}
	return res
}

pub fn cmsgsetverticalscroll_unpack(buf []byte) ?CMsgSetVerticalScroll {
	mut res := zzz_vproto_internal_new_cmsgsetverticalscroll()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetVerticalScroll) eq(b CMsgSetVerticalScroll) bool {
	return true && a.browser_handle == b.browser_handle && a.scroll == b.scroll
}

[inline]
pub fn (a CMsgSetVerticalScroll) ne(b CMsgSetVerticalScroll) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetVerticalScroll) eq(b []CMsgSetVerticalScroll) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetVerticalScroll) ne(b []CMsgSetVerticalScroll) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetverticalscroll() CMsgSetVerticalScroll {
	return CMsgSetVerticalScroll{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetverticalscroll(o CMsgSetVerticalScroll, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetverticalscroll(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetVerticalScroll) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetverticalscroll_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetZoomLevel {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	zoom           f64
}

pub fn (o &CMsgSetZoomLevel) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.zoom != f64(0) {
		res << vproto.pack_double_field(o.zoom, 2)
	}
	return res
}

pub fn cmsgsetzoomlevel_unpack(buf []byte) ?CMsgSetZoomLevel {
	mut res := zzz_vproto_internal_new_cmsgsetzoomlevel()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetZoomLevel) eq(b CMsgSetZoomLevel) bool {
	return true && a.browser_handle == b.browser_handle && a.zoom == b.zoom
}

[inline]
pub fn (a CMsgSetZoomLevel) ne(b CMsgSetZoomLevel) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetZoomLevel) eq(b []CMsgSetZoomLevel) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetZoomLevel) ne(b []CMsgSetZoomLevel) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetzoomlevel() CMsgSetZoomLevel {
	return CMsgSetZoomLevel{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetzoomlevel(o CMsgSetZoomLevel, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetzoomlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetZoomLevel) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetzoomlevel_unpack(v)?
	return i, unpacked
}

pub struct CMsgViewSource {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgViewSource) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgviewsource_unpack(buf []byte) ?CMsgViewSource {
	mut res := zzz_vproto_internal_new_cmsgviewsource()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgViewSource) eq(b CMsgViewSource) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgViewSource) ne(b CMsgViewSource) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgViewSource) eq(b []CMsgViewSource) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgViewSource) ne(b []CMsgViewSource) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgviewsource() CMsgViewSource {
	return CMsgViewSource{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgviewsource(o CMsgViewSource, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgviewsource(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgViewSource) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgviewsource_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserReady {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	vr_overlay_key string
	hwnd_browser   u64
}

pub fn (o &CMsgBrowserReady) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.vr_overlay_key != '' {
		res << vproto.pack_string_field(o.vr_overlay_key, 2)
	}
	if o.hwnd_browser != u64(0) {
		res << vproto.pack_64bit_field(o.hwnd_browser, 3)
	}
	return res
}

pub fn cmsgbrowserready_unpack(buf []byte) ?CMsgBrowserReady {
	mut res := zzz_vproto_internal_new_cmsgbrowserready()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_overlay_key = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hwnd_browser = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBrowserReady) eq(b CMsgBrowserReady) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.vr_overlay_key == b.vr_overlay_key &&
		a.hwnd_browser == b.hwnd_browser
}

[inline]
pub fn (a CMsgBrowserReady) ne(b CMsgBrowserReady) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBrowserReady) eq(b []CMsgBrowserReady) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBrowserReady) ne(b []CMsgBrowserReady) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbrowserready() CMsgBrowserReady {
	return CMsgBrowserReady{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbrowserready(o CMsgBrowserReady, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbrowserready(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserReady) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserready_unpack(v)?
	return i, unpacked
}

pub struct CMsgURLChanged {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	postdata       string
	bisredirect    bool
	pagetitle      string
	bnewnavigation bool
}

pub fn (o &CMsgURLChanged) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.postdata != '' {
		res << vproto.pack_string_field(o.postdata, 3)
	}
	if o.bisredirect != bool(0) {
		res << vproto.pack_bool_field(o.bisredirect, 4)
	}
	if o.pagetitle != '' {
		res << vproto.pack_string_field(o.pagetitle, 5)
	}
	if o.bnewnavigation != bool(0) {
		res << vproto.pack_bool_field(o.bnewnavigation, 6)
	}
	return res
}

pub fn cmsgurlchanged_unpack(buf []byte) ?CMsgURLChanged {
	mut res := zzz_vproto_internal_new_cmsgurlchanged()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.postdata = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bisredirect = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pagetitle = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bnewnavigation = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgURLChanged) eq(b CMsgURLChanged) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.postdata == b.postdata &&
		a.bisredirect == b.bisredirect && a.pagetitle == b.pagetitle &&
		a.bnewnavigation == b.bnewnavigation
}

[inline]
pub fn (a CMsgURLChanged) ne(b CMsgURLChanged) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgURLChanged) eq(b []CMsgURLChanged) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgURLChanged) ne(b []CMsgURLChanged) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgurlchanged() CMsgURLChanged {
	return CMsgURLChanged{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgurlchanged(o CMsgURLChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgurlchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgURLChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgurlchanged_unpack(v)?
	return i, unpacked
}

pub struct CHTMLHeader {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
}

pub fn (o &CHTMLHeader) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn chtmlheader_unpack(buf []byte) ?CHTMLHeader {
	mut res := zzz_vproto_internal_new_chtmlheader()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CHTMLHeader) eq(b CHTMLHeader) bool {
	return true && a.key == b.key && a.value == b.value
}

[inline]
pub fn (a CHTMLHeader) ne(b CHTMLHeader) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CHTMLHeader) eq(b []CHTMLHeader) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CHTMLHeader) ne(b []CHTMLHeader) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_chtmlheader() CHTMLHeader {
	return CHTMLHeader{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_chtmlheader(o CHTMLHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_chtmlheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CHTMLHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chtmlheader_unpack(v)?
	return i, unpacked
}

pub struct CHTMLPageSecurityInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bissecure      bool = false
	bhascerterror  bool = false
	issuername     string
	certname       string
	certexpiry     int = 0
	ncertbits      int = 0
	bisevcert      bool = false
}

pub fn (o &CHTMLPageSecurityInfo) pack() []byte {
	mut res := []byte{}
	if o.bissecure != bool(0) {
		res << vproto.pack_bool_field(o.bissecure, 1)
	}
	if o.bhascerterror != bool(0) {
		res << vproto.pack_bool_field(o.bhascerterror, 2)
	}
	if o.issuername != '' {
		res << vproto.pack_string_field(o.issuername, 3)
	}
	if o.certname != '' {
		res << vproto.pack_string_field(o.certname, 4)
	}
	if o.certexpiry != int(0) {
		res << vproto.pack_int32_field(o.certexpiry, 5)
	}
	if o.ncertbits != int(0) {
		res << vproto.pack_int32_field(o.ncertbits, 6)
	}
	if o.bisevcert != bool(0) {
		res << vproto.pack_bool_field(o.bisevcert, 7)
	}
	return res
}

pub fn chtmlpagesecurityinfo_unpack(buf []byte) ?CHTMLPageSecurityInfo {
	mut res := zzz_vproto_internal_new_chtmlpagesecurityinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bissecure = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bhascerterror = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.issuername = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.certname = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.certexpiry = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ncertbits = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bisevcert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CHTMLPageSecurityInfo) eq(b CHTMLPageSecurityInfo) bool {
	return true && a.bissecure == b.bissecure &&
		a.bhascerterror == b.bhascerterror &&
		a.issuername == b.issuername && a.certname == b.certname &&
		a.certexpiry == b.certexpiry && a.ncertbits == b.ncertbits &&
		a.bisevcert == b.bisevcert
}

[inline]
pub fn (a CHTMLPageSecurityInfo) ne(b CHTMLPageSecurityInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CHTMLPageSecurityInfo) eq(b []CHTMLPageSecurityInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CHTMLPageSecurityInfo) ne(b []CHTMLPageSecurityInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_chtmlpagesecurityinfo() CHTMLPageSecurityInfo {
	return CHTMLPageSecurityInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_chtmlpagesecurityinfo(o CHTMLPageSecurityInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_chtmlpagesecurityinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CHTMLPageSecurityInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chtmlpagesecurityinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgFinishedRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	pagetitle      string
}

pub fn (o &CMsgFinishedRequest) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.pagetitle != '' {
		res << vproto.pack_string_field(o.pagetitle, 3)
	}
	return res
}

pub fn cmsgfinishedrequest_unpack(buf []byte) ?CMsgFinishedRequest {
	mut res := zzz_vproto_internal_new_cmsgfinishedrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pagetitle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFinishedRequest) eq(b CMsgFinishedRequest) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.pagetitle == b.pagetitle
}

[inline]
pub fn (a CMsgFinishedRequest) ne(b CMsgFinishedRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFinishedRequest) eq(b []CMsgFinishedRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFinishedRequest) ne(b []CMsgFinishedRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfinishedrequest() CMsgFinishedRequest {
	return CMsgFinishedRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfinishedrequest(o CMsgFinishedRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfinishedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFinishedRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfinishedrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgLoadedRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	pagetitle      string
	headers        []CHTMLHeader
}

pub fn (o &CMsgLoadedRequest) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.pagetitle != '' {
		res << vproto.pack_string_field(o.pagetitle, 3)
	}
	// [packed=false]
	for _, x in o.headers {
		res << zzz_vproto_internal_pack_chtmlheader(x, 5)
	}
	return res
}

pub fn cmsgloadedrequest_unpack(buf []byte) ?CMsgLoadedRequest {
	mut res := zzz_vproto_internal_new_cmsgloadedrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pagetitle = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_chtmlheader(cur_buf, tag_wiretype.wire_type)?
				res.headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgLoadedRequest) eq(b CMsgLoadedRequest) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.pagetitle == b.pagetitle && a.headers.eq(b.headers)
}

[inline]
pub fn (a CMsgLoadedRequest) ne(b CMsgLoadedRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgLoadedRequest) eq(b []CMsgLoadedRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgLoadedRequest) ne(b []CMsgLoadedRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgloadedrequest() CMsgLoadedRequest {
	return CMsgLoadedRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgloadedrequest(o CMsgLoadedRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgloadedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadedRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgloadedrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgPageSecurity {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	security_info  CHTMLPageSecurityInfo
}

pub fn (o &CMsgPageSecurity) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.security_info.ne(zzz_vproto_internal_new_chtmlpagesecurityinfo()) {
		res << zzz_vproto_internal_pack_chtmlpagesecurityinfo(o.security_info, 3)
	}
	return res
}

pub fn cmsgpagesecurity_unpack(buf []byte) ?CMsgPageSecurity {
	mut res := zzz_vproto_internal_new_cmsgpagesecurity()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_chtmlpagesecurityinfo(cur_buf, tag_wiretype.wire_type)?
				res.security_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPageSecurity) eq(b CMsgPageSecurity) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.security_info.eq(b.security_info)
}

[inline]
pub fn (a CMsgPageSecurity) ne(b CMsgPageSecurity) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPageSecurity) eq(b []CMsgPageSecurity) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPageSecurity) ne(b []CMsgPageSecurity) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpagesecurity() CMsgPageSecurity {
	return CMsgPageSecurity{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpagesecurity(o CMsgPageSecurity, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpagesecurity(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPageSecurity) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpagesecurity_unpack(v)?
	return i, unpacked
}

pub struct CMsgStartRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	target         string
	postdata       string
	bisredirect    bool
}

pub fn (o &CMsgStartRequest) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.target != '' {
		res << vproto.pack_string_field(o.target, 3)
	}
	if o.postdata != '' {
		res << vproto.pack_string_field(o.postdata, 4)
	}
	if o.bisredirect != bool(0) {
		res << vproto.pack_bool_field(o.bisredirect, 5)
	}
	return res
}

pub fn cmsgstartrequest_unpack(buf []byte) ?CMsgStartRequest {
	mut res := zzz_vproto_internal_new_cmsgstartrequest()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.target = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.postdata = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bisredirect = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgStartRequest) eq(b CMsgStartRequest) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.target == b.target &&
		a.postdata == b.postdata && a.bisredirect == b.bisredirect
}

[inline]
pub fn (a CMsgStartRequest) ne(b CMsgStartRequest) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgStartRequest) eq(b []CMsgStartRequest) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgStartRequest) ne(b []CMsgStartRequest) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgstartrequest() CMsgStartRequest {
	return CMsgStartRequest{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstartrequest(o CMsgStartRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstartrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstartrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgStartRequestResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	ballow         bool
}

pub fn (o &CMsgStartRequestResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.ballow != bool(0) {
		res << vproto.pack_bool_field(o.ballow, 2)
	}
	return res
}

pub fn cmsgstartrequestresponse_unpack(buf []byte) ?CMsgStartRequestResponse {
	mut res := zzz_vproto_internal_new_cmsgstartrequestresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ballow = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgStartRequestResponse) eq(b CMsgStartRequestResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.ballow == b.ballow
}

[inline]
pub fn (a CMsgStartRequestResponse) ne(b CMsgStartRequestResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgStartRequestResponse) eq(b []CMsgStartRequestResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgStartRequestResponse) ne(b []CMsgStartRequestResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgstartrequestresponse() CMsgStartRequestResponse {
	return CMsgStartRequestResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstartrequestresponse(o CMsgStartRequestResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstartrequestresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartRequestResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstartrequestresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowPopup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgShowPopup) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgshowpopup_unpack(buf []byte) ?CMsgShowPopup {
	mut res := zzz_vproto_internal_new_cmsgshowpopup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgShowPopup) eq(b CMsgShowPopup) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgShowPopup) ne(b CMsgShowPopup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgShowPopup) eq(b []CMsgShowPopup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgShowPopup) ne(b []CMsgShowPopup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgshowpopup() CMsgShowPopup {
	return CMsgShowPopup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowpopup(o CMsgShowPopup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowpopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowPopup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowpopup_unpack(v)?
	return i, unpacked
}

pub struct CMsgHidePopup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgHidePopup) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghidepopup_unpack(buf []byte) ?CMsgHidePopup {
	mut res := zzz_vproto_internal_new_cmsghidepopup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgHidePopup) eq(b CMsgHidePopup) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgHidePopup) ne(b CMsgHidePopup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgHidePopup) eq(b []CMsgHidePopup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgHidePopup) ne(b []CMsgHidePopup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsghidepopup() CMsgHidePopup {
	return CMsgHidePopup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghidepopup(o CMsgHidePopup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghidepopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHidePopup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghidepopup_unpack(v)?
	return i, unpacked
}

pub struct CMsgSizePopup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              int
	y              int
	wide           u32
	tall           u32
}

pub fn (o &CMsgSizePopup) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.wide != u32(0) {
		res << vproto.pack_uint32_field(o.wide, 4)
	}
	if o.tall != u32(0) {
		res << vproto.pack_uint32_field(o.tall, 5)
	}
	return res
}

pub fn cmsgsizepopup_unpack(buf []byte) ?CMsgSizePopup {
	mut res := zzz_vproto_internal_new_cmsgsizepopup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSizePopup) eq(b CMsgSizePopup) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.x == b.x && a.y == b.y && a.wide == b.wide &&
		a.tall == b.tall
}

[inline]
pub fn (a CMsgSizePopup) ne(b CMsgSizePopup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSizePopup) eq(b []CMsgSizePopup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSizePopup) ne(b []CMsgSizePopup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsizepopup() CMsgSizePopup {
	return CMsgSizePopup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsizepopup(o CMsgSizePopup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsizepopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSizePopup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsizepopup_unpack(v)?
	return i, unpacked
}

pub struct CMsgOpenNewTab {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	bforeground    bool
}

pub fn (o &CMsgOpenNewTab) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.bforeground != bool(0) {
		res << vproto.pack_bool_field(o.bforeground, 3)
	}
	return res
}

pub fn cmsgopennewtab_unpack(buf []byte) ?CMsgOpenNewTab {
	mut res := zzz_vproto_internal_new_cmsgopennewtab()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bforeground = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgOpenNewTab) eq(b CMsgOpenNewTab) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.bforeground == b.bforeground
}

[inline]
pub fn (a CMsgOpenNewTab) ne(b CMsgOpenNewTab) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgOpenNewTab) eq(b []CMsgOpenNewTab) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgOpenNewTab) ne(b []CMsgOpenNewTab) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgopennewtab() CMsgOpenNewTab {
	return CMsgOpenNewTab{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgopennewtab(o CMsgOpenNewTab, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgopennewtab(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenNewTab) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgopennewtab_unpack(v)?
	return i, unpacked
}

pub struct CMsgPopupHTMLWindow {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	browser_handle  u32
	url             string
	x               int = -2147483648
	y               int = -2147483648
	wide            u32
	tall            u32
	popup_index     u32
	trusted_creator bool
}

pub fn (o &CMsgPopupHTMLWindow) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 3)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 4)
	}
	if o.wide != u32(0) {
		res << vproto.pack_uint32_field(o.wide, 5)
	}
	if o.tall != u32(0) {
		res << vproto.pack_uint32_field(o.tall, 6)
	}
	if o.popup_index != u32(0) {
		res << vproto.pack_uint32_field(o.popup_index, 7)
	}
	if o.trusted_creator != bool(0) {
		res << vproto.pack_bool_field(o.trusted_creator, 8)
	}
	return res
}

pub fn cmsgpopuphtmlwindow_unpack(buf []byte) ?CMsgPopupHTMLWindow {
	mut res := zzz_vproto_internal_new_cmsgpopuphtmlwindow()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.popup_index = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.trusted_creator = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPopupHTMLWindow) eq(b CMsgPopupHTMLWindow) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.x == b.x && a.y == b.y &&
		a.wide == b.wide && a.tall == b.tall &&
		a.popup_index == b.popup_index && a.trusted_creator == b.trusted_creator
}

[inline]
pub fn (a CMsgPopupHTMLWindow) ne(b CMsgPopupHTMLWindow) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPopupHTMLWindow) eq(b []CMsgPopupHTMLWindow) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPopupHTMLWindow) ne(b []CMsgPopupHTMLWindow) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpopuphtmlwindow() CMsgPopupHTMLWindow {
	return CMsgPopupHTMLWindow{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpopuphtmlwindow(o CMsgPopupHTMLWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpopuphtmlwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPopupHTMLWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpopuphtmlwindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgPopupHTMLWindowResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	ballow         bool
}

pub fn (o &CMsgPopupHTMLWindowResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.ballow != bool(0) {
		res << vproto.pack_bool_field(o.ballow, 2)
	}
	return res
}

pub fn cmsgpopuphtmlwindowresponse_unpack(buf []byte) ?CMsgPopupHTMLWindowResponse {
	mut res := zzz_vproto_internal_new_cmsgpopuphtmlwindowresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ballow = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPopupHTMLWindowResponse) eq(b CMsgPopupHTMLWindowResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.ballow == b.ballow
}

[inline]
pub fn (a CMsgPopupHTMLWindowResponse) ne(b CMsgPopupHTMLWindowResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPopupHTMLWindowResponse) eq(b []CMsgPopupHTMLWindowResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPopupHTMLWindowResponse) ne(b []CMsgPopupHTMLWindowResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpopuphtmlwindowresponse() CMsgPopupHTMLWindowResponse {
	return CMsgPopupHTMLWindowResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpopuphtmlwindowresponse(o CMsgPopupHTMLWindowResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpopuphtmlwindowresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPopupHTMLWindowResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpopuphtmlwindowresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetHTMLTitle {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	title          string
}

pub fn (o &CMsgSetHTMLTitle) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.title != '' {
		res << vproto.pack_string_field(o.title, 2)
	}
	return res
}

pub fn cmsgsethtmltitle_unpack(buf []byte) ?CMsgSetHTMLTitle {
	mut res := zzz_vproto_internal_new_cmsgsethtmltitle()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetHTMLTitle) eq(b CMsgSetHTMLTitle) bool {
	return true && a.browser_handle == b.browser_handle && a.title == b.title
}

[inline]
pub fn (a CMsgSetHTMLTitle) ne(b CMsgSetHTMLTitle) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetHTMLTitle) eq(b []CMsgSetHTMLTitle) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetHTMLTitle) ne(b []CMsgSetHTMLTitle) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsethtmltitle() CMsgSetHTMLTitle {
	return CMsgSetHTMLTitle{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsethtmltitle(o CMsgSetHTMLTitle, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsethtmltitle(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetHTMLTitle) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsethtmltitle_unpack(v)?
	return i, unpacked
}

pub struct CMsgLoadingResource {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
}

pub fn (o &CMsgLoadingResource) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	return res
}

pub fn cmsgloadingresource_unpack(buf []byte) ?CMsgLoadingResource {
	mut res := zzz_vproto_internal_new_cmsgloadingresource()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgLoadingResource) eq(b CMsgLoadingResource) bool {
	return true && a.browser_handle == b.browser_handle && a.url == b.url
}

[inline]
pub fn (a CMsgLoadingResource) ne(b CMsgLoadingResource) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgLoadingResource) eq(b []CMsgLoadingResource) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgLoadingResource) ne(b []CMsgLoadingResource) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgloadingresource() CMsgLoadingResource {
	return CMsgLoadingResource{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgloadingresource(o CMsgLoadingResource, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgloadingresource(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadingResource) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgloadingresource_unpack(v)?
	return i, unpacked
}

pub struct CMsgStatusText {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	text           string
}

pub fn (o &CMsgStatusText) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.text != '' {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgstatustext_unpack(buf []byte) ?CMsgStatusText {
	mut res := zzz_vproto_internal_new_cmsgstatustext()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgStatusText) eq(b CMsgStatusText) bool {
	return true && a.browser_handle == b.browser_handle && a.text == b.text
}

[inline]
pub fn (a CMsgStatusText) ne(b CMsgStatusText) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgStatusText) eq(b []CMsgStatusText) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgStatusText) ne(b []CMsgStatusText) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgstatustext() CMsgStatusText {
	return CMsgStatusText{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstatustext(o CMsgStatusText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstatustext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStatusText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstatustext_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetCursor {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	cursor         u32
	custom_data    []byte
	wide           u32
	tall           u32
	xhotspot       u32
	yhotspot       u32
}

pub fn (o &CMsgSetCursor) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.cursor != u32(0) {
		res << vproto.pack_uint32_field(o.cursor, 2)
	}
	if o.custom_data != []byte{} {
		res << vproto.pack_bytes_field(o.custom_data, 3)
	}
	if o.wide != u32(0) {
		res << vproto.pack_uint32_field(o.wide, 4)
	}
	if o.tall != u32(0) {
		res << vproto.pack_uint32_field(o.tall, 5)
	}
	if o.xhotspot != u32(0) {
		res << vproto.pack_uint32_field(o.xhotspot, 6)
	}
	if o.yhotspot != u32(0) {
		res << vproto.pack_uint32_field(o.yhotspot, 7)
	}
	return res
}

pub fn cmsgsetcursor_unpack(buf []byte) ?CMsgSetCursor {
	mut res := zzz_vproto_internal_new_cmsgsetcursor()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.custom_data = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.xhotspot = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.yhotspot = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetCursor) eq(b CMsgSetCursor) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.cursor == b.cursor && a.custom_data == b.custom_data &&
		a.wide == b.wide && a.tall == b.tall &&
		a.xhotspot == b.xhotspot && a.yhotspot == b.yhotspot
}

[inline]
pub fn (a CMsgSetCursor) ne(b CMsgSetCursor) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetCursor) eq(b []CMsgSetCursor) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetCursor) ne(b []CMsgSetCursor) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetcursor() CMsgSetCursor {
	return CMsgSetCursor{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetcursor(o CMsgSetCursor, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetcursor(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetCursor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetcursor_unpack(v)?
	return i, unpacked
}

pub struct CMsgFileLoadDialog {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	title          string
	initialfile    string
	accept_types   []string
	is_save        bool
}

pub fn (o &CMsgFileLoadDialog) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.title != '' {
		res << vproto.pack_string_field(o.title, 2)
	}
	if o.initialfile != '' {
		res << vproto.pack_string_field(o.initialfile, 3)
	}
	// [packed=false]
	for _, x in o.accept_types {
		res << vproto.pack_string_field(x, 4)
	}
	if o.is_save != bool(0) {
		res << vproto.pack_bool_field(o.is_save, 5)
	}
	return res
}

pub fn cmsgfileloaddialog_unpack(buf []byte) ?CMsgFileLoadDialog {
	mut res := zzz_vproto_internal_new_cmsgfileloaddialog()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.initialfile = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.accept_types << v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_save = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFileLoadDialog) eq(b CMsgFileLoadDialog) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.title == b.title && a.initialfile == b.initialfile &&
		a.accept_types == b.accept_types &&
		a.is_save == b.is_save
}

[inline]
pub fn (a CMsgFileLoadDialog) ne(b CMsgFileLoadDialog) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFileLoadDialog) eq(b []CMsgFileLoadDialog) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFileLoadDialog) ne(b []CMsgFileLoadDialog) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfileloaddialog() CMsgFileLoadDialog {
	return CMsgFileLoadDialog{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfileloaddialog(o CMsgFileLoadDialog, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfileloaddialog(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFileLoadDialog) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfileloaddialog_unpack(v)?
	return i, unpacked
}

pub struct CMsgFileLoadDialogResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	files          []string
}

pub fn (o &CMsgFileLoadDialogResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	// [packed=false]
	for _, x in o.files {
		res << vproto.pack_string_field(x, 2)
	}
	return res
}

pub fn cmsgfileloaddialogresponse_unpack(buf []byte) ?CMsgFileLoadDialogResponse {
	mut res := zzz_vproto_internal_new_cmsgfileloaddialogresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFileLoadDialogResponse) eq(b CMsgFileLoadDialogResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.files == b.files
}

[inline]
pub fn (a CMsgFileLoadDialogResponse) ne(b CMsgFileLoadDialogResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFileLoadDialogResponse) eq(b []CMsgFileLoadDialogResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFileLoadDialogResponse) ne(b []CMsgFileLoadDialogResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfileloaddialogresponse() CMsgFileLoadDialogResponse {
	return CMsgFileLoadDialogResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfileloaddialogresponse(o CMsgFileLoadDialogResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfileloaddialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFileLoadDialogResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfileloaddialogresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowToolTip {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	text           string
}

pub fn (o &CMsgShowToolTip) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.text != '' {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgshowtooltip_unpack(buf []byte) ?CMsgShowToolTip {
	mut res := zzz_vproto_internal_new_cmsgshowtooltip()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgShowToolTip) eq(b CMsgShowToolTip) bool {
	return true && a.browser_handle == b.browser_handle && a.text == b.text
}

[inline]
pub fn (a CMsgShowToolTip) ne(b CMsgShowToolTip) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgShowToolTip) eq(b []CMsgShowToolTip) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgShowToolTip) ne(b []CMsgShowToolTip) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgshowtooltip() CMsgShowToolTip {
	return CMsgShowToolTip{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowtooltip(o CMsgShowToolTip, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowtooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowToolTip) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowtooltip_unpack(v)?
	return i, unpacked
}

pub struct CMsgUpdateToolTip {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	text           string
}

pub fn (o &CMsgUpdateToolTip) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.text != '' {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgupdatetooltip_unpack(buf []byte) ?CMsgUpdateToolTip {
	mut res := zzz_vproto_internal_new_cmsgupdatetooltip()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgUpdateToolTip) eq(b CMsgUpdateToolTip) bool {
	return true && a.browser_handle == b.browser_handle && a.text == b.text
}

[inline]
pub fn (a CMsgUpdateToolTip) ne(b CMsgUpdateToolTip) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgUpdateToolTip) eq(b []CMsgUpdateToolTip) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgUpdateToolTip) ne(b []CMsgUpdateToolTip) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgupdatetooltip() CMsgUpdateToolTip {
	return CMsgUpdateToolTip{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgupdatetooltip(o CMsgUpdateToolTip, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgupdatetooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgUpdateToolTip) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgupdatetooltip_unpack(v)?
	return i, unpacked
}

pub struct CMsgHideToolTip {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgHideToolTip) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghidetooltip_unpack(buf []byte) ?CMsgHideToolTip {
	mut res := zzz_vproto_internal_new_cmsghidetooltip()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgHideToolTip) eq(b CMsgHideToolTip) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgHideToolTip) ne(b CMsgHideToolTip) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgHideToolTip) eq(b []CMsgHideToolTip) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgHideToolTip) ne(b []CMsgHideToolTip) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsghidetooltip() CMsgHideToolTip {
	return CMsgHideToolTip{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghidetooltip(o CMsgHideToolTip, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghidetooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHideToolTip) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghidetooltip_unpack(v)?
	return i, unpacked
}

pub struct CMsgSearchResults {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	activematch    int
	results        int
}

pub fn (o &CMsgSearchResults) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.activematch != int(0) {
		res << vproto.pack_int32_field(o.activematch, 2)
	}
	if o.results != int(0) {
		res << vproto.pack_int32_field(o.results, 3)
	}
	return res
}

pub fn cmsgsearchresults_unpack(buf []byte) ?CMsgSearchResults {
	mut res := zzz_vproto_internal_new_cmsgsearchresults()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.activematch = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSearchResults) eq(b CMsgSearchResults) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.activematch == b.activematch && a.results == b.results
}

[inline]
pub fn (a CMsgSearchResults) ne(b CMsgSearchResults) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSearchResults) eq(b []CMsgSearchResults) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSearchResults) ne(b []CMsgSearchResults) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsearchresults() CMsgSearchResults {
	return CMsgSearchResults{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsearchresults(o CMsgSearchResults, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsearchresults(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSearchResults) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsearchresults_unpack(v)?
	return i, unpacked
}

pub struct CMsgClose {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgClose) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclose_unpack(buf []byte) ?CMsgClose {
	mut res := zzz_vproto_internal_new_cmsgclose()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClose) eq(b CMsgClose) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgClose) ne(b CMsgClose) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClose) eq(b []CMsgClose) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClose) ne(b []CMsgClose) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclose() CMsgClose {
	return CMsgClose{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclose(o CMsgClose, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclose(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClose) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclose_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetSharedPaintBuffers {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	wide           u32
	tall           u32
	source_pid     u64
	source_handle  u64
	handle         u64
}

pub fn (o &CMsgSetSharedPaintBuffers) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.wide != u32(0) {
		res << vproto.pack_uint32_field(o.wide, 2)
	}
	if o.tall != u32(0) {
		res << vproto.pack_uint32_field(o.tall, 3)
	}
	if o.source_pid != u64(0) {
		res << vproto.pack_uint64_field(o.source_pid, 4)
	}
	if o.source_handle != u64(0) {
		res << vproto.pack_uint64_field(o.source_handle, 5)
	}
	if o.handle != u64(0) {
		res << vproto.pack_uint64_field(o.handle, 6)
	}
	return res
}

pub fn cmsgsetsharedpaintbuffers_unpack(buf []byte) ?CMsgSetSharedPaintBuffers {
	mut res := zzz_vproto_internal_new_cmsgsetsharedpaintbuffers()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.source_pid = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.source_handle = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetSharedPaintBuffers) eq(b CMsgSetSharedPaintBuffers) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.wide == b.wide && a.tall == b.tall &&
		a.source_pid == b.source_pid && a.source_handle == b.source_handle &&
		a.handle == b.handle
}

[inline]
pub fn (a CMsgSetSharedPaintBuffers) ne(b CMsgSetSharedPaintBuffers) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetSharedPaintBuffers) eq(b []CMsgSetSharedPaintBuffers) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetSharedPaintBuffers) ne(b []CMsgSetSharedPaintBuffers) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetsharedpaintbuffers() CMsgSetSharedPaintBuffers {
	return CMsgSetSharedPaintBuffers{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetsharedpaintbuffers(o CMsgSetSharedPaintBuffers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetsharedpaintbuffers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetSharedPaintBuffers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetsharedpaintbuffers_unpack(v)?
	return i, unpacked
}

pub struct CMsgAckSharedPaintBuffers {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgAckSharedPaintBuffers) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgacksharedpaintbuffers_unpack(buf []byte) ?CMsgAckSharedPaintBuffers {
	mut res := zzz_vproto_internal_new_cmsgacksharedpaintbuffers()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgAckSharedPaintBuffers) eq(b CMsgAckSharedPaintBuffers) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgAckSharedPaintBuffers) ne(b CMsgAckSharedPaintBuffers) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgAckSharedPaintBuffers) eq(b []CMsgAckSharedPaintBuffers) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgAckSharedPaintBuffers) ne(b []CMsgAckSharedPaintBuffers) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgacksharedpaintbuffers() CMsgAckSharedPaintBuffers {
	return CMsgAckSharedPaintBuffers{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgacksharedpaintbuffers(o CMsgAckSharedPaintBuffers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgacksharedpaintbuffers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAckSharedPaintBuffers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgacksharedpaintbuffers_unpack(v)?
	return i, unpacked
}

pub struct CMsgNeedsPaint {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scrollx        u32
	scrolly        u32
	pagescale      f32
	pageserial     u32
}

pub fn (o &CMsgNeedsPaint) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scrollx != u32(0) {
		res << vproto.pack_uint32_field(o.scrollx, 10)
	}
	if o.scrolly != u32(0) {
		res << vproto.pack_uint32_field(o.scrolly, 11)
	}
	if o.pagescale != f32(0) {
		res << vproto.pack_float_field(o.pagescale, 12)
	}
	if o.pageserial != u32(0) {
		res << vproto.pack_uint32_field(o.pageserial, 15)
	}
	return res
}

pub fn cmsgneedspaint_unpack(buf []byte) ?CMsgNeedsPaint {
	mut res := zzz_vproto_internal_new_cmsgneedspaint()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrollx = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrolly = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pagescale = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgNeedsPaint) eq(b CMsgNeedsPaint) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.scrollx == b.scrollx && a.scrolly == b.scrolly &&
		a.pagescale == b.pagescale && a.pageserial == b.pageserial
}

[inline]
pub fn (a CMsgNeedsPaint) ne(b CMsgNeedsPaint) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgNeedsPaint) eq(b []CMsgNeedsPaint) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgNeedsPaint) ne(b []CMsgNeedsPaint) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgneedspaint() CMsgNeedsPaint {
	return CMsgNeedsPaint{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgneedspaint(o CMsgNeedsPaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgneedspaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNeedsPaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgneedspaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgComboNeedsPaint {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	browser_handle       u32
	rgba                 u64
	combobox_wide        u32 = 0
	combobox_tall        u32 = 0
	shared_memory_handle u64 = 0
	shared_memory_size   u64 = 0
}

pub fn (o &CMsgComboNeedsPaint) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.rgba != u64(0) {
		res << vproto.pack_uint64_field(o.rgba, 2)
	}
	if o.combobox_wide != u32(0) {
		res << vproto.pack_uint32_field(o.combobox_wide, 3)
	}
	if o.combobox_tall != u32(0) {
		res << vproto.pack_uint32_field(o.combobox_tall, 4)
	}
	if o.shared_memory_handle != u64(0) {
		res << vproto.pack_uint64_field(o.shared_memory_handle, 5)
	}
	if o.shared_memory_size != u64(0) {
		res << vproto.pack_uint64_field(o.shared_memory_size, 7)
	}
	return res
}

pub fn cmsgcomboneedspaint_unpack(buf []byte) ?CMsgComboNeedsPaint {
	mut res := zzz_vproto_internal_new_cmsgcomboneedspaint()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.rgba = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.combobox_wide = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.combobox_tall = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.shared_memory_handle = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.shared_memory_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgComboNeedsPaint) eq(b CMsgComboNeedsPaint) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.rgba == b.rgba && a.combobox_wide == b.combobox_wide &&
		a.combobox_tall == b.combobox_tall &&
		a.shared_memory_handle == b.shared_memory_handle &&
		a.shared_memory_size == b.shared_memory_size
}

[inline]
pub fn (a CMsgComboNeedsPaint) ne(b CMsgComboNeedsPaint) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgComboNeedsPaint) eq(b []CMsgComboNeedsPaint) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgComboNeedsPaint) ne(b []CMsgComboNeedsPaint) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgcomboneedspaint() CMsgComboNeedsPaint {
	return CMsgComboNeedsPaint{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgcomboneedspaint(o CMsgComboNeedsPaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgcomboneedspaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgComboNeedsPaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcomboneedspaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgNeedsSharedTexturePaint {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	share_handle   u32
	width          u32
	height         u32
	scrollx        u32
	scrolly        u32
	pagescale      f32
	pageserial     u32
}

pub fn (o &CMsgNeedsSharedTexturePaint) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.share_handle != u32(0) {
		res << vproto.pack_uint32_field(o.share_handle, 2)
	}
	if o.width != u32(0) {
		res << vproto.pack_uint32_field(o.width, 3)
	}
	if o.height != u32(0) {
		res << vproto.pack_uint32_field(o.height, 4)
	}
	if o.scrollx != u32(0) {
		res << vproto.pack_uint32_field(o.scrollx, 5)
	}
	if o.scrolly != u32(0) {
		res << vproto.pack_uint32_field(o.scrolly, 6)
	}
	if o.pagescale != f32(0) {
		res << vproto.pack_float_field(o.pagescale, 7)
	}
	if o.pageserial != u32(0) {
		res << vproto.pack_uint32_field(o.pageserial, 8)
	}
	return res
}

pub fn cmsgneedssharedtexturepaint_unpack(buf []byte) ?CMsgNeedsSharedTexturePaint {
	mut res := zzz_vproto_internal_new_cmsgneedssharedtexturepaint()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.share_handle = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrollx = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrolly = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pagescale = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgNeedsSharedTexturePaint) eq(b CMsgNeedsSharedTexturePaint) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.share_handle == b.share_handle &&
		a.width == b.width && a.height == b.height &&
		a.scrollx == b.scrollx && a.scrolly == b.scrolly &&
		a.pagescale == b.pagescale && a.pageserial == b.pageserial
}

[inline]
pub fn (a CMsgNeedsSharedTexturePaint) ne(b CMsgNeedsSharedTexturePaint) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgNeedsSharedTexturePaint) eq(b []CMsgNeedsSharedTexturePaint) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgNeedsSharedTexturePaint) ne(b []CMsgNeedsSharedTexturePaint) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgneedssharedtexturepaint() CMsgNeedsSharedTexturePaint {
	return CMsgNeedsSharedTexturePaint{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgneedssharedtexturepaint(o CMsgNeedsSharedTexturePaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgneedssharedtexturepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNeedsSharedTexturePaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgneedssharedtexturepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameOverlayTexturePaint {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	width          u32
	height         u32
	scrollx        u32
	scrolly        u32
	pagescale      f32
	pageserial     u32
}

pub fn (o &CMsgGameOverlayTexturePaint) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.width != u32(0) {
		res << vproto.pack_uint32_field(o.width, 3)
	}
	if o.height != u32(0) {
		res << vproto.pack_uint32_field(o.height, 4)
	}
	if o.scrollx != u32(0) {
		res << vproto.pack_uint32_field(o.scrollx, 5)
	}
	if o.scrolly != u32(0) {
		res << vproto.pack_uint32_field(o.scrolly, 6)
	}
	if o.pagescale != f32(0) {
		res << vproto.pack_float_field(o.pagescale, 7)
	}
	if o.pageserial != u32(0) {
		res << vproto.pack_uint32_field(o.pageserial, 8)
	}
	return res
}

pub fn cmsggameoverlaytexturepaint_unpack(buf []byte) ?CMsgGameOverlayTexturePaint {
	mut res := zzz_vproto_internal_new_cmsggameoverlaytexturepaint()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrollx = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrolly = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pagescale = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGameOverlayTexturePaint) eq(b CMsgGameOverlayTexturePaint) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.width == b.width && a.height == b.height &&
		a.scrollx == b.scrollx && a.scrolly == b.scrolly &&
		a.pagescale == b.pagescale && a.pageserial == b.pageserial
}

[inline]
pub fn (a CMsgGameOverlayTexturePaint) ne(b CMsgGameOverlayTexturePaint) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGameOverlayTexturePaint) eq(b []CMsgGameOverlayTexturePaint) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGameOverlayTexturePaint) ne(b []CMsgGameOverlayTexturePaint) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggameoverlaytexturepaint() CMsgGameOverlayTexturePaint {
	return CMsgGameOverlayTexturePaint{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggameoverlaytexturepaint(o CMsgGameOverlayTexturePaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggameoverlaytexturepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameOverlayTexturePaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameoverlaytexturepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetZoom {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgGetZoom) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsggetzoom_unpack(buf []byte) ?CMsgGetZoom {
	mut res := zzz_vproto_internal_new_cmsggetzoom()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGetZoom) eq(b CMsgGetZoom) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgGetZoom) ne(b CMsgGetZoom) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGetZoom) eq(b []CMsgGetZoom) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGetZoom) ne(b []CMsgGetZoom) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggetzoom() CMsgGetZoom {
	return CMsgGetZoom{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetzoom(o CMsgGetZoom, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetzoom(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetZoom) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetzoom_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetZoomResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	zoom           f32
}

pub fn (o &CMsgGetZoomResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.zoom != f32(0) {
		res << vproto.pack_float_field(o.zoom, 2)
	}
	return res
}

pub fn cmsggetzoomresponse_unpack(buf []byte) ?CMsgGetZoomResponse {
	mut res := zzz_vproto_internal_new_cmsggetzoomresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGetZoomResponse) eq(b CMsgGetZoomResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.zoom == b.zoom
}

[inline]
pub fn (a CMsgGetZoomResponse) ne(b CMsgGetZoomResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGetZoomResponse) eq(b []CMsgGetZoomResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGetZoomResponse) ne(b []CMsgGetZoomResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggetzoomresponse() CMsgGetZoomResponse {
	return CMsgGetZoomResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetzoomresponse(o CMsgGetZoomResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetzoomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetZoomResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetzoomresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgLinkAtPosition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              u32
	y              u32
}

pub fn (o &CMsgLinkAtPosition) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != u32(0) {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.y != u32(0) {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsglinkatposition_unpack(buf []byte) ?CMsgLinkAtPosition {
	mut res := zzz_vproto_internal_new_cmsglinkatposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgLinkAtPosition) eq(b CMsgLinkAtPosition) bool {
	return true && a.browser_handle == b.browser_handle && a.x == b.x && a.y == b.y
}

[inline]
pub fn (a CMsgLinkAtPosition) ne(b CMsgLinkAtPosition) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgLinkAtPosition) eq(b []CMsgLinkAtPosition) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgLinkAtPosition) ne(b []CMsgLinkAtPosition) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsglinkatposition() CMsgLinkAtPosition {
	return CMsgLinkAtPosition{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsglinkatposition(o CMsgLinkAtPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsglinkatposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLinkAtPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsglinkatposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgLinkAtPositionResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              u32
	y              u32
	url            string
	blivelink      bool
	binput         bool
}

pub fn (o &CMsgLinkAtPositionResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != u32(0) {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.y != u32(0) {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 4)
	}
	if o.blivelink != bool(0) {
		res << vproto.pack_bool_field(o.blivelink, 5)
	}
	if o.binput != bool(0) {
		res << vproto.pack_bool_field(o.binput, 6)
	}
	return res
}

pub fn cmsglinkatpositionresponse_unpack(buf []byte) ?CMsgLinkAtPositionResponse {
	mut res := zzz_vproto_internal_new_cmsglinkatpositionresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.blivelink = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.binput = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgLinkAtPositionResponse) eq(b CMsgLinkAtPositionResponse) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.x == b.x && a.y == b.y && a.url == b.url &&
		a.blivelink == b.blivelink && a.binput == b.binput
}

[inline]
pub fn (a CMsgLinkAtPositionResponse) ne(b CMsgLinkAtPositionResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgLinkAtPositionResponse) eq(b []CMsgLinkAtPositionResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgLinkAtPositionResponse) ne(b []CMsgLinkAtPositionResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsglinkatpositionresponse() CMsgLinkAtPositionResponse {
	return CMsgLinkAtPositionResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsglinkatpositionresponse(o CMsgLinkAtPositionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsglinkatpositionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLinkAtPositionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsglinkatpositionresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgZoomToElementAtPosition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              u32
	y              u32
}

pub fn (o &CMsgZoomToElementAtPosition) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != u32(0) {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.y != u32(0) {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsgzoomtoelementatposition_unpack(buf []byte) ?CMsgZoomToElementAtPosition {
	mut res := zzz_vproto_internal_new_cmsgzoomtoelementatposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgZoomToElementAtPosition) eq(b CMsgZoomToElementAtPosition) bool {
	return true && a.browser_handle == b.browser_handle && a.x == b.x && a.y == b.y
}

[inline]
pub fn (a CMsgZoomToElementAtPosition) ne(b CMsgZoomToElementAtPosition) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgZoomToElementAtPosition) eq(b []CMsgZoomToElementAtPosition) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgZoomToElementAtPosition) ne(b []CMsgZoomToElementAtPosition) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgzoomtoelementatposition() CMsgZoomToElementAtPosition {
	return CMsgZoomToElementAtPosition{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgzoomtoelementatposition(o CMsgZoomToElementAtPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgzoomtoelementatposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToElementAtPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgzoomtoelementatposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgZoomToElementAtPositionResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scale          f32
	duration       f32
}

pub fn (o &CMsgZoomToElementAtPositionResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scale != f32(0) {
		res << vproto.pack_float_field(o.scale, 2)
	}
	if o.duration != f32(0) {
		res << vproto.pack_float_field(o.duration, 3)
	}
	return res
}

pub fn cmsgzoomtoelementatpositionresponse_unpack(buf []byte) ?CMsgZoomToElementAtPositionResponse {
	mut res := zzz_vproto_internal_new_cmsgzoomtoelementatpositionresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.scale = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgZoomToElementAtPositionResponse) eq(b CMsgZoomToElementAtPositionResponse) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.scale == b.scale && a.duration == b.duration
}

[inline]
pub fn (a CMsgZoomToElementAtPositionResponse) ne(b CMsgZoomToElementAtPositionResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgZoomToElementAtPositionResponse) eq(b []CMsgZoomToElementAtPositionResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgZoomToElementAtPositionResponse) ne(b []CMsgZoomToElementAtPositionResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgzoomtoelementatpositionresponse() CMsgZoomToElementAtPositionResponse {
	return CMsgZoomToElementAtPositionResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgzoomtoelementatpositionresponse(o CMsgZoomToElementAtPositionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgzoomtoelementatpositionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToElementAtPositionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgzoomtoelementatpositionresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgScalePageToValue {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	scale          f32
	x              f32
	y              f32
}

pub fn (o &CMsgScalePageToValue) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.scale != f32(0) {
		res << vproto.pack_float_field(o.scale, 2)
	}
	if o.x != f32(0) {
		res << vproto.pack_float_field(o.x, 3)
	}
	if o.y != f32(0) {
		res << vproto.pack_float_field(o.y, 4)
	}
	return res
}

pub fn cmsgscalepagetovalue_unpack(buf []byte) ?CMsgScalePageToValue {
	mut res := zzz_vproto_internal_new_cmsgscalepagetovalue()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.scale = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgScalePageToValue) eq(b CMsgScalePageToValue) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.scale == b.scale && a.x == b.x &&
		a.y == b.y
}

[inline]
pub fn (a CMsgScalePageToValue) ne(b CMsgScalePageToValue) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgScalePageToValue) eq(b []CMsgScalePageToValue) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgScalePageToValue) ne(b []CMsgScalePageToValue) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgscalepagetovalue() CMsgScalePageToValue {
	return CMsgScalePageToValue{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscalepagetovalue(o CMsgScalePageToValue, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscalepagetovalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScalePageToValue) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscalepagetovalue_unpack(v)?
	return i, unpacked
}

pub struct CMsgForcePopupsToDirectHWND {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	browser_handle           u32
	force_direct_hwnd_popups bool
}

pub fn (o &CMsgForcePopupsToDirectHWND) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.force_direct_hwnd_popups != bool(0) {
		res << vproto.pack_bool_field(o.force_direct_hwnd_popups, 2)
	}
	return res
}

pub fn cmsgforcepopupstodirecthwnd_unpack(buf []byte) ?CMsgForcePopupsToDirectHWND {
	mut res := zzz_vproto_internal_new_cmsgforcepopupstodirecthwnd()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_direct_hwnd_popups = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgForcePopupsToDirectHWND) eq(b CMsgForcePopupsToDirectHWND) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.force_direct_hwnd_popups == b.force_direct_hwnd_popups
}

[inline]
pub fn (a CMsgForcePopupsToDirectHWND) ne(b CMsgForcePopupsToDirectHWND) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgForcePopupsToDirectHWND) eq(b []CMsgForcePopupsToDirectHWND) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgForcePopupsToDirectHWND) ne(b []CMsgForcePopupsToDirectHWND) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgforcepopupstodirecthwnd() CMsgForcePopupsToDirectHWND {
	return CMsgForcePopupsToDirectHWND{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgforcepopupstodirecthwnd(o CMsgForcePopupsToDirectHWND, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgforcepopupstodirecthwnd(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgForcePopupsToDirectHWND) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgforcepopupstodirecthwnd_unpack(v)?
	return i, unpacked
}

pub struct CMsgScalePageToValueResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	zoom           f32
}

pub fn (o &CMsgScalePageToValueResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.zoom != f32(0) {
		res << vproto.pack_float_field(o.zoom, 2)
	}
	return res
}

pub fn cmsgscalepagetovalueresponse_unpack(buf []byte) ?CMsgScalePageToValueResponse {
	mut res := zzz_vproto_internal_new_cmsgscalepagetovalueresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgScalePageToValueResponse) eq(b CMsgScalePageToValueResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.zoom == b.zoom
}

[inline]
pub fn (a CMsgScalePageToValueResponse) ne(b CMsgScalePageToValueResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgScalePageToValueResponse) eq(b []CMsgScalePageToValueResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgScalePageToValueResponse) ne(b []CMsgScalePageToValueResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgscalepagetovalueresponse() CMsgScalePageToValueResponse {
	return CMsgScalePageToValueResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscalepagetovalueresponse(o CMsgScalePageToValueResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscalepagetovalueresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScalePageToValueResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscalepagetovalueresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgSavePageToJPEG {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	filename       string
	width          u32
	height         u32
}

pub fn (o &CMsgSavePageToJPEG) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 3)
	}
	if o.width != u32(0) {
		res << vproto.pack_uint32_field(o.width, 4)
	}
	if o.height != u32(0) {
		res << vproto.pack_uint32_field(o.height, 5)
	}
	return res
}

pub fn cmsgsavepagetojpeg_unpack(buf []byte) ?CMsgSavePageToJPEG {
	mut res := zzz_vproto_internal_new_cmsgsavepagetojpeg()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSavePageToJPEG) eq(b CMsgSavePageToJPEG) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.filename == b.filename &&
		a.width == b.width && a.height == b.height
}

[inline]
pub fn (a CMsgSavePageToJPEG) ne(b CMsgSavePageToJPEG) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSavePageToJPEG) eq(b []CMsgSavePageToJPEG) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSavePageToJPEG) ne(b []CMsgSavePageToJPEG) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsavepagetojpeg() CMsgSavePageToJPEG {
	return CMsgSavePageToJPEG{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsavepagetojpeg(o CMsgSavePageToJPEG, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsavepagetojpeg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSavePageToJPEG) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsavepagetojpeg_unpack(v)?
	return i, unpacked
}

pub struct CMsgSavePageToJPEGResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	filename       string
}

pub fn (o &CMsgSavePageToJPEGResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 3)
	}
	return res
}

pub fn cmsgsavepagetojpegresponse_unpack(buf []byte) ?CMsgSavePageToJPEGResponse {
	mut res := zzz_vproto_internal_new_cmsgsavepagetojpegresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSavePageToJPEGResponse) eq(b CMsgSavePageToJPEGResponse) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.filename == b.filename
}

[inline]
pub fn (a CMsgSavePageToJPEGResponse) ne(b CMsgSavePageToJPEGResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSavePageToJPEGResponse) eq(b []CMsgSavePageToJPEGResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSavePageToJPEGResponse) ne(b []CMsgSavePageToJPEGResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsavepagetojpegresponse() CMsgSavePageToJPEGResponse {
	return CMsgSavePageToJPEGResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsavepagetojpegresponse(o CMsgSavePageToJPEGResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsavepagetojpegresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSavePageToJPEGResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsavepagetojpegresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSAlert {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	message        string
}

pub fn (o &CMsgJSAlert) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.message != '' {
		res << vproto.pack_string_field(o.message, 2)
	}
	return res
}

pub fn cmsgjsalert_unpack(buf []byte) ?CMsgJSAlert {
	mut res := zzz_vproto_internal_new_cmsgjsalert()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSAlert) eq(b CMsgJSAlert) bool {
	return true && a.browser_handle == b.browser_handle && a.message == b.message
}

[inline]
pub fn (a CMsgJSAlert) ne(b CMsgJSAlert) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSAlert) eq(b []CMsgJSAlert) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSAlert) ne(b []CMsgJSAlert) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsalert() CMsgJSAlert {
	return CMsgJSAlert{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsalert(o CMsgJSAlert, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsalert(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSAlert) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsalert_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSConfirm {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	message        string
}

pub fn (o &CMsgJSConfirm) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.message != '' {
		res << vproto.pack_string_field(o.message, 2)
	}
	return res
}

pub fn cmsgjsconfirm_unpack(buf []byte) ?CMsgJSConfirm {
	mut res := zzz_vproto_internal_new_cmsgjsconfirm()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSConfirm) eq(b CMsgJSConfirm) bool {
	return true && a.browser_handle == b.browser_handle && a.message == b.message
}

[inline]
pub fn (a CMsgJSConfirm) ne(b CMsgJSConfirm) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSConfirm) eq(b []CMsgJSConfirm) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSConfirm) ne(b []CMsgJSConfirm) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsconfirm() CMsgJSConfirm {
	return CMsgJSConfirm{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsconfirm(o CMsgJSConfirm, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsconfirm(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSConfirm) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsconfirm_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSDialogResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	result         bool
}

pub fn (o &CMsgJSDialogResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.result != bool(0) {
		res << vproto.pack_bool_field(o.result, 2)
	}
	return res
}

pub fn cmsgjsdialogresponse_unpack(buf []byte) ?CMsgJSDialogResponse {
	mut res := zzz_vproto_internal_new_cmsgjsdialogresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSDialogResponse) eq(b CMsgJSDialogResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.result == b.result
}

[inline]
pub fn (a CMsgJSDialogResponse) ne(b CMsgJSDialogResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSDialogResponse) eq(b []CMsgJSDialogResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSDialogResponse) ne(b []CMsgJSDialogResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsdialogresponse() CMsgJSDialogResponse {
	return CMsgJSDialogResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsdialogresponse(o CMsgJSDialogResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsdialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSDialogResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsdialogresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgCanGoBackAndForward {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	bgoback        bool
	bgoforward     bool
}

pub fn (o &CMsgCanGoBackAndForward) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.bgoback != bool(0) {
		res << vproto.pack_bool_field(o.bgoback, 2)
	}
	if o.bgoforward != bool(0) {
		res << vproto.pack_bool_field(o.bgoforward, 3)
	}
	return res
}

pub fn cmsgcangobackandforward_unpack(buf []byte) ?CMsgCanGoBackAndForward {
	mut res := zzz_vproto_internal_new_cmsgcangobackandforward()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bgoback = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bgoforward = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgCanGoBackAndForward) eq(b CMsgCanGoBackAndForward) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.bgoback == b.bgoback && a.bgoforward == b.bgoforward
}

[inline]
pub fn (a CMsgCanGoBackAndForward) ne(b CMsgCanGoBackAndForward) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgCanGoBackAndForward) eq(b []CMsgCanGoBackAndForward) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgCanGoBackAndForward) ne(b []CMsgCanGoBackAndForward) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgcangobackandforward() CMsgCanGoBackAndForward {
	return CMsgCanGoBackAndForward{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgcangobackandforward(o CMsgCanGoBackAndForward, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgcangobackandforward(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCanGoBackAndForward) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcangobackandforward_unpack(v)?
	return i, unpacked
}

pub struct CMsgOpenSteamURL {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	referrer       string
}

pub fn (o &CMsgOpenSteamURL) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.referrer != '' {
		res << vproto.pack_string_field(o.referrer, 3)
	}
	return res
}

pub fn cmsgopensteamurl_unpack(buf []byte) ?CMsgOpenSteamURL {
	mut res := zzz_vproto_internal_new_cmsgopensteamurl()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.referrer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgOpenSteamURL) eq(b CMsgOpenSteamURL) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.url == b.url && a.referrer == b.referrer
}

[inline]
pub fn (a CMsgOpenSteamURL) ne(b CMsgOpenSteamURL) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgOpenSteamURL) eq(b []CMsgOpenSteamURL) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgOpenSteamURL) ne(b []CMsgOpenSteamURL) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgopensteamurl() CMsgOpenSteamURL {
	return CMsgOpenSteamURL{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgopensteamurl(o CMsgOpenSteamURL, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgopensteamurl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenSteamURL) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgopensteamurl_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetCookie {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
	path           string
	host           string
	expires        u32
	secure         bool
	httponly       bool
}

pub fn (o &CMsgSetCookie) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.path != '' {
		res << vproto.pack_string_field(o.path, 3)
	}
	if o.host != '' {
		res << vproto.pack_string_field(o.host, 4)
	}
	if o.expires != u32(0) {
		res << vproto.pack_uint32_field(o.expires, 5)
	}
	if o.secure != bool(0) {
		res << vproto.pack_bool_field(o.secure, 6)
	}
	if o.httponly != bool(0) {
		res << vproto.pack_bool_field(o.httponly, 7)
	}
	return res
}

pub fn cmsgsetcookie_unpack(buf []byte) ?CMsgSetCookie {
	mut res := zzz_vproto_internal_new_cmsgsetcookie()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.expires = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.secure = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.httponly = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetCookie) eq(b CMsgSetCookie) bool {
	return true && a.key == b.key &&
		a.value == b.value && a.path == b.path &&
		a.host == b.host && a.expires == b.expires &&
		a.secure == b.secure && a.httponly == b.httponly
}

[inline]
pub fn (a CMsgSetCookie) ne(b CMsgSetCookie) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetCookie) eq(b []CMsgSetCookie) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetCookie) ne(b []CMsgSetCookie) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetcookie() CMsgSetCookie {
	return CMsgSetCookie{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetcookie(o CMsgSetCookie, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetcookie(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetCookie) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetcookie_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetTargetFrameRate {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	browser_handle   u32
	ntargetframerate u32
}

pub fn (o &CMsgSetTargetFrameRate) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.ntargetframerate != u32(0) {
		res << vproto.pack_uint32_field(o.ntargetframerate, 2)
	}
	return res
}

pub fn cmsgsettargetframerate_unpack(buf []byte) ?CMsgSetTargetFrameRate {
	mut res := zzz_vproto_internal_new_cmsgsettargetframerate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ntargetframerate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetTargetFrameRate) eq(b CMsgSetTargetFrameRate) bool {
	return true && a.browser_handle == b.browser_handle && a.ntargetframerate == b.ntargetframerate
}

[inline]
pub fn (a CMsgSetTargetFrameRate) ne(b CMsgSetTargetFrameRate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetTargetFrameRate) eq(b []CMsgSetTargetFrameRate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetTargetFrameRate) ne(b []CMsgSetTargetFrameRate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsettargetframerate() CMsgSetTargetFrameRate {
	return CMsgSetTargetFrameRate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsettargetframerate(o CMsgSetTargetFrameRate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsettargetframerate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetTargetFrameRate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsettargetframerate_unpack(v)?
	return i, unpacked
}

pub struct CMsgPauseRepaint {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgPauseRepaint) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgpauserepaint_unpack(buf []byte) ?CMsgPauseRepaint {
	mut res := zzz_vproto_internal_new_cmsgpauserepaint()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPauseRepaint) eq(b CMsgPauseRepaint) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgPauseRepaint) ne(b CMsgPauseRepaint) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPauseRepaint) eq(b []CMsgPauseRepaint) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPauseRepaint) ne(b []CMsgPauseRepaint) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpauserepaint() CMsgPauseRepaint {
	return CMsgPauseRepaint{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpauserepaint(o CMsgPauseRepaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpauserepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPauseRepaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpauserepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgFullRepaint {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgFullRepaint) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgfullrepaint_unpack(buf []byte) ?CMsgFullRepaint {
	mut res := zzz_vproto_internal_new_cmsgfullrepaint()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFullRepaint) eq(b CMsgFullRepaint) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgFullRepaint) ne(b CMsgFullRepaint) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFullRepaint) eq(b []CMsgFullRepaint) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFullRepaint) ne(b []CMsgFullRepaint) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfullrepaint() CMsgFullRepaint {
	return CMsgFullRepaint{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfullrepaint(o CMsgFullRepaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfullrepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFullRepaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfullrepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgRequestFullScreen {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgRequestFullScreen) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgrequestfullscreen_unpack(buf []byte) ?CMsgRequestFullScreen {
	mut res := zzz_vproto_internal_new_cmsgrequestfullscreen()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgRequestFullScreen) eq(b CMsgRequestFullScreen) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgRequestFullScreen) ne(b CMsgRequestFullScreen) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgRequestFullScreen) eq(b []CMsgRequestFullScreen) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgRequestFullScreen) ne(b []CMsgRequestFullScreen) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgrequestfullscreen() CMsgRequestFullScreen {
	return CMsgRequestFullScreen{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgrequestfullscreen(o CMsgRequestFullScreen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgrequestfullscreen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRequestFullScreen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgrequestfullscreen_unpack(v)?
	return i, unpacked
}

pub struct CMsgExitFullScreen {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgExitFullScreen) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgexitfullscreen_unpack(buf []byte) ?CMsgExitFullScreen {
	mut res := zzz_vproto_internal_new_cmsgexitfullscreen()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgExitFullScreen) eq(b CMsgExitFullScreen) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgExitFullScreen) ne(b CMsgExitFullScreen) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgExitFullScreen) eq(b []CMsgExitFullScreen) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgExitFullScreen) ne(b []CMsgExitFullScreen) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgexitfullscreen() CMsgExitFullScreen {
	return CMsgExitFullScreen{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgexitfullscreen(o CMsgExitFullScreen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgexitfullscreen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgExitFullScreen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgexitfullscreen_unpack(v)?
	return i, unpacked
}

pub struct CMsgToggleFindInPageDialog {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgToggleFindInPageDialog) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgtogglefindinpagedialog_unpack(buf []byte) ?CMsgToggleFindInPageDialog {
	mut res := zzz_vproto_internal_new_cmsgtogglefindinpagedialog()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgToggleFindInPageDialog) eq(b CMsgToggleFindInPageDialog) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgToggleFindInPageDialog) ne(b CMsgToggleFindInPageDialog) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgToggleFindInPageDialog) eq(b []CMsgToggleFindInPageDialog) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgToggleFindInPageDialog) ne(b []CMsgToggleFindInPageDialog) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgtogglefindinpagedialog() CMsgToggleFindInPageDialog {
	return CMsgToggleFindInPageDialog{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgtogglefindinpagedialog(o CMsgToggleFindInPageDialog, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgtogglefindinpagedialog(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgToggleFindInPageDialog) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtogglefindinpagedialog_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetPIDShuttingDown {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgSetPIDShuttingDown) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgsetpidshuttingdown_unpack(buf []byte) ?CMsgSetPIDShuttingDown {
	mut res := zzz_vproto_internal_new_cmsgsetpidshuttingdown()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetPIDShuttingDown) eq(b CMsgSetPIDShuttingDown) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgSetPIDShuttingDown) ne(b CMsgSetPIDShuttingDown) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetPIDShuttingDown) eq(b []CMsgSetPIDShuttingDown) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetPIDShuttingDown) ne(b []CMsgSetPIDShuttingDown) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetpidshuttingdown() CMsgSetPIDShuttingDown {
	return CMsgSetPIDShuttingDown{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetpidshuttingdown(o CMsgSetPIDShuttingDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetpidshuttingdown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetPIDShuttingDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetpidshuttingdown_unpack(v)?
	return i, unpacked
}

pub struct CMsgDisableBackgroundThrottling {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgDisableBackgroundThrottling) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgdisablebackgroundthrottling_unpack(buf []byte) ?CMsgDisableBackgroundThrottling {
	mut res := zzz_vproto_internal_new_cmsgdisablebackgroundthrottling()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgDisableBackgroundThrottling) eq(b CMsgDisableBackgroundThrottling) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgDisableBackgroundThrottling) ne(b CMsgDisableBackgroundThrottling) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgDisableBackgroundThrottling) eq(b []CMsgDisableBackgroundThrottling) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgDisableBackgroundThrottling) ne(b []CMsgDisableBackgroundThrottling) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgdisablebackgroundthrottling() CMsgDisableBackgroundThrottling {
	return CMsgDisableBackgroundThrottling{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdisablebackgroundthrottling(o CMsgDisableBackgroundThrottling, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdisablebackgroundthrottling(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDisableBackgroundThrottling) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdisablebackgroundthrottling_unpack(v)?
	return i, unpacked
}

pub struct CMsgAckPIDShuttingDown {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgAckPIDShuttingDown) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgackpidshuttingdown_unpack(buf []byte) ?CMsgAckPIDShuttingDown {
	mut res := zzz_vproto_internal_new_cmsgackpidshuttingdown()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgAckPIDShuttingDown) eq(b CMsgAckPIDShuttingDown) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgAckPIDShuttingDown) ne(b CMsgAckPIDShuttingDown) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgAckPIDShuttingDown) eq(b []CMsgAckPIDShuttingDown) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgAckPIDShuttingDown) ne(b []CMsgAckPIDShuttingDown) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgackpidshuttingdown() CMsgAckPIDShuttingDown {
	return CMsgAckPIDShuttingDown{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgackpidshuttingdown(o CMsgAckPIDShuttingDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgackpidshuttingdown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAckPIDShuttingDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgackpidshuttingdown_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetCookiesForURL {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
}

pub fn (o &CMsgGetCookiesForURL) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	return res
}

pub fn cmsggetcookiesforurl_unpack(buf []byte) ?CMsgGetCookiesForURL {
	mut res := zzz_vproto_internal_new_cmsggetcookiesforurl()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGetCookiesForURL) eq(b CMsgGetCookiesForURL) bool {
	return true && a.browser_handle == b.browser_handle && a.url == b.url
}

[inline]
pub fn (a CMsgGetCookiesForURL) ne(b CMsgGetCookiesForURL) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGetCookiesForURL) eq(b []CMsgGetCookiesForURL) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGetCookiesForURL) ne(b []CMsgGetCookiesForURL) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggetcookiesforurl() CMsgGetCookiesForURL {
	return CMsgGetCookiesForURL{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetcookiesforurl(o CMsgGetCookiesForURL, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetcookiesforurl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetCookiesForURL) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetcookiesforurl_unpack(v)?
	return i, unpacked
}

pub struct CCookie {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	value          string
	domain         string
	path           string
}

pub fn (o &CCookie) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.domain != '' {
		res << vproto.pack_string_field(o.domain, 3)
	}
	if o.path != '' {
		res << vproto.pack_string_field(o.path, 4)
	}
	return res
}

pub fn ccookie_unpack(buf []byte) ?CCookie {
	mut res := zzz_vproto_internal_new_ccookie()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.domain = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCookie) eq(b CCookie) bool {
	return true && a.name == b.name &&
		a.value == b.value && a.domain == b.domain &&
		a.path == b.path
}

[inline]
pub fn (a CCookie) ne(b CCookie) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCookie) eq(b []CCookie) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCookie) ne(b []CCookie) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccookie() CCookie {
	return CCookie{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccookie(o CCookie, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccookie(buf []byte, tag_wiretype vproto.WireType) ?(int, CCookie) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccookie_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetCookiesForURLResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
	cookies        []CCookie
}

pub fn (o &CMsgGetCookiesForURLResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	// [packed=false]
	for _, x in o.cookies {
		res << zzz_vproto_internal_pack_ccookie(x, 3)
	}
	return res
}

pub fn cmsggetcookiesforurlresponse_unpack(buf []byte) ?CMsgGetCookiesForURLResponse {
	mut res := zzz_vproto_internal_new_cmsggetcookiesforurlresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccookie(cur_buf, tag_wiretype.wire_type)?
				res.cookies << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGetCookiesForURLResponse) eq(b CMsgGetCookiesForURLResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.url == b.url && a.cookies.eq(b.cookies)
}

[inline]
pub fn (a CMsgGetCookiesForURLResponse) ne(b CMsgGetCookiesForURLResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGetCookiesForURLResponse) eq(b []CMsgGetCookiesForURLResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGetCookiesForURLResponse) ne(b []CMsgGetCookiesForURLResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggetcookiesforurlresponse() CMsgGetCookiesForURLResponse {
	return CMsgGetCookiesForURLResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggetcookiesforurlresponse(o CMsgGetCookiesForURLResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggetcookiesforurlresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetCookiesForURLResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetcookiesforurlresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgNodeHasFocus {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	binput             bool
	name               string
	elementtagname     string
	searchbuttontext   string
	bhasmultipleinputs bool
	input_type         string
}

pub fn (o &CMsgNodeHasFocus) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.binput != bool(0) {
		res << vproto.pack_bool_field(o.binput, 2)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 3)
	}
	if o.elementtagname != '' {
		res << vproto.pack_string_field(o.elementtagname, 4)
	}
	if o.searchbuttontext != '' {
		res << vproto.pack_string_field(o.searchbuttontext, 5)
	}
	if o.bhasmultipleinputs != bool(0) {
		res << vproto.pack_bool_field(o.bhasmultipleinputs, 6)
	}
	if o.input_type != '' {
		res << vproto.pack_string_field(o.input_type, 7)
	}
	return res
}

pub fn cmsgnodehasfocus_unpack(buf []byte) ?CMsgNodeHasFocus {
	mut res := zzz_vproto_internal_new_cmsgnodehasfocus()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.binput = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.elementtagname = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.searchbuttontext = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bhasmultipleinputs = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.input_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgNodeHasFocus) eq(b CMsgNodeHasFocus) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.binput == b.binput && a.name == b.name &&
		a.elementtagname == b.elementtagname &&
		a.searchbuttontext == b.searchbuttontext &&
		a.bhasmultipleinputs == b.bhasmultipleinputs &&
		a.input_type == b.input_type
}

[inline]
pub fn (a CMsgNodeHasFocus) ne(b CMsgNodeHasFocus) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgNodeHasFocus) eq(b []CMsgNodeHasFocus) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgNodeHasFocus) ne(b []CMsgNodeHasFocus) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgnodehasfocus() CMsgNodeHasFocus {
	return CMsgNodeHasFocus{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgnodehasfocus(o CMsgNodeHasFocus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgnodehasfocus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNodeHasFocus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgnodehasfocus_unpack(v)?
	return i, unpacked
}

pub struct CMsgZoomToFocusedElement {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgZoomToFocusedElement) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgzoomtofocusedelement_unpack(buf []byte) ?CMsgZoomToFocusedElement {
	mut res := zzz_vproto_internal_new_cmsgzoomtofocusedelement()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgZoomToFocusedElement) eq(b CMsgZoomToFocusedElement) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgZoomToFocusedElement) ne(b CMsgZoomToFocusedElement) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgZoomToFocusedElement) eq(b []CMsgZoomToFocusedElement) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgZoomToFocusedElement) ne(b []CMsgZoomToFocusedElement) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgzoomtofocusedelement() CMsgZoomToFocusedElement {
	return CMsgZoomToFocusedElement{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgzoomtofocusedelement(o CMsgZoomToFocusedElement, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgzoomtofocusedelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToFocusedElement) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgzoomtofocusedelement_unpack(v)?
	return i, unpacked
}

pub struct CMsgCloseFullScreenFlashIfOpen {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgCloseFullScreenFlashIfOpen) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclosefullscreenflashifopen_unpack(buf []byte) ?CMsgCloseFullScreenFlashIfOpen {
	mut res := zzz_vproto_internal_new_cmsgclosefullscreenflashifopen()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgCloseFullScreenFlashIfOpen) eq(b CMsgCloseFullScreenFlashIfOpen) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgCloseFullScreenFlashIfOpen) ne(b CMsgCloseFullScreenFlashIfOpen) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgCloseFullScreenFlashIfOpen) eq(b []CMsgCloseFullScreenFlashIfOpen) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgCloseFullScreenFlashIfOpen) ne(b []CMsgCloseFullScreenFlashIfOpen) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclosefullscreenflashifopen() CMsgCloseFullScreenFlashIfOpen {
	return CMsgCloseFullScreenFlashIfOpen{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclosefullscreenflashifopen(o CMsgCloseFullScreenFlashIfOpen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclosefullscreenflashifopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCloseFullScreenFlashIfOpen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclosefullscreenflashifopen_unpack(v)?
	return i, unpacked
}

pub struct CMsgPauseFullScreenFlashMovieIfOpen {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgPauseFullScreenFlashMovieIfOpen) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgpausefullscreenflashmovieifopen_unpack(buf []byte) ?CMsgPauseFullScreenFlashMovieIfOpen {
	mut res := zzz_vproto_internal_new_cmsgpausefullscreenflashmovieifopen()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgPauseFullScreenFlashMovieIfOpen) eq(b CMsgPauseFullScreenFlashMovieIfOpen) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgPauseFullScreenFlashMovieIfOpen) ne(b CMsgPauseFullScreenFlashMovieIfOpen) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgPauseFullScreenFlashMovieIfOpen) eq(b []CMsgPauseFullScreenFlashMovieIfOpen) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgPauseFullScreenFlashMovieIfOpen) ne(b []CMsgPauseFullScreenFlashMovieIfOpen) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgpausefullscreenflashmovieifopen() CMsgPauseFullScreenFlashMovieIfOpen {
	return CMsgPauseFullScreenFlashMovieIfOpen{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgpausefullscreenflashmovieifopen(o CMsgPauseFullScreenFlashMovieIfOpen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgpausefullscreenflashmovieifopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPauseFullScreenFlashMovieIfOpen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpausefullscreenflashmovieifopen_unpack(v)?
	return i, unpacked
}

pub struct CMsgFocusedNodeText {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgFocusedNodeText) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgfocusednodetext_unpack(buf []byte) ?CMsgFocusedNodeText {
	mut res := zzz_vproto_internal_new_cmsgfocusednodetext()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFocusedNodeText) eq(b CMsgFocusedNodeText) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgFocusedNodeText) ne(b CMsgFocusedNodeText) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFocusedNodeText) eq(b []CMsgFocusedNodeText) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFocusedNodeText) ne(b []CMsgFocusedNodeText) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfocusednodetext() CMsgFocusedNodeText {
	return CMsgFocusedNodeText{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfocusednodetext(o CMsgFocusedNodeText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfocusednodetext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFocusedNodeText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfocusednodetext_unpack(v)?
	return i, unpacked
}

pub struct CMsgFocusedNodeTextResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	value          string
}

pub fn (o &CMsgFocusedNodeTextResponse) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cmsgfocusednodetextresponse_unpack(buf []byte) ?CMsgFocusedNodeTextResponse {
	mut res := zzz_vproto_internal_new_cmsgfocusednodetextresponse()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgFocusedNodeTextResponse) eq(b CMsgFocusedNodeTextResponse) bool {
	return true && a.browser_handle == b.browser_handle && a.value == b.value
}

[inline]
pub fn (a CMsgFocusedNodeTextResponse) ne(b CMsgFocusedNodeTextResponse) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgFocusedNodeTextResponse) eq(b []CMsgFocusedNodeTextResponse) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgFocusedNodeTextResponse) ne(b []CMsgFocusedNodeTextResponse) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgfocusednodetextresponse() CMsgFocusedNodeTextResponse {
	return CMsgFocusedNodeTextResponse{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgfocusednodetextresponse(o CMsgFocusedNodeTextResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgfocusednodetextresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFocusedNodeTextResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfocusednodetextresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgBuildID {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	build_id       u64
}

pub fn (o &CMsgBuildID) pack() []byte {
	mut res := []byte{}
	if o.build_id != u64(0) {
		res << vproto.pack_uint64_field(o.build_id, 1)
	}
	return res
}

pub fn cmsgbuildid_unpack(buf []byte) ?CMsgBuildID {
	mut res := zzz_vproto_internal_new_cmsgbuildid()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.build_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBuildID) eq(b CMsgBuildID) bool {
	return true && a.build_id == b.build_id
}

[inline]
pub fn (a CMsgBuildID) ne(b CMsgBuildID) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBuildID) eq(b []CMsgBuildID) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBuildID) ne(b []CMsgBuildID) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbuildid() CMsgBuildID {
	return CMsgBuildID{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbuildid(o CMsgBuildID, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbuildid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBuildID) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbuildid_unpack(v)?
	return i, unpacked
}

pub struct CMsgOpenDevTools {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgOpenDevTools) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgopendevtools_unpack(buf []byte) ?CMsgOpenDevTools {
	mut res := zzz_vproto_internal_new_cmsgopendevtools()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgOpenDevTools) eq(b CMsgOpenDevTools) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgOpenDevTools) ne(b CMsgOpenDevTools) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgOpenDevTools) eq(b []CMsgOpenDevTools) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgOpenDevTools) ne(b []CMsgOpenDevTools) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgopendevtools() CMsgOpenDevTools {
	return CMsgOpenDevTools{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgopendevtools(o CMsgOpenDevTools, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgopendevtools(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenDevTools) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgopendevtools_unpack(v)?
	return i, unpacked
}

pub struct CMsgCloseDevTools {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgCloseDevTools) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclosedevtools_unpack(buf []byte) ?CMsgCloseDevTools {
	mut res := zzz_vproto_internal_new_cmsgclosedevtools()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgCloseDevTools) eq(b CMsgCloseDevTools) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgCloseDevTools) ne(b CMsgCloseDevTools) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgCloseDevTools) eq(b []CMsgCloseDevTools) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgCloseDevTools) ne(b []CMsgCloseDevTools) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclosedevtools() CMsgCloseDevTools {
	return CMsgCloseDevTools{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclosedevtools(o CMsgCloseDevTools, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclosedevtools(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCloseDevTools) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclosedevtools_unpack(v)?
	return i, unpacked
}

pub struct CMsgUnlockH264 {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	unlock_code    string
}

pub fn (o &CMsgUnlockH264) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.unlock_code != '' {
		res << vproto.pack_string_field(o.unlock_code, 2)
	}
	return res
}

pub fn cmsgunlockh264_unpack(buf []byte) ?CMsgUnlockH264 {
	mut res := zzz_vproto_internal_new_cmsgunlockh264()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.unlock_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgUnlockH264) eq(b CMsgUnlockH264) bool {
	return true && a.browser_handle == b.browser_handle && a.unlock_code == b.unlock_code
}

[inline]
pub fn (a CMsgUnlockH264) ne(b CMsgUnlockH264) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgUnlockH264) eq(b []CMsgUnlockH264) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgUnlockH264) ne(b []CMsgUnlockH264) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgunlockh264() CMsgUnlockH264 {
	return CMsgUnlockH264{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgunlockh264(o CMsgUnlockH264, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgunlockh264(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgUnlockH264) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgunlockh264_unpack(v)?
	return i, unpacked
}

pub struct CMsgScreenInformationChanged {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	browser_handle  u32
	override_width  u32
	override_height u32
	monitor_left    u32
	monitor_top     u32
	monitor_right   u32
	monitor_bottom  u32
	usable_left     u32
	usable_top      u32
	usable_right    u32
	usable_bottom   u32
}

pub fn (o &CMsgScreenInformationChanged) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.override_width != u32(0) {
		res << vproto.pack_uint32_field(o.override_width, 2)
	}
	if o.override_height != u32(0) {
		res << vproto.pack_uint32_field(o.override_height, 3)
	}
	if o.monitor_left != u32(0) {
		res << vproto.pack_uint32_field(o.monitor_left, 4)
	}
	if o.monitor_top != u32(0) {
		res << vproto.pack_uint32_field(o.monitor_top, 5)
	}
	if o.monitor_right != u32(0) {
		res << vproto.pack_uint32_field(o.monitor_right, 6)
	}
	if o.monitor_bottom != u32(0) {
		res << vproto.pack_uint32_field(o.monitor_bottom, 7)
	}
	if o.usable_left != u32(0) {
		res << vproto.pack_uint32_field(o.usable_left, 8)
	}
	if o.usable_top != u32(0) {
		res << vproto.pack_uint32_field(o.usable_top, 9)
	}
	if o.usable_right != u32(0) {
		res << vproto.pack_uint32_field(o.usable_right, 10)
	}
	if o.usable_bottom != u32(0) {
		res << vproto.pack_uint32_field(o.usable_bottom, 11)
	}
	return res
}

pub fn cmsgscreeninformationchanged_unpack(buf []byte) ?CMsgScreenInformationChanged {
	mut res := zzz_vproto_internal_new_cmsgscreeninformationchanged()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.override_width = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.override_height = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_left = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_top = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_right = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_bottom = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_left = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_top = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_right = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_bottom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgScreenInformationChanged) eq(b CMsgScreenInformationChanged) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.override_width == b.override_width &&
		a.override_height == b.override_height &&
		a.monitor_left == b.monitor_left &&
		a.monitor_top == b.monitor_top && a.monitor_right == b.monitor_right &&
		a.monitor_bottom == b.monitor_bottom &&
		a.usable_left == b.usable_left && a.usable_top == b.usable_top &&
		a.usable_right == b.usable_right &&
		a.usable_bottom == b.usable_bottom
}

[inline]
pub fn (a CMsgScreenInformationChanged) ne(b CMsgScreenInformationChanged) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgScreenInformationChanged) eq(b []CMsgScreenInformationChanged) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgScreenInformationChanged) ne(b []CMsgScreenInformationChanged) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgscreeninformationchanged() CMsgScreenInformationChanged {
	return CMsgScreenInformationChanged{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscreeninformationchanged(o CMsgScreenInformationChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscreeninformationchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScreenInformationChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscreeninformationchanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgClearAllCookies {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgClearAllCookies) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclearallcookies_unpack(buf []byte) ?CMsgClearAllCookies {
	mut res := zzz_vproto_internal_new_cmsgclearallcookies()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgClearAllCookies) eq(b CMsgClearAllCookies) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgClearAllCookies) ne(b CMsgClearAllCookies) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgClearAllCookies) eq(b []CMsgClearAllCookies) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgClearAllCookies) ne(b []CMsgClearAllCookies) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgclearallcookies() CMsgClearAllCookies {
	return CMsgClearAllCookies{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgclearallcookies(o CMsgClearAllCookies, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgclearallcookies(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearAllCookies) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclearallcookies_unpack(v)?
	return i, unpacked
}

pub struct CMsgScreenDPI {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	dpi_scaling    f32
}

pub fn (o &CMsgScreenDPI) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.dpi_scaling != f32(0) {
		res << vproto.pack_float_field(o.dpi_scaling, 2)
	}
	return res
}

pub fn cmsgscreendpi_unpack(buf []byte) ?CMsgScreenDPI {
	mut res := zzz_vproto_internal_new_cmsgscreendpi()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.dpi_scaling = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgScreenDPI) eq(b CMsgScreenDPI) bool {
	return true && a.browser_handle == b.browser_handle && a.dpi_scaling == b.dpi_scaling
}

[inline]
pub fn (a CMsgScreenDPI) ne(b CMsgScreenDPI) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgScreenDPI) eq(b []CMsgScreenDPI) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgScreenDPI) ne(b []CMsgScreenDPI) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgscreendpi() CMsgScreenDPI {
	return CMsgScreenDPI{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgscreendpi(o CMsgScreenDPI, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgscreendpi(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScreenDPI) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscreendpi_unpack(v)?
	return i, unpacked
}

pub struct CMsgAuthedSteamDomains {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	domains        []string
}

pub fn (o &CMsgAuthedSteamDomains) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.domains {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cmsgauthedsteamdomains_unpack(buf []byte) ?CMsgAuthedSteamDomains {
	mut res := zzz_vproto_internal_new_cmsgauthedsteamdomains()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.domains << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgAuthedSteamDomains) eq(b CMsgAuthedSteamDomains) bool {
	return true && a.domains == b.domains
}

[inline]
pub fn (a CMsgAuthedSteamDomains) ne(b CMsgAuthedSteamDomains) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgAuthedSteamDomains) eq(b []CMsgAuthedSteamDomains) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgAuthedSteamDomains) ne(b []CMsgAuthedSteamDomains) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgauthedsteamdomains() CMsgAuthedSteamDomains {
	return CMsgAuthedSteamDomains{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgauthedsteamdomains(o CMsgAuthedSteamDomains, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgauthedsteamdomains(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAuthedSteamDomains) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgauthedsteamdomains_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamAuthNeeded {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filler         bool
}

pub fn (o &CMsgSteamAuthNeeded) pack() []byte {
	mut res := []byte{}
	if o.filler != bool(0) {
		res << vproto.pack_bool_field(o.filler, 1)
	}
	return res
}

pub fn cmsgsteamauthneeded_unpack(buf []byte) ?CMsgSteamAuthNeeded {
	mut res := zzz_vproto_internal_new_cmsgsteamauthneeded()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.filler = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamAuthNeeded) eq(b CMsgSteamAuthNeeded) bool {
	return true && a.filler == b.filler
}

[inline]
pub fn (a CMsgSteamAuthNeeded) ne(b CMsgSteamAuthNeeded) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamAuthNeeded) eq(b []CMsgSteamAuthNeeded) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamAuthNeeded) ne(b []CMsgSteamAuthNeeded) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamauthneeded() CMsgSteamAuthNeeded {
	return CMsgSteamAuthNeeded{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamauthneeded(o CMsgSteamAuthNeeded, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamauthneeded(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamAuthNeeded) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamauthneeded_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamAuthCookiesSet {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	success        bool
}

pub fn (o &CMsgSteamAuthCookiesSet) pack() []byte {
	mut res := []byte{}
	if o.success != bool(0) {
		res << vproto.pack_bool_field(o.success, 1)
	}
	return res
}

pub fn cmsgsteamauthcookiesset_unpack(buf []byte) ?CMsgSteamAuthCookiesSet {
	mut res := zzz_vproto_internal_new_cmsgsteamauthcookiesset()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSteamAuthCookiesSet) eq(b CMsgSteamAuthCookiesSet) bool {
	return true && a.success == b.success
}

[inline]
pub fn (a CMsgSteamAuthCookiesSet) ne(b CMsgSteamAuthCookiesSet) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSteamAuthCookiesSet) eq(b []CMsgSteamAuthCookiesSet) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSteamAuthCookiesSet) ne(b []CMsgSteamAuthCookiesSet) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsteamauthcookiesset() CMsgSteamAuthCookiesSet {
	return CMsgSteamAuthCookiesSet{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsteamauthcookiesset(o CMsgSteamAuthCookiesSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsteamauthcookiesset(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamAuthCookiesSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamauthcookiesset_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSRegisterMethod {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	name           string
	method_type    EJSRegisterMethodType = .k_ejsregistermethodtype_invalid
}

pub fn (o &CMsgJSRegisterMethod) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.method_type != zzz_vproto_internal_new_ejsregistermethodtype() {
		res << zzz_vproto_internal_pack_ejsregistermethodtype(o.method_type, 3)
	}
	return res
}

pub fn cmsgjsregistermethod_unpack(buf []byte) ?CMsgJSRegisterMethod {
	mut res := zzz_vproto_internal_new_cmsgjsregistermethod()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_ejsregistermethodtype(cur_buf, tag_wiretype.wire_type)?
				res.method_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSRegisterMethod) eq(b CMsgJSRegisterMethod) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.name == b.name && a.method_type == b.method_type
}

[inline]
pub fn (a CMsgJSRegisterMethod) ne(b CMsgJSRegisterMethod) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSRegisterMethod) eq(b []CMsgJSRegisterMethod) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSRegisterMethod) ne(b []CMsgJSRegisterMethod) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsregistermethod() CMsgJSRegisterMethod {
	return CMsgJSRegisterMethod{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsregistermethod(o CMsgJSRegisterMethod, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsregistermethod(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSRegisterMethod) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsregistermethod_unpack(v)?
	return i, unpacked
}

pub struct CJSMethodArgument {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	json_data       string
	function_handle u64
}

pub fn (o &CJSMethodArgument) pack() []byte {
	mut res := []byte{}
	if o.json_data != '' {
		res << vproto.pack_string_field(o.json_data, 1)
	}
	if o.function_handle != u64(0) {
		res << vproto.pack_uint64_field(o.function_handle, 2)
	}
	return res
}

pub fn cjsmethodargument_unpack(buf []byte) ?CJSMethodArgument {
	mut res := zzz_vproto_internal_new_cjsmethodargument()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.json_data = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CJSMethodArgument) eq(b CJSMethodArgument) bool {
	return true && a.json_data == b.json_data && a.function_handle == b.function_handle
}

[inline]
pub fn (a CJSMethodArgument) ne(b CJSMethodArgument) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CJSMethodArgument) eq(b []CJSMethodArgument) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CJSMethodArgument) ne(b []CJSMethodArgument) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cjsmethodargument() CJSMethodArgument {
	return CJSMethodArgument{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cjsmethodargument(o CJSMethodArgument, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cjsmethodargument(buf []byte, tag_wiretype vproto.WireType) ?(int, CJSMethodArgument) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cjsmethodargument_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSValue_JSObjectProperty {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	value          CMsgJSValue
}

pub fn (o &CMsgJSValue_JSObjectProperty) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.value.ne(zzz_vproto_internal_new_cmsgjsvalue()) {
		res << zzz_vproto_internal_pack_cmsgjsvalue(o.value, 2)
	}
	return res
}

pub fn cmsgjsvalue_jsobjectproperty_unpack(buf []byte) ?CMsgJSValue_JSObjectProperty {
	mut res := zzz_vproto_internal_new_cmsgjsvalue_jsobjectproperty()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSValue_JSObjectProperty) eq(b CMsgJSValue_JSObjectProperty) bool {
	return true && a.name == b.name && a.value.eq(b.value)
}

[inline]
pub fn (a CMsgJSValue_JSObjectProperty) ne(b CMsgJSValue_JSObjectProperty) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSValue_JSObjectProperty) eq(b []CMsgJSValue_JSObjectProperty) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSValue_JSObjectProperty) ne(b []CMsgJSValue_JSObjectProperty) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsvalue_jsobjectproperty() CMsgJSValue_JSObjectProperty {
	return CMsgJSValue_JSObjectProperty{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsvalue_jsobjectproperty(o CMsgJSValue_JSObjectProperty, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsvalue_jsobjectproperty(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSValue_JSObjectProperty) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsvalue_jsobjectproperty_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSValue {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	bool_value        bool
	int_value         int
	uint_value        u32
	double_value      f64
	string_value      string
	function_handle   u64
	is_array          bool
	array_values      []CMsgJSValue
	is_object         bool
	object_properties []CMsgJSValue_JSObjectProperty
}

pub fn (o &CMsgJSValue) pack() []byte {
	mut res := []byte{}
	if o.bool_value != bool(0) {
		res << vproto.pack_bool_field(o.bool_value, 1)
	}
	if o.int_value != int(0) {
		res << vproto.pack_int32_field(o.int_value, 2)
	}
	if o.uint_value != u32(0) {
		res << vproto.pack_uint32_field(o.uint_value, 3)
	}
	if o.double_value != f64(0) {
		res << vproto.pack_double_field(o.double_value, 4)
	}
	if o.string_value != '' {
		res << vproto.pack_string_field(o.string_value, 5)
	}
	if o.function_handle != u64(0) {
		res << vproto.pack_uint64_field(o.function_handle, 6)
	}
	if o.is_array != bool(0) {
		res << vproto.pack_bool_field(o.is_array, 8)
	}
	// [packed=false]
	for _, x in o.array_values {
		res << zzz_vproto_internal_pack_cmsgjsvalue(x, 9)
	}
	if o.is_object != bool(0) {
		res << vproto.pack_bool_field(o.is_object, 10)
	}
	// [packed=false]
	for _, x in o.object_properties {
		res << zzz_vproto_internal_pack_cmsgjsvalue_jsobjectproperty(x, 11)
	}
	return res
}

pub fn cmsgjsvalue_unpack(buf []byte) ?CMsgJSValue {
	mut res := zzz_vproto_internal_new_cmsgjsvalue()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bool_value = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.int_value = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.uint_value = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
				res.double_value = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.string_value = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_array = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.array_values << v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_object = v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue_jsobjectproperty(cur_buf,
					tag_wiretype.wire_type)?
				res.object_properties << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSValue) eq(b CMsgJSValue) bool {
	return true && a.bool_value == b.bool_value &&
		a.int_value == b.int_value && a.uint_value == b.uint_value &&
		a.double_value == b.double_value &&
		a.string_value == b.string_value &&
		a.function_handle == b.function_handle &&
		a.is_array == b.is_array && a.array_values.eq(b.array_values) &&
		a.is_object == b.is_object && a.object_properties.eq(b.object_properties)
}

[inline]
pub fn (a CMsgJSValue) ne(b CMsgJSValue) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSValue) eq(b []CMsgJSValue) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSValue) ne(b []CMsgJSValue) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsvalue() CMsgJSValue {
	return CMsgJSValue{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsvalue(o CMsgJSValue, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsvalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSValue) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsvalue_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSMethodCall {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	name           string
	arguments      []CMsgJSValue
}

pub fn (o &CMsgJSMethodCall) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 2)
	}
	// [packed=false]
	for _, x in o.arguments {
		res << zzz_vproto_internal_pack_cmsgjsvalue(x, 3)
	}
	return res
}

pub fn cmsgjsmethodcall_unpack(buf []byte) ?CMsgJSMethodCall {
	mut res := zzz_vproto_internal_new_cmsgjsmethodcall()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.arguments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSMethodCall) eq(b CMsgJSMethodCall) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.name == b.name && a.arguments.eq(b.arguments)
}

[inline]
pub fn (a CMsgJSMethodCall) ne(b CMsgJSMethodCall) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSMethodCall) eq(b []CMsgJSMethodCall) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSMethodCall) ne(b []CMsgJSMethodCall) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsmethodcall() CMsgJSMethodCall {
	return CMsgJSMethodCall{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsmethodcall(o CMsgJSMethodCall, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsmethodcall(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSMethodCall) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsmethodcall_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSExecuteCallback {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	browser_handle  u32
	function_handle u64
	arguments       []CMsgJSValue
}

pub fn (o &CMsgJSExecuteCallback) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.function_handle != u64(0) {
		res << vproto.pack_uint64_field(o.function_handle, 2)
	}
	// [packed=false]
	for _, x in o.arguments {
		res << zzz_vproto_internal_pack_cmsgjsvalue(x, 3)
	}
	return res
}

pub fn cmsgjsexecutecallback_unpack(buf []byte) ?CMsgJSExecuteCallback {
	mut res := zzz_vproto_internal_new_cmsgjsexecutecallback()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.arguments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSExecuteCallback) eq(b CMsgJSExecuteCallback) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.function_handle == b.function_handle && a.arguments.eq(b.arguments)
}

[inline]
pub fn (a CMsgJSExecuteCallback) ne(b CMsgJSExecuteCallback) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSExecuteCallback) eq(b []CMsgJSExecuteCallback) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSExecuteCallback) ne(b []CMsgJSExecuteCallback) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsexecutecallback() CMsgJSExecuteCallback {
	return CMsgJSExecuteCallback{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsexecutecallback(o CMsgJSExecuteCallback, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsexecutecallback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSExecuteCallback) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsexecutecallback_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSReleaseCallback {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	browser_handle  u32
	function_handle u64
}

pub fn (o &CMsgJSReleaseCallback) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.function_handle != u64(0) {
		res << vproto.pack_uint64_field(o.function_handle, 2)
	}
	return res
}

pub fn cmsgjsreleasecallback_unpack(buf []byte) ?CMsgJSReleaseCallback {
	mut res := zzz_vproto_internal_new_cmsgjsreleasecallback()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSReleaseCallback) eq(b CMsgJSReleaseCallback) bool {
	return true && a.browser_handle == b.browser_handle && a.function_handle == b.function_handle
}

[inline]
pub fn (a CMsgJSReleaseCallback) ne(b CMsgJSReleaseCallback) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSReleaseCallback) eq(b []CMsgJSReleaseCallback) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSReleaseCallback) ne(b []CMsgJSReleaseCallback) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsreleasecallback() CMsgJSReleaseCallback {
	return CMsgJSReleaseCallback{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsreleasecallback(o CMsgJSReleaseCallback, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsreleasecallback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSReleaseCallback) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsreleasecallback_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSRaiseException {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	exception      string
}

pub fn (o &CMsgJSRaiseException) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.exception != '' {
		res << vproto.pack_string_field(o.exception, 2)
	}
	return res
}

pub fn cmsgjsraiseexception_unpack(buf []byte) ?CMsgJSRaiseException {
	mut res := zzz_vproto_internal_new_cmsgjsraiseexception()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.exception = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJSRaiseException) eq(b CMsgJSRaiseException) bool {
	return true && a.browser_handle == b.browser_handle && a.exception == b.exception
}

[inline]
pub fn (a CMsgJSRaiseException) ne(b CMsgJSRaiseException) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJSRaiseException) eq(b []CMsgJSRaiseException) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJSRaiseException) ne(b []CMsgJSRaiseException) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjsraiseexception() CMsgJSRaiseException {
	return CMsgJSRaiseException{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjsraiseexception(o CMsgJSRaiseException, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjsraiseexception(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSRaiseException) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsraiseexception_unpack(v)?
	return i, unpacked
}

pub struct CMsgLoadLocalization {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	browser_handle    u32
	localization_path string
	language          string
}

pub fn (o &CMsgLoadLocalization) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.localization_path != '' {
		res << vproto.pack_string_field(o.localization_path, 2)
	}
	if o.language != '' {
		res << vproto.pack_string_field(o.language, 3)
	}
	return res
}

pub fn cmsgloadlocalization_unpack(buf []byte) ?CMsgLoadLocalization {
	mut res := zzz_vproto_internal_new_cmsgloadlocalization()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localization_path = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgLoadLocalization) eq(b CMsgLoadLocalization) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.localization_path == b.localization_path &&
		a.language == b.language
}

[inline]
pub fn (a CMsgLoadLocalization) ne(b CMsgLoadLocalization) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgLoadLocalization) eq(b []CMsgLoadLocalization) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgLoadLocalization) ne(b []CMsgLoadLocalization) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgloadlocalization() CMsgLoadLocalization {
	return CMsgLoadLocalization{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgloadlocalization(o CMsgLoadLocalization, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgloadlocalization(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadLocalization) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgloadlocalization_unpack(v)?
	return i, unpacked
}

pub struct CMsgJumpListLink {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	display_name   string
	url_link       string
	icon_path      string
}

pub fn (o &CMsgJumpListLink) pack() []byte {
	mut res := []byte{}
	if o.display_name != '' {
		res << vproto.pack_string_field(o.display_name, 1)
	}
	if o.url_link != '' {
		res << vproto.pack_string_field(o.url_link, 2)
	}
	if o.icon_path != '' {
		res << vproto.pack_string_field(o.icon_path, 3)
	}
	return res
}

pub fn cmsgjumplistlink_unpack(buf []byte) ?CMsgJumpListLink {
	mut res := zzz_vproto_internal_new_cmsgjumplistlink()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.display_name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_link = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgJumpListLink) eq(b CMsgJumpListLink) bool {
	return true && a.display_name == b.display_name &&
		a.url_link == b.url_link && a.icon_path == b.icon_path
}

[inline]
pub fn (a CMsgJumpListLink) ne(b CMsgJumpListLink) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgJumpListLink) eq(b []CMsgJumpListLink) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgJumpListLink) ne(b []CMsgJumpListLink) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjumplistlink() CMsgJumpListLink {
	return CMsgJumpListLink{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjumplistlink(o CMsgJumpListLink, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjumplistlink(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJumpListLink) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjumplistlink_unpack(v)?
	return i, unpacked
}

pub struct CMSgJumpListMRUApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	display_name   string
	url_link       string
	icon_path      string
}

pub fn (o &CMSgJumpListMRUApp) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.display_name != '' {
		res << vproto.pack_string_field(o.display_name, 2)
	}
	if o.url_link != '' {
		res << vproto.pack_string_field(o.url_link, 3)
	}
	if o.icon_path != '' {
		res << vproto.pack_string_field(o.icon_path, 4)
	}
	return res
}

pub fn cmsgjumplistmruapp_unpack(buf []byte) ?CMSgJumpListMRUApp {
	mut res := zzz_vproto_internal_new_cmsgjumplistmruapp()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.display_name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_link = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMSgJumpListMRUApp) eq(b CMSgJumpListMRUApp) bool {
	return true && a.appid == b.appid &&
		a.display_name == b.display_name &&
		a.url_link == b.url_link && a.icon_path == b.icon_path
}

[inline]
pub fn (a CMSgJumpListMRUApp) ne(b CMSgJumpListMRUApp) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMSgJumpListMRUApp) eq(b []CMSgJumpListMRUApp) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMSgJumpListMRUApp) ne(b []CMSgJumpListMRUApp) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgjumplistmruapp() CMSgJumpListMRUApp {
	return CMSgJumpListMRUApp{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgjumplistmruapp(o CMSgJumpListMRUApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgjumplistmruapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMSgJumpListMRUApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjumplistmruapp_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetJumpList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_path     string
	mru_title      string
	apps           []CMSgJumpListMRUApp
	links          []CMsgJumpListLink
}

pub fn (o &CMsgSetJumpList) pack() []byte {
	mut res := []byte{}
	if o.steam_path != '' {
		res << vproto.pack_string_field(o.steam_path, 1)
	}
	if o.mru_title != '' {
		res << vproto.pack_string_field(o.mru_title, 2)
	}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgjumplistmruapp(x, 3)
	}
	// [packed=false]
	for _, x in o.links {
		res << zzz_vproto_internal_pack_cmsgjumplistlink(x, 4)
	}
	return res
}

pub fn cmsgsetjumplist_unpack(buf []byte) ?CMsgSetJumpList {
	mut res := zzz_vproto_internal_new_cmsgsetjumplist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_path = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mru_title = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjumplistmruapp(cur_buf, tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjumplistlink(cur_buf, tag_wiretype.wire_type)?
				res.links << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetJumpList) eq(b CMsgSetJumpList) bool {
	return true && a.steam_path == b.steam_path &&
		a.mru_title == b.mru_title && a.apps.eq(b.apps) && a.links.eq(b.links)
}

[inline]
pub fn (a CMsgSetJumpList) ne(b CMsgSetJumpList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetJumpList) eq(b []CMsgSetJumpList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetJumpList) ne(b []CMsgSetJumpList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetjumplist() CMsgSetJumpList {
	return CMsgSetJumpList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetjumplist(o CMsgSetJumpList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetjumplist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetJumpList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetjumplist_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetGameOverlayTargetPIDs {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	target_pid     []u32
}

pub fn (o &CMsgSetGameOverlayTargetPIDs) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	// [packed=false]
	for _, x in o.target_pid {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cmsgsetgameoverlaytargetpids_unpack(buf []byte) ?CMsgSetGameOverlayTargetPIDs {
	mut res := zzz_vproto_internal_new_cmsgsetgameoverlaytargetpids()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.target_pid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetGameOverlayTargetPIDs) eq(b CMsgSetGameOverlayTargetPIDs) bool {
	return true && a.browser_handle == b.browser_handle && a.target_pid == b.target_pid
}

[inline]
pub fn (a CMsgSetGameOverlayTargetPIDs) ne(b CMsgSetGameOverlayTargetPIDs) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetGameOverlayTargetPIDs) eq(b []CMsgSetGameOverlayTargetPIDs) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetGameOverlayTargetPIDs) ne(b []CMsgSetGameOverlayTargetPIDs) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetgameoverlaytargetpids() CMsgSetGameOverlayTargetPIDs {
	return CMsgSetGameOverlayTargetPIDs{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetgameoverlaytargetpids(o CMsgSetGameOverlayTargetPIDs, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetgameoverlaytargetpids(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetGameOverlayTargetPIDs) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetgameoverlaytargetpids_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameOverlayTargetTextureID {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	target_pid     u32
	texture_handle u32
}

pub fn (o &CMsgGameOverlayTargetTextureID) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.target_pid != u32(0) {
		res << vproto.pack_uint32_field(o.target_pid, 2)
	}
	if o.texture_handle != u32(0) {
		res << vproto.pack_uint32_field(o.texture_handle, 3)
	}
	return res
}

pub fn cmsggameoverlaytargettextureid_unpack(buf []byte) ?CMsgGameOverlayTargetTextureID {
	mut res := zzz_vproto_internal_new_cmsggameoverlaytargettextureid()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.target_pid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.texture_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgGameOverlayTargetTextureID) eq(b CMsgGameOverlayTargetTextureID) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.target_pid == b.target_pid && a.texture_handle == b.texture_handle
}

[inline]
pub fn (a CMsgGameOverlayTargetTextureID) ne(b CMsgGameOverlayTargetTextureID) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgGameOverlayTargetTextureID) eq(b []CMsgGameOverlayTargetTextureID) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgGameOverlayTargetTextureID) ne(b []CMsgGameOverlayTargetTextureID) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsggameoverlaytargettextureid() CMsgGameOverlayTargetTextureID {
	return CMsgGameOverlayTargetTextureID{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsggameoverlaytargettextureid(o CMsgGameOverlayTargetTextureID, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsggameoverlaytargettextureid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameOverlayTargetTextureID) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameoverlaytargettextureid_unpack(v)?
	return i, unpacked
}

pub struct CMsgDraggableRegionsChanged_DraggableRects {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	x              int
	y              int
	width          int
	height         int
	draggable      bool
}

pub fn (o &CMsgDraggableRegionsChanged_DraggableRects) pack() []byte {
	mut res := []byte{}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 1)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 2)
	}
	if o.width != int(0) {
		res << vproto.pack_int32_field(o.width, 3)
	}
	if o.height != int(0) {
		res << vproto.pack_int32_field(o.height, 4)
	}
	if o.draggable != bool(0) {
		res << vproto.pack_bool_field(o.draggable, 5)
	}
	return res
}

pub fn cmsgdraggableregionschanged_draggablerects_unpack(buf []byte) ?CMsgDraggableRegionsChanged_DraggableRects {
	mut res := zzz_vproto_internal_new_cmsgdraggableregionschanged_draggablerects()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.draggable = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgDraggableRegionsChanged_DraggableRects) eq(b CMsgDraggableRegionsChanged_DraggableRects) bool {
	return true && a.x == b.x &&
		a.y == b.y && a.width == b.width &&
		a.height == b.height && a.draggable == b.draggable
}

[inline]
pub fn (a CMsgDraggableRegionsChanged_DraggableRects) ne(b CMsgDraggableRegionsChanged_DraggableRects) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgDraggableRegionsChanged_DraggableRects) eq(b []CMsgDraggableRegionsChanged_DraggableRects) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgDraggableRegionsChanged_DraggableRects) ne(b []CMsgDraggableRegionsChanged_DraggableRects) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgdraggableregionschanged_draggablerects() CMsgDraggableRegionsChanged_DraggableRects {
	return CMsgDraggableRegionsChanged_DraggableRects{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdraggableregionschanged_draggablerects(o CMsgDraggableRegionsChanged_DraggableRects, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdraggableregionschanged_draggablerects(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDraggableRegionsChanged_DraggableRects) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdraggableregionschanged_draggablerects_unpack(v)?
	return i, unpacked
}

pub struct CMsgDraggableRegionsChanged {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	rects          []CMsgDraggableRegionsChanged_DraggableRects
}

pub fn (o &CMsgDraggableRegionsChanged) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	// [packed=false]
	for _, x in o.rects {
		res << zzz_vproto_internal_pack_cmsgdraggableregionschanged_draggablerects(x, 2)
	}
	return res
}

pub fn cmsgdraggableregionschanged_unpack(buf []byte) ?CMsgDraggableRegionsChanged {
	mut res := zzz_vproto_internal_new_cmsgdraggableregionschanged()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgdraggableregionschanged_draggablerects(cur_buf,
					tag_wiretype.wire_type)?
				res.rects << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgDraggableRegionsChanged) eq(b CMsgDraggableRegionsChanged) bool {
	return true && a.browser_handle == b.browser_handle && a.rects.eq(b.rects)
}

[inline]
pub fn (a CMsgDraggableRegionsChanged) ne(b CMsgDraggableRegionsChanged) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgDraggableRegionsChanged) eq(b []CMsgDraggableRegionsChanged) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgDraggableRegionsChanged) ne(b []CMsgDraggableRegionsChanged) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgdraggableregionschanged() CMsgDraggableRegionsChanged {
	return CMsgDraggableRegionsChanged{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdraggableregionschanged(o CMsgDraggableRegionsChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdraggableregionschanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDraggableRegionsChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdraggableregionschanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgResizeGripChanged {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	width          int
	height         int
}

pub fn (o &CMsgResizeGripChanged) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.width != int(0) {
		res << vproto.pack_int32_field(o.width, 2)
	}
	if o.height != int(0) {
		res << vproto.pack_int32_field(o.height, 3)
	}
	return res
}

pub fn cmsgresizegripchanged_unpack(buf []byte) ?CMsgResizeGripChanged {
	mut res := zzz_vproto_internal_new_cmsgresizegripchanged()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgResizeGripChanged) eq(b CMsgResizeGripChanged) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.width == b.width && a.height == b.height
}

[inline]
pub fn (a CMsgResizeGripChanged) ne(b CMsgResizeGripChanged) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgResizeGripChanged) eq(b []CMsgResizeGripChanged) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgResizeGripChanged) ne(b []CMsgResizeGripChanged) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgresizegripchanged() CMsgResizeGripChanged {
	return CMsgResizeGripChanged{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgresizegripchanged(o CMsgResizeGripChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgresizegripchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgResizeGripChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgresizegripchanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetWindowPosition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              int
	y              int
	width          int
	height         int
	min_width      int
	min_height     int
}

pub fn (o &CMsgSetWindowPosition) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != int(0) {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.y != int(0) {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.width != int(0) {
		res << vproto.pack_int32_field(o.width, 4)
	}
	if o.height != int(0) {
		res << vproto.pack_int32_field(o.height, 5)
	}
	if o.min_width != int(0) {
		res << vproto.pack_int32_field(o.min_width, 6)
	}
	if o.min_height != int(0) {
		res << vproto.pack_int32_field(o.min_height, 7)
	}
	return res
}

pub fn cmsgsetwindowposition_unpack(buf []byte) ?CMsgSetWindowPosition {
	mut res := zzz_vproto_internal_new_cmsgsetwindowposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.min_width = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.min_height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetWindowPosition) eq(b CMsgSetWindowPosition) bool {
	return true && a.browser_handle == b.browser_handle &&
		a.x == b.x && a.y == b.y && a.width == b.width &&
		a.height == b.height && a.min_width == b.min_width &&
		a.min_height == b.min_height
}

[inline]
pub fn (a CMsgSetWindowPosition) ne(b CMsgSetWindowPosition) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetWindowPosition) eq(b []CMsgSetWindowPosition) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetWindowPosition) ne(b []CMsgSetWindowPosition) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetwindowposition() CMsgSetWindowPosition {
	return CMsgSetWindowPosition{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetwindowposition(o CMsgSetWindowPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetwindowposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetWindowPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetwindowposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowWindow {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgShowWindow) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgshowwindow_unpack(buf []byte) ?CMsgShowWindow {
	mut res := zzz_vproto_internal_new_cmsgshowwindow()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgShowWindow) eq(b CMsgShowWindow) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgShowWindow) ne(b CMsgShowWindow) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgShowWindow) eq(b []CMsgShowWindow) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgShowWindow) ne(b []CMsgShowWindow) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgshowwindow() CMsgShowWindow {
	return CMsgShowWindow{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowwindow(o CMsgShowWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowwindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgHideWindow {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgHideWindow) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghidewindow_unpack(buf []byte) ?CMsgHideWindow {
	mut res := zzz_vproto_internal_new_cmsghidewindow()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgHideWindow) eq(b CMsgHideWindow) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgHideWindow) ne(b CMsgHideWindow) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgHideWindow) eq(b []CMsgHideWindow) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgHideWindow) ne(b []CMsgHideWindow) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsghidewindow() CMsgHideWindow {
	return CMsgHideWindow{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsghidewindow(o CMsgHideWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsghidewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHideWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghidewindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgBringWindowToFront {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgBringWindowToFront) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgbringwindowtofront_unpack(buf []byte) ?CMsgBringWindowToFront {
	mut res := zzz_vproto_internal_new_cmsgbringwindowtofront()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgBringWindowToFront) eq(b CMsgBringWindowToFront) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgBringWindowToFront) ne(b CMsgBringWindowToFront) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgBringWindowToFront) eq(b []CMsgBringWindowToFront) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgBringWindowToFront) ne(b []CMsgBringWindowToFront) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgbringwindowtofront() CMsgBringWindowToFront {
	return CMsgBringWindowToFront{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgbringwindowtofront(o CMsgBringWindowToFront, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgbringwindowtofront(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBringWindowToFront) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbringwindowtofront_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetForegroundWindow {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgSetForegroundWindow) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgsetforegroundwindow_unpack(buf []byte) ?CMsgSetForegroundWindow {
	mut res := zzz_vproto_internal_new_cmsgsetforegroundwindow()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgSetForegroundWindow) eq(b CMsgSetForegroundWindow) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgSetForegroundWindow) ne(b CMsgSetForegroundWindow) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgSetForegroundWindow) eq(b []CMsgSetForegroundWindow) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgSetForegroundWindow) ne(b []CMsgSetForegroundWindow) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgsetforegroundwindow() CMsgSetForegroundWindow {
	return CMsgSetForegroundWindow{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgsetforegroundwindow(o CMsgSetForegroundWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgsetforegroundwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetForegroundWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetforegroundwindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgMaximizeRestoreWindow {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgMaximizeRestoreWindow) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgmaximizerestorewindow_unpack(buf []byte) ?CMsgMaximizeRestoreWindow {
	mut res := zzz_vproto_internal_new_cmsgmaximizerestorewindow()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMaximizeRestoreWindow) eq(b CMsgMaximizeRestoreWindow) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgMaximizeRestoreWindow) ne(b CMsgMaximizeRestoreWindow) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMaximizeRestoreWindow) eq(b []CMsgMaximizeRestoreWindow) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMaximizeRestoreWindow) ne(b []CMsgMaximizeRestoreWindow) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmaximizerestorewindow() CMsgMaximizeRestoreWindow {
	return CMsgMaximizeRestoreWindow{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmaximizerestorewindow(o CMsgMaximizeRestoreWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmaximizerestorewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMaximizeRestoreWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmaximizerestorewindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgMinimizeWindow {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgMinimizeWindow) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgminimizewindow_unpack(buf []byte) ?CMsgMinimizeWindow {
	mut res := zzz_vproto_internal_new_cmsgminimizewindow()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMinimizeWindow) eq(b CMsgMinimizeWindow) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgMinimizeWindow) ne(b CMsgMinimizeWindow) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMinimizeWindow) eq(b []CMsgMinimizeWindow) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMinimizeWindow) ne(b []CMsgMinimizeWindow) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgminimizewindow() CMsgMinimizeWindow {
	return CMsgMinimizeWindow{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgminimizewindow(o CMsgMinimizeWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgminimizewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMinimizeWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgminimizewindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowBrowserContextMenu {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgShowBrowserContextMenu) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgshowbrowsercontextmenu_unpack(buf []byte) ?CMsgShowBrowserContextMenu {
	mut res := zzz_vproto_internal_new_cmsgshowbrowsercontextmenu()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgShowBrowserContextMenu) eq(b CMsgShowBrowserContextMenu) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgShowBrowserContextMenu) ne(b CMsgShowBrowserContextMenu) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgShowBrowserContextMenu) eq(b []CMsgShowBrowserContextMenu) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgShowBrowserContextMenu) ne(b []CMsgShowBrowserContextMenu) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgshowbrowsercontextmenu() CMsgShowBrowserContextMenu {
	return CMsgShowBrowserContextMenu{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgshowbrowsercontextmenu(o CMsgShowBrowserContextMenu, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgshowbrowsercontextmenu(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowBrowserContextMenu) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowbrowsercontextmenu_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeSetComposition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	text           string
}

pub fn (o &CMsgImeSetComposition) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.text != '' {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgimesetcomposition_unpack(buf []byte) ?CMsgImeSetComposition {
	mut res := zzz_vproto_internal_new_cmsgimesetcomposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgImeSetComposition) eq(b CMsgImeSetComposition) bool {
	return true && a.browser_handle == b.browser_handle && a.text == b.text
}

[inline]
pub fn (a CMsgImeSetComposition) ne(b CMsgImeSetComposition) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgImeSetComposition) eq(b []CMsgImeSetComposition) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgImeSetComposition) ne(b []CMsgImeSetComposition) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgimesetcomposition() CMsgImeSetComposition {
	return CMsgImeSetComposition{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimesetcomposition(o CMsgImeSetComposition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimesetcomposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeSetComposition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimesetcomposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeCommitText {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	text           string
}

pub fn (o &CMsgImeCommitText) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.text != '' {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgimecommittext_unpack(buf []byte) ?CMsgImeCommitText {
	mut res := zzz_vproto_internal_new_cmsgimecommittext()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgImeCommitText) eq(b CMsgImeCommitText) bool {
	return true && a.browser_handle == b.browser_handle && a.text == b.text
}

[inline]
pub fn (a CMsgImeCommitText) ne(b CMsgImeCommitText) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgImeCommitText) eq(b []CMsgImeCommitText) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgImeCommitText) ne(b []CMsgImeCommitText) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgimecommittext() CMsgImeCommitText {
	return CMsgImeCommitText{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimecommittext(o CMsgImeCommitText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimecommittext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCommitText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimecommittext_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeCancelComposition {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
}

pub fn (o &CMsgImeCancelComposition) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgimecancelcomposition_unpack(buf []byte) ?CMsgImeCancelComposition {
	mut res := zzz_vproto_internal_new_cmsgimecancelcomposition()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgImeCancelComposition) eq(b CMsgImeCancelComposition) bool {
	return true && a.browser_handle == b.browser_handle
}

[inline]
pub fn (a CMsgImeCancelComposition) ne(b CMsgImeCancelComposition) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgImeCancelComposition) eq(b []CMsgImeCancelComposition) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgImeCancelComposition) ne(b []CMsgImeCancelComposition) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgimecancelcomposition() CMsgImeCancelComposition {
	return CMsgImeCancelComposition{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimecancelcomposition(o CMsgImeCancelComposition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimecancelcomposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCancelComposition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimecancelcomposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeCompositionRangeChanged {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              u32
	y              u32
}

pub fn (o &CMsgImeCompositionRangeChanged) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != u32(0) {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.y != u32(0) {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsgimecompositionrangechanged_unpack(buf []byte) ?CMsgImeCompositionRangeChanged {
	mut res := zzz_vproto_internal_new_cmsgimecompositionrangechanged()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgImeCompositionRangeChanged) eq(b CMsgImeCompositionRangeChanged) bool {
	return true && a.browser_handle == b.browser_handle && a.x == b.x && a.y == b.y
}

[inline]
pub fn (a CMsgImeCompositionRangeChanged) ne(b CMsgImeCompositionRangeChanged) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgImeCompositionRangeChanged) eq(b []CMsgImeCompositionRangeChanged) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgImeCompositionRangeChanged) ne(b []CMsgImeCompositionRangeChanged) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgimecompositionrangechanged() CMsgImeCompositionRangeChanged {
	return CMsgImeCompositionRangeChanged{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgimecompositionrangechanged(o CMsgImeCompositionRangeChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgimecompositionrangechanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCompositionRangeChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimecompositionrangechanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgInspectElement {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	x              u32
	y              u32
}

pub fn (o &CMsgInspectElement) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.x != u32(0) {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.y != u32(0) {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsginspectelement_unpack(buf []byte) ?CMsgInspectElement {
	mut res := zzz_vproto_internal_new_cmsginspectelement()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgInspectElement) eq(b CMsgInspectElement) bool {
	return true && a.browser_handle == b.browser_handle && a.x == b.x && a.y == b.y
}

[inline]
pub fn (a CMsgInspectElement) ne(b CMsgInspectElement) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgInspectElement) eq(b []CMsgInspectElement) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgInspectElement) ne(b []CMsgInspectElement) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsginspectelement() CMsgInspectElement {
	return CMsgInspectElement{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsginspectelement(o CMsgInspectElement, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsginspectelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgInspectElement) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsginspectelement_unpack(v)?
	return i, unpacked
}

pub struct CMsgDisableF5 {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	disable        bool
}

pub fn (o &CMsgDisableF5) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.disable != bool(0) {
		res << vproto.pack_bool_field(o.disable, 2)
	}
	return res
}

pub fn cmsgdisablef5_unpack(buf []byte) ?CMsgDisableF5 {
	mut res := zzz_vproto_internal_new_cmsgdisablef5()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgDisableF5) eq(b CMsgDisableF5) bool {
	return true && a.browser_handle == b.browser_handle && a.disable == b.disable
}

[inline]
pub fn (a CMsgDisableF5) ne(b CMsgDisableF5) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgDisableF5) eq(b []CMsgDisableF5) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgDisableF5) ne(b []CMsgDisableF5) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgdisablef5() CMsgDisableF5 {
	return CMsgDisableF5{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgdisablef5(o CMsgDisableF5, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgdisablef5(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDisableF5) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdisablef5_unpack(v)?
	return i, unpacked
}

pub struct CMsgStartDownload {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	browser_handle u32
	url            string
}

pub fn (o &CMsgStartDownload) pack() []byte {
	mut res := []byte{}
	if o.browser_handle != u32(0) {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 2)
	}
	return res
}

pub fn cmsgstartdownload_unpack(buf []byte) ?CMsgStartDownload {
	mut res := zzz_vproto_internal_new_cmsgstartdownload()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgStartDownload) eq(b CMsgStartDownload) bool {
	return true && a.browser_handle == b.browser_handle && a.url == b.url
}

[inline]
pub fn (a CMsgStartDownload) ne(b CMsgStartDownload) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgStartDownload) eq(b []CMsgStartDownload) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgStartDownload) ne(b []CMsgStartDownload) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgstartdownload() CMsgStartDownload {
	return CMsgStartDownload{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgstartdownload(o CMsgStartDownload, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgstartdownload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartDownload) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstartdownload_unpack(v)?
	return i, unpacked
}
