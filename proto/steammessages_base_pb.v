// Generated by vproto - Do not modify
module proto

import emily33901.vproto
import proto.google.protobuf

[_allow_multiple_values]
enum EProtoClanEventType {
	k_eclanotherevent = 1
	k_eclangameevent = 2
	k_eclanpartyevent = 3
	k_eclanmeetingevent = 4
	k_eclanspecialcauseevent = 5
	k_eclanmusicandartsevent = 6
	k_eclansportsevent = 7
	k_eclantripevent = 8
	k_eclanchatevent = 9
	k_eclangamereleaseevent = 10
	k_eclanbroadcastevent = 11
	k_eclansmallupdateevent = 12
	k_eclanpreannouncemajorupdateevent = 13
	k_eclanmajorupdateevent = 14
	k_eclandlcreleaseevent = 15
	k_eclanfuturereleaseevent = 16
	k_eclanesporttournamentstreamevent = 17
	k_eclandevstreamevent = 18
	k_eclanfamousstreamevent = 19
	k_eclangamesalesevent = 20
	k_eclangameitemsalesevent = 21
	k_eclaningamebonusxpevent = 22
	k_eclaningamelootevent = 23
	k_eclaningameperksevent = 24
	k_eclaningamechallengeevent = 25
	k_eclaningamecontestevent = 26
	k_eclanirlevent = 27
	k_eclannewsevent = 28
	k_eclanbetareleaseevent = 29
	k_eclaningamecontentreleaseevent = 30
	k_eclanfreetrial = 31
	k_eclanseasonrelease = 32
	k_eclanseasonupdate = 33
	k_eclancrosspostevent = 34
	k_eclaningameeventgeneral = 35
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_eprotoclaneventtype() EProtoClanEventType {
	return .k_eclanotherevent
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eprotoclaneventtype(e EProtoClanEventType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_eprotoclaneventtype_packed(e []EProtoClanEventType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eprotoclaneventtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EProtoClanEventType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EProtoClanEventType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_eprotoclaneventtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EProtoClanEventType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum PartnerEventNotificationType {
	k_eeventstart = 0
	k_eeventbroadcaststart = 1
	k_eeventmatchstart = 2
	k_eeventpartnermaxtype = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_partnereventnotificationtype() PartnerEventNotificationType {
	return .k_eeventstart
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_partnereventnotificationtype(e PartnerEventNotificationType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_partnereventnotificationtype_packed(e []PartnerEventNotificationType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_partnereventnotificationtype(buf []byte, tag_wiretype vproto.WireType) ?(int, PartnerEventNotificationType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, PartnerEventNotificationType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_partnereventnotificationtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []PartnerEventNotificationType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgIPAddress {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgIPAddress) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgipaddress_unpack(buf []byte) ?CMsgIPAddress {
	res := zzz_vproto_internal_new_cmsgipaddress()
	return res
}

[inline]
pub fn (a CMsgIPAddress) eq(b CMsgIPAddress) bool {
	return true
}

[inline]
pub fn (a CMsgIPAddress) ne(b CMsgIPAddress) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgIPAddress) eq(b []CMsgIPAddress) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgIPAddress) ne(b []CMsgIPAddress) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgipaddress() CMsgIPAddress {
	return CMsgIPAddress{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgipaddress(o CMsgIPAddress, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgipaddress(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgIPAddress) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgipaddress_unpack(v)?
	return i, unpacked
}

pub struct CMsgIPAddressBucket {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	original_ip_address CMsgIPAddress
	bucket              u64
}

pub fn (o &CMsgIPAddressBucket) pack() []byte {
	mut res := []byte{}
	if o.original_ip_address.ne(zzz_vproto_internal_new_cmsgipaddress()) {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.original_ip_address, 1)
	}
	if o.bucket != u64(0) {
		res << vproto.pack_64bit_field(o.bucket, 2)
	}
	return res
}

pub fn cmsgipaddressbucket_unpack(buf []byte) ?CMsgIPAddressBucket {
	mut res := zzz_vproto_internal_new_cmsgipaddressbucket()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.original_ip_address = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.bucket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgIPAddressBucket) eq(b CMsgIPAddressBucket) bool {
	return true && a.original_ip_address.eq(b.original_ip_address) && a.bucket == b.bucket
}

[inline]
pub fn (a CMsgIPAddressBucket) ne(b CMsgIPAddressBucket) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgIPAddressBucket) eq(b []CMsgIPAddressBucket) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgIPAddressBucket) ne(b []CMsgIPAddressBucket) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgipaddressbucket() CMsgIPAddressBucket {
	return CMsgIPAddressBucket{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgipaddressbucket(o CMsgIPAddressBucket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgipaddressbucket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgIPAddressBucket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgipaddressbucket_unpack(v)?
	return i, unpacked
}

pub struct CMsgProtoBufHeader {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	steamid                 u64
	client_sessionid        int
	routing_appid           u32
	jobid_source            u64 = 18446744073709551615
	jobid_target            u64 = 18446744073709551615
	target_job_name         string
	seq_num                 int
	eresult                 int = 2
	error_message           string
	auth_account_flags      u32
	token_source            u32
	admin_spoofing_user     bool
	transport_error         int = 1
	messageid               u64 = 18446744073709551615
	publisher_group_id      u32
	sysid                   u32
	trace_tag               u64
	webapi_key_id           u32
	is_from_external_source bool
	forward_to_sysid        []u32
	cm_sysid                u32
	wg_token                string
	launcher_type           u32 = 0
	realm                   u32 = 0
}

pub fn (o &CMsgProtoBufHeader) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.client_sessionid != int(0) {
		res << vproto.pack_int32_field(o.client_sessionid, 2)
	}
	if o.routing_appid != u32(0) {
		res << vproto.pack_uint32_field(o.routing_appid, 3)
	}
	if o.jobid_source != u64(0) {
		res << vproto.pack_64bit_field(o.jobid_source, 10)
	}
	if o.jobid_target != u64(0) {
		res << vproto.pack_64bit_field(o.jobid_target, 11)
	}
	if o.target_job_name != '' {
		res << vproto.pack_string_field(o.target_job_name, 12)
	}
	if o.seq_num != int(0) {
		res << vproto.pack_int32_field(o.seq_num, 24)
	}
	if o.eresult != int(0) {
		res << vproto.pack_int32_field(o.eresult, 13)
	}
	if o.error_message != '' {
		res << vproto.pack_string_field(o.error_message, 14)
	}
	if o.auth_account_flags != u32(0) {
		res << vproto.pack_uint32_field(o.auth_account_flags, 16)
	}
	if o.token_source != u32(0) {
		res << vproto.pack_uint32_field(o.token_source, 22)
	}
	if o.admin_spoofing_user != bool(0) {
		res << vproto.pack_bool_field(o.admin_spoofing_user, 23)
	}
	if o.transport_error != int(0) {
		res << vproto.pack_int32_field(o.transport_error, 17)
	}
	if o.messageid != u64(0) {
		res << vproto.pack_uint64_field(o.messageid, 18)
	}
	if o.publisher_group_id != u32(0) {
		res << vproto.pack_uint32_field(o.publisher_group_id, 19)
	}
	if o.sysid != u32(0) {
		res << vproto.pack_uint32_field(o.sysid, 20)
	}
	if o.trace_tag != u64(0) {
		res << vproto.pack_uint64_field(o.trace_tag, 21)
	}
	if o.webapi_key_id != u32(0) {
		res << vproto.pack_uint32_field(o.webapi_key_id, 25)
	}
	if o.is_from_external_source != bool(0) {
		res << vproto.pack_bool_field(o.is_from_external_source, 26)
	}
	// [packed=false]
	for _, x in o.forward_to_sysid {
		res << vproto.pack_uint32_field(x, 27)
	}
	if o.cm_sysid != u32(0) {
		res << vproto.pack_uint32_field(o.cm_sysid, 28)
	}
	if o.wg_token != '' {
		res << vproto.pack_string_field(o.wg_token, 30)
	}
	if o.launcher_type != u32(0) {
		res << vproto.pack_uint32_field(o.launcher_type, 31)
	}
	if o.realm != u32(0) {
		res << vproto.pack_uint32_field(o.realm, 32)
	}
	return res
}

pub fn cmsgprotobufheader_unpack(buf []byte) ?CMsgProtoBufHeader {
	mut res := zzz_vproto_internal_new_cmsgprotobufheader()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_sessionid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.routing_appid = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.jobid_source = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.jobid_target = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.target_job_name = v
				i = ii
			}
			24 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.error_message = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_account_flags = v
				i = ii
			}
			22 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.token_source = v
				i = ii
			}
			23 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.admin_spoofing_user = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.transport_error = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.messageid = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.publisher_group_id = v
				i = ii
			}
			20 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid = v
				i = ii
			}
			21 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.trace_tag = v
				i = ii
			}
			25 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.webapi_key_id = v
				i = ii
			}
			26 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_from_external_source = v
				i = ii
			}
			27 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.forward_to_sysid << v
				i = ii
			}
			28 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cm_sysid = v
				i = ii
			}
			30 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.wg_token = v
				i = ii
			}
			31 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.launcher_type = v
				i = ii
			}
			32 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.realm = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgProtoBufHeader) eq(b CMsgProtoBufHeader) bool {
	return true && a.steamid == b.steamid &&
		a.client_sessionid == b.client_sessionid &&
		a.routing_appid == b.routing_appid &&
		a.jobid_source == b.jobid_source &&
		a.jobid_target == b.jobid_target &&
		a.target_job_name == b.target_job_name &&
		a.seq_num == b.seq_num && a.eresult == b.eresult &&
		a.error_message == b.error_message &&
		a.auth_account_flags == b.auth_account_flags &&
		a.token_source == b.token_source &&
		a.admin_spoofing_user == b.admin_spoofing_user &&
		a.transport_error == b.transport_error &&
		a.messageid == b.messageid && a.publisher_group_id == b.publisher_group_id &&
		a.sysid == b.sysid && a.trace_tag == b.trace_tag &&
		a.webapi_key_id == b.webapi_key_id &&
		a.is_from_external_source == b.is_from_external_source &&
		a.forward_to_sysid == b.forward_to_sysid &&
		a.cm_sysid == b.cm_sysid && a.wg_token == b.wg_token &&
		a.launcher_type == b.launcher_type &&
		a.realm == b.realm
}

[inline]
pub fn (a CMsgProtoBufHeader) ne(b CMsgProtoBufHeader) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgProtoBufHeader) eq(b []CMsgProtoBufHeader) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgProtoBufHeader) ne(b []CMsgProtoBufHeader) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgprotobufheader() CMsgProtoBufHeader {
	return CMsgProtoBufHeader{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgprotobufheader(o CMsgProtoBufHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgprotobufheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgProtoBufHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgprotobufheader_unpack(v)?
	return i, unpacked
}

pub struct CMsgMulti {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	size_unzipped  u32
	message_body   []byte
}

pub fn (o &CMsgMulti) pack() []byte {
	mut res := []byte{}
	if o.size_unzipped != u32(0) {
		res << vproto.pack_uint32_field(o.size_unzipped, 1)
	}
	if o.message_body != []byte{} {
		res << vproto.pack_bytes_field(o.message_body, 2)
	}
	return res
}

pub fn cmsgmulti_unpack(buf []byte) ?CMsgMulti {
	mut res := zzz_vproto_internal_new_cmsgmulti()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.size_unzipped = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.message_body = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgMulti) eq(b CMsgMulti) bool {
	return true && a.size_unzipped == b.size_unzipped && a.message_body == b.message_body
}

[inline]
pub fn (a CMsgMulti) ne(b CMsgMulti) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgMulti) eq(b []CMsgMulti) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgMulti) ne(b []CMsgMulti) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgmulti() CMsgMulti {
	return CMsgMulti{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgmulti(o CMsgMulti, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgmulti(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMulti) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmulti_unpack(v)?
	return i, unpacked
}

pub struct CMsgProtobufWrapped {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	message_body   []byte
}

pub fn (o &CMsgProtobufWrapped) pack() []byte {
	mut res := []byte{}
	if o.message_body != []byte{} {
		res << vproto.pack_bytes_field(o.message_body, 1)
	}
	return res
}

pub fn cmsgprotobufwrapped_unpack(buf []byte) ?CMsgProtobufWrapped {
	mut res := zzz_vproto_internal_new_cmsgprotobufwrapped()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.message_body = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgProtobufWrapped) eq(b CMsgProtobufWrapped) bool {
	return true && a.message_body == b.message_body
}

[inline]
pub fn (a CMsgProtobufWrapped) ne(b CMsgProtobufWrapped) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgProtobufWrapped) eq(b []CMsgProtobufWrapped) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgProtobufWrapped) ne(b []CMsgProtobufWrapped) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgprotobufwrapped() CMsgProtobufWrapped {
	return CMsgProtobufWrapped{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgprotobufwrapped(o CMsgProtobufWrapped, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgprotobufwrapped(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgProtobufWrapped) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgprotobufwrapped_unpack(v)?
	return i, unpacked
}

pub struct CMsgAuthTicket {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	estate         u32
	eresult        u32 = 2
	steamid        u64
	gameid         u64
	h_steam_pipe   u32
	ticket_crc     u32
	ticket         []byte
}

pub fn (o &CMsgAuthTicket) pack() []byte {
	mut res := []byte{}
	if o.estate != u32(0) {
		res << vproto.pack_uint32_field(o.estate, 1)
	}
	if o.eresult != u32(0) {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 3)
	}
	if o.gameid != u64(0) {
		res << vproto.pack_64bit_field(o.gameid, 4)
	}
	if o.h_steam_pipe != u32(0) {
		res << vproto.pack_uint32_field(o.h_steam_pipe, 5)
	}
	if o.ticket_crc != u32(0) {
		res << vproto.pack_uint32_field(o.ticket_crc, 6)
	}
	if o.ticket != []byte{} {
		res << vproto.pack_bytes_field(o.ticket, 7)
	}
	return res
}

pub fn cmsgauthticket_unpack(buf []byte) ?CMsgAuthTicket {
	mut res := zzz_vproto_internal_new_cmsgauthticket()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.estate = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.h_steam_pipe = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket_crc = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgAuthTicket) eq(b CMsgAuthTicket) bool {
	return true && a.estate == b.estate &&
		a.eresult == b.eresult && a.steamid == b.steamid &&
		a.gameid == b.gameid && a.h_steam_pipe == b.h_steam_pipe &&
		a.ticket_crc == b.ticket_crc && a.ticket == b.ticket
}

[inline]
pub fn (a CMsgAuthTicket) ne(b CMsgAuthTicket) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgAuthTicket) eq(b []CMsgAuthTicket) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgAuthTicket) ne(b []CMsgAuthTicket) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgauthticket() CMsgAuthTicket {
	return CMsgAuthTicket{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgauthticket(o CMsgAuthTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgauthticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAuthTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgauthticket_unpack(v)?
	return i, unpacked
}

pub struct CCDDBAppDetailCommon {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	appid                   u32
	name                    string
	icon                    string
	logo                    string
	logo_small              string
	tool                    bool
	demo                    bool
	media                   bool
	community_visible_stats bool
	friendly_name           string
	propagation             string
	has_adult_content       bool
}

pub fn (o &CCDDBAppDetailCommon) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.icon != '' {
		res << vproto.pack_string_field(o.icon, 3)
	}
	if o.logo != '' {
		res << vproto.pack_string_field(o.logo, 4)
	}
	if o.logo_small != '' {
		res << vproto.pack_string_field(o.logo_small, 5)
	}
	if o.tool != bool(0) {
		res << vproto.pack_bool_field(o.tool, 6)
	}
	if o.demo != bool(0) {
		res << vproto.pack_bool_field(o.demo, 7)
	}
	if o.media != bool(0) {
		res << vproto.pack_bool_field(o.media, 8)
	}
	if o.community_visible_stats != bool(0) {
		res << vproto.pack_bool_field(o.community_visible_stats, 9)
	}
	if o.friendly_name != '' {
		res << vproto.pack_string_field(o.friendly_name, 10)
	}
	if o.propagation != '' {
		res << vproto.pack_string_field(o.propagation, 11)
	}
	if o.has_adult_content != bool(0) {
		res << vproto.pack_bool_field(o.has_adult_content, 12)
	}
	return res
}

pub fn ccddbappdetailcommon_unpack(buf []byte) ?CCDDBAppDetailCommon {
	mut res := zzz_vproto_internal_new_ccddbappdetailcommon()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.logo = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.logo_small = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.tool = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.demo = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.media = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.community_visible_stats = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.friendly_name = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.propagation = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.has_adult_content = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCDDBAppDetailCommon) eq(b CCDDBAppDetailCommon) bool {
	return true && a.appid == b.appid &&
		a.name == b.name && a.icon == b.icon &&
		a.logo == b.logo && a.logo_small == b.logo_small &&
		a.tool == b.tool && a.demo == b.demo &&
		a.media == b.media && a.community_visible_stats == b.community_visible_stats &&
		a.friendly_name == b.friendly_name &&
		a.propagation == b.propagation && a.has_adult_content == b.has_adult_content
}

[inline]
pub fn (a CCDDBAppDetailCommon) ne(b CCDDBAppDetailCommon) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCDDBAppDetailCommon) eq(b []CCDDBAppDetailCommon) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCDDBAppDetailCommon) ne(b []CCDDBAppDetailCommon) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccddbappdetailcommon() CCDDBAppDetailCommon {
	return CCDDBAppDetailCommon{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccddbappdetailcommon(o CCDDBAppDetailCommon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccddbappdetailcommon(buf []byte, tag_wiretype vproto.WireType) ?(int, CCDDBAppDetailCommon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccddbappdetailcommon_unpack(v)?
	return i, unpacked
}

pub struct CMsgAppRights {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	edit_info                  bool
	publish                    bool
	view_error_data            bool
	download                   bool
	upload_cdkeys              bool
	generate_cdkeys            bool
	view_financials            bool
	manage_ceg                 bool
	manage_signing             bool
	manage_cdkeys              bool
	edit_marketing             bool
	economy_support            bool
	economy_support_supervisor bool
	manage_pricing             bool
	broadcast_live             bool
	view_marketing_traffic     bool
}

pub fn (o &CMsgAppRights) pack() []byte {
	mut res := []byte{}
	if o.edit_info != bool(0) {
		res << vproto.pack_bool_field(o.edit_info, 1)
	}
	if o.publish != bool(0) {
		res << vproto.pack_bool_field(o.publish, 2)
	}
	if o.view_error_data != bool(0) {
		res << vproto.pack_bool_field(o.view_error_data, 3)
	}
	if o.download != bool(0) {
		res << vproto.pack_bool_field(o.download, 4)
	}
	if o.upload_cdkeys != bool(0) {
		res << vproto.pack_bool_field(o.upload_cdkeys, 5)
	}
	if o.generate_cdkeys != bool(0) {
		res << vproto.pack_bool_field(o.generate_cdkeys, 6)
	}
	if o.view_financials != bool(0) {
		res << vproto.pack_bool_field(o.view_financials, 7)
	}
	if o.manage_ceg != bool(0) {
		res << vproto.pack_bool_field(o.manage_ceg, 8)
	}
	if o.manage_signing != bool(0) {
		res << vproto.pack_bool_field(o.manage_signing, 9)
	}
	if o.manage_cdkeys != bool(0) {
		res << vproto.pack_bool_field(o.manage_cdkeys, 10)
	}
	if o.edit_marketing != bool(0) {
		res << vproto.pack_bool_field(o.edit_marketing, 11)
	}
	if o.economy_support != bool(0) {
		res << vproto.pack_bool_field(o.economy_support, 12)
	}
	if o.economy_support_supervisor != bool(0) {
		res << vproto.pack_bool_field(o.economy_support_supervisor, 13)
	}
	if o.manage_pricing != bool(0) {
		res << vproto.pack_bool_field(o.manage_pricing, 14)
	}
	if o.broadcast_live != bool(0) {
		res << vproto.pack_bool_field(o.broadcast_live, 15)
	}
	if o.view_marketing_traffic != bool(0) {
		res << vproto.pack_bool_field(o.view_marketing_traffic, 16)
	}
	return res
}

pub fn cmsgapprights_unpack(buf []byte) ?CMsgAppRights {
	mut res := zzz_vproto_internal_new_cmsgapprights()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.edit_info = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.publish = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.view_error_data = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.download = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_cdkeys = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.generate_cdkeys = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.view_financials = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_ceg = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_signing = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_cdkeys = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.edit_marketing = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.economy_support = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.economy_support_supervisor = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_pricing = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_live = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.view_marketing_traffic = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CMsgAppRights) eq(b CMsgAppRights) bool {
	return true && a.edit_info == b.edit_info &&
		a.publish == b.publish && a.view_error_data == b.view_error_data &&
		a.download == b.download && a.upload_cdkeys == b.upload_cdkeys &&
		a.generate_cdkeys == b.generate_cdkeys &&
		a.view_financials == b.view_financials &&
		a.manage_ceg == b.manage_ceg && a.manage_signing == b.manage_signing &&
		a.manage_cdkeys == b.manage_cdkeys &&
		a.edit_marketing == b.edit_marketing &&
		a.economy_support == b.economy_support &&
		a.economy_support_supervisor == b.economy_support_supervisor &&
		a.manage_pricing == b.manage_pricing &&
		a.broadcast_live == b.broadcast_live &&
		a.view_marketing_traffic == b.view_marketing_traffic
}

[inline]
pub fn (a CMsgAppRights) ne(b CMsgAppRights) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CMsgAppRights) eq(b []CMsgAppRights) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CMsgAppRights) ne(b []CMsgAppRights) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cmsgapprights() CMsgAppRights {
	return CMsgAppRights{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cmsgapprights(o CMsgAppRights, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cmsgapprights(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAppRights) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgapprights_unpack(v)?
	return i, unpacked
}

pub struct CCuratorPreferences {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	supported_languages    u32
	platform_windows       bool
	platform_mac           bool
	platform_linux         bool
	vr_content             bool
	adult_content_violence bool
	adult_content_sex      bool
	timestamp_updated      u32
	tagids_curated         []u32
	tagids_filtered        []u32
	website_title          string
	website_url            string
	discussion_url         string
	show_broadcast         bool
}

pub fn (o &CCuratorPreferences) pack() []byte {
	mut res := []byte{}
	if o.supported_languages != u32(0) {
		res << vproto.pack_uint32_field(o.supported_languages, 1)
	}
	if o.platform_windows != bool(0) {
		res << vproto.pack_bool_field(o.platform_windows, 2)
	}
	if o.platform_mac != bool(0) {
		res << vproto.pack_bool_field(o.platform_mac, 3)
	}
	if o.platform_linux != bool(0) {
		res << vproto.pack_bool_field(o.platform_linux, 4)
	}
	if o.vr_content != bool(0) {
		res << vproto.pack_bool_field(o.vr_content, 5)
	}
	if o.adult_content_violence != bool(0) {
		res << vproto.pack_bool_field(o.adult_content_violence, 6)
	}
	if o.adult_content_sex != bool(0) {
		res << vproto.pack_bool_field(o.adult_content_sex, 7)
	}
	if o.timestamp_updated != u32(0) {
		res << vproto.pack_uint32_field(o.timestamp_updated, 8)
	}
	// [packed=false]
	for _, x in o.tagids_curated {
		res << vproto.pack_uint32_field(x, 9)
	}
	// [packed=false]
	for _, x in o.tagids_filtered {
		res << vproto.pack_uint32_field(x, 10)
	}
	if o.website_title != '' {
		res << vproto.pack_string_field(o.website_title, 11)
	}
	if o.website_url != '' {
		res << vproto.pack_string_field(o.website_url, 12)
	}
	if o.discussion_url != '' {
		res << vproto.pack_string_field(o.discussion_url, 13)
	}
	if o.show_broadcast != bool(0) {
		res << vproto.pack_bool_field(o.show_broadcast, 14)
	}
	return res
}

pub fn ccuratorpreferences_unpack(buf []byte) ?CCuratorPreferences {
	mut res := zzz_vproto_internal_new_ccuratorpreferences()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.supported_languages = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_windows = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_mac = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_linux = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_content = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.adult_content_violence = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.adult_content_sex = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_updated = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagids_curated << v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagids_filtered << v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.website_title = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.website_url = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.discussion_url = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.show_broadcast = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCuratorPreferences) eq(b CCuratorPreferences) bool {
	return true && a.supported_languages == b.supported_languages &&
		a.platform_windows == b.platform_windows &&
		a.platform_mac == b.platform_mac &&
		a.platform_linux == b.platform_linux &&
		a.vr_content == b.vr_content && a.adult_content_violence == b.adult_content_violence &&
		a.adult_content_sex == b.adult_content_sex &&
		a.timestamp_updated == b.timestamp_updated &&
		a.tagids_curated == b.tagids_curated &&
		a.tagids_filtered == b.tagids_filtered &&
		a.website_title == b.website_title &&
		a.website_url == b.website_url && a.discussion_url == b.discussion_url &&
		a.show_broadcast == b.show_broadcast
}

[inline]
pub fn (a CCuratorPreferences) ne(b CCuratorPreferences) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCuratorPreferences) eq(b []CCuratorPreferences) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCuratorPreferences) ne(b []CCuratorPreferences) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccuratorpreferences() CCuratorPreferences {
	return CCuratorPreferences{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccuratorpreferences(o CCuratorPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccuratorpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CCuratorPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccuratorpreferences_unpack(v)?
	return i, unpacked
}

pub struct CLocalizationToken {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	language         u32
	localized_string string
}

pub fn (o &CLocalizationToken) pack() []byte {
	mut res := []byte{}
	if o.language != u32(0) {
		res << vproto.pack_uint32_field(o.language, 1)
	}
	if o.localized_string != '' {
		res << vproto.pack_string_field(o.localized_string, 2)
	}
	return res
}

pub fn clocalizationtoken_unpack(buf []byte) ?CLocalizationToken {
	mut res := zzz_vproto_internal_new_clocalizationtoken()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_string = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CLocalizationToken) eq(b CLocalizationToken) bool {
	return true && a.language == b.language && a.localized_string == b.localized_string
}

[inline]
pub fn (a CLocalizationToken) ne(b CLocalizationToken) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CLocalizationToken) eq(b []CLocalizationToken) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CLocalizationToken) ne(b []CLocalizationToken) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_clocalizationtoken() CLocalizationToken {
	return CLocalizationToken{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_clocalizationtoken(o CLocalizationToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_clocalizationtoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CLocalizationToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clocalizationtoken_unpack(v)?
	return i, unpacked
}

pub struct CClanEventUserNewsTuple {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	clanid                u32
	event_gid             u64
	announcement_gid      u64
	rtime_start           u32
	rtime_end             u32
	priority_score        u32
	@type                 u32
	clamp_range_slot      u32
	appid                 u32
	rtime32_last_modified u32
}

pub fn (o &CClanEventUserNewsTuple) pack() []byte {
	mut res := []byte{}
	if o.clanid != u32(0) {
		res << vproto.pack_uint32_field(o.clanid, 1)
	}
	if o.event_gid != u64(0) {
		res << vproto.pack_64bit_field(o.event_gid, 2)
	}
	if o.announcement_gid != u64(0) {
		res << vproto.pack_64bit_field(o.announcement_gid, 3)
	}
	if o.rtime_start != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_start, 4)
	}
	if o.rtime_end != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_end, 5)
	}
	if o.priority_score != u32(0) {
		res << vproto.pack_uint32_field(o.priority_score, 6)
	}
	if o.@type != u32(0) {
		res << vproto.pack_uint32_field(o.@type, 7)
	}
	if o.clamp_range_slot != u32(0) {
		res << vproto.pack_uint32_field(o.clamp_range_slot, 8)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 9)
	}
	if o.rtime32_last_modified != u32(0) {
		res << vproto.pack_uint32_field(o.rtime32_last_modified, 10)
	}
	return res
}

pub fn cclaneventusernewstuple_unpack(buf []byte) ?CClanEventUserNewsTuple {
	mut res := zzz_vproto_internal_new_cclaneventusernewstuple()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.event_gid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_gid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_start = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_end = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.priority_score = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clamp_range_slot = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_last_modified = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CClanEventUserNewsTuple) eq(b CClanEventUserNewsTuple) bool {
	return true && a.clanid == b.clanid &&
		a.event_gid == b.event_gid && a.announcement_gid == b.announcement_gid &&
		a.rtime_start == b.rtime_start && a.rtime_end == b.rtime_end &&
		a.priority_score == b.priority_score &&
		a.@type == b.@type && a.clamp_range_slot == b.clamp_range_slot &&
		a.appid == b.appid && a.rtime32_last_modified == b.rtime32_last_modified
}

[inline]
pub fn (a CClanEventUserNewsTuple) ne(b CClanEventUserNewsTuple) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CClanEventUserNewsTuple) eq(b []CClanEventUserNewsTuple) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CClanEventUserNewsTuple) ne(b []CClanEventUserNewsTuple) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cclaneventusernewstuple() CClanEventUserNewsTuple {
	return CClanEventUserNewsTuple{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cclaneventusernewstuple(o CClanEventUserNewsTuple, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cclaneventusernewstuple(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanEventUserNewsTuple) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclaneventusernewstuple_unpack(v)?
	return i, unpacked
}

pub struct CClanMatchEventByRange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	rtime_before   u32
	rtime_after    u32
	qualified      u32
	events         []CClanEventUserNewsTuple
}

pub fn (o &CClanMatchEventByRange) pack() []byte {
	mut res := []byte{}
	if o.rtime_before != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_before, 1)
	}
	if o.rtime_after != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_after, 2)
	}
	if o.qualified != u32(0) {
		res << vproto.pack_uint32_field(o.qualified, 3)
	}
	// [packed=false]
	for _, x in o.events {
		res << zzz_vproto_internal_pack_cclaneventusernewstuple(x, 4)
	}
	return res
}

pub fn cclanmatcheventbyrange_unpack(buf []byte) ?CClanMatchEventByRange {
	mut res := zzz_vproto_internal_new_cclanmatcheventbyrange()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_before = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_after = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.qualified = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cclaneventusernewstuple(cur_buf, tag_wiretype.wire_type)?
				res.events << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CClanMatchEventByRange) eq(b CClanMatchEventByRange) bool {
	return true && a.rtime_before == b.rtime_before &&
		a.rtime_after == b.rtime_after && a.qualified == b.qualified && a.events.eq(b.events)
}

[inline]
pub fn (a CClanMatchEventByRange) ne(b CClanMatchEventByRange) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CClanMatchEventByRange) eq(b []CClanMatchEventByRange) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CClanMatchEventByRange) ne(b []CClanMatchEventByRange) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cclanmatcheventbyrange() CClanMatchEventByRange {
	return CClanMatchEventByRange{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cclanmatcheventbyrange(o CClanMatchEventByRange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cclanmatcheventbyrange(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanMatchEventByRange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanmatcheventbyrange_unpack(v)?
	return i, unpacked
}

pub struct CCommunity_ClanAnnouncementInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	gid            u64
	clanid         u64
	posterid       u64
	headline       string
	posttime       u32
	updatetime     u32
	body           string
	commentcount   int
	tags           []string
	language       int
	hidden         bool
	forum_topic_id u64
	event_gid      u64
	voteupcount    int
	votedowncount  int
}

pub fn (o &CCommunity_ClanAnnouncementInfo) pack() []byte {
	mut res := []byte{}
	if o.gid != u64(0) {
		res << vproto.pack_uint64_field(o.gid, 1)
	}
	if o.clanid != u64(0) {
		res << vproto.pack_uint64_field(o.clanid, 2)
	}
	if o.posterid != u64(0) {
		res << vproto.pack_uint64_field(o.posterid, 3)
	}
	if o.headline != '' {
		res << vproto.pack_string_field(o.headline, 4)
	}
	if o.posttime != u32(0) {
		res << vproto.pack_uint32_field(o.posttime, 5)
	}
	if o.updatetime != u32(0) {
		res << vproto.pack_uint32_field(o.updatetime, 6)
	}
	if o.body != '' {
		res << vproto.pack_string_field(o.body, 7)
	}
	if o.commentcount != int(0) {
		res << vproto.pack_int32_field(o.commentcount, 8)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 9)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 10)
	}
	if o.hidden != bool(0) {
		res << vproto.pack_bool_field(o.hidden, 11)
	}
	if o.forum_topic_id != u64(0) {
		res << vproto.pack_64bit_field(o.forum_topic_id, 12)
	}
	if o.event_gid != u64(0) {
		res << vproto.pack_64bit_field(o.event_gid, 13)
	}
	if o.voteupcount != int(0) {
		res << vproto.pack_int32_field(o.voteupcount, 14)
	}
	if o.votedowncount != int(0) {
		res << vproto.pack_int32_field(o.votedowncount, 15)
	}
	return res
}

pub fn ccommunity_clanannouncementinfo_unpack(buf []byte) ?CCommunity_ClanAnnouncementInfo {
	mut res := zzz_vproto_internal_new_ccommunity_clanannouncementinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.posterid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.headline = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.posttime = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.updatetime = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.body = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.commentcount = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.forum_topic_id = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.event_gid = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.voteupcount = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.votedowncount = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CCommunity_ClanAnnouncementInfo) eq(b CCommunity_ClanAnnouncementInfo) bool {
	return true && a.gid == b.gid &&
		a.clanid == b.clanid && a.posterid == b.posterid &&
		a.headline == b.headline && a.posttime == b.posttime &&
		a.updatetime == b.updatetime && a.body == b.body &&
		a.commentcount == b.commentcount &&
		a.tags == b.tags && a.language == b.language &&
		a.hidden == b.hidden && a.forum_topic_id == b.forum_topic_id &&
		a.event_gid == b.event_gid && a.voteupcount == b.voteupcount &&
		a.votedowncount == b.votedowncount
}

[inline]
pub fn (a CCommunity_ClanAnnouncementInfo) ne(b CCommunity_ClanAnnouncementInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CCommunity_ClanAnnouncementInfo) eq(b []CCommunity_ClanAnnouncementInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CCommunity_ClanAnnouncementInfo) ne(b []CCommunity_ClanAnnouncementInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccommunity_clanannouncementinfo() CCommunity_ClanAnnouncementInfo {
	return CCommunity_ClanAnnouncementInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccommunity_clanannouncementinfo(o CCommunity_ClanAnnouncementInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccommunity_clanannouncementinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunity_ClanAnnouncementInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunity_clanannouncementinfo_unpack(v)?
	return i, unpacked
}

pub struct CClanEventData {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	gid                      u64
	clan_steamid             u64
	event_name               string
	event_type               EProtoClanEventType = .k_eclanotherevent
	appid                    u32
	server_address           string
	server_password          string
	rtime32_start_time       u32
	rtime32_end_time         u32
	comment_count            int
	creator_steamid          u64
	last_update_steamid      u64
	event_notes              string
	jsondata                 string
	announcement_body        CCommunity_ClanAnnouncementInfo
	published                bool
	hidden                   bool
	rtime32_visibility_start u32
	rtime32_visibility_end   u32
	broadcaster_accountid    u32
	follower_count           u32
	ignore_count             u32
	forum_topic_id           u64
	rtime32_last_modified    u32
	news_post_gid            u64
	rtime_mod_reviewed       u32
}

pub fn (o &CClanEventData) pack() []byte {
	mut res := []byte{}
	if o.gid != u64(0) {
		res << vproto.pack_64bit_field(o.gid, 1)
	}
	if o.clan_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.clan_steamid, 2)
	}
	if o.event_name != '' {
		res << vproto.pack_string_field(o.event_name, 3)
	}
	if o.event_type != zzz_vproto_internal_new_eprotoclaneventtype() {
		res << zzz_vproto_internal_pack_eprotoclaneventtype(o.event_type, 4)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	if o.server_address != '' {
		res << vproto.pack_string_field(o.server_address, 6)
	}
	if o.server_password != '' {
		res << vproto.pack_string_field(o.server_password, 7)
	}
	if o.rtime32_start_time != u32(0) {
		res << vproto.pack_uint32_field(o.rtime32_start_time, 8)
	}
	if o.rtime32_end_time != u32(0) {
		res << vproto.pack_uint32_field(o.rtime32_end_time, 9)
	}
	if o.comment_count != int(0) {
		res << vproto.pack_int32_field(o.comment_count, 10)
	}
	if o.creator_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.creator_steamid, 11)
	}
	if o.last_update_steamid != u64(0) {
		res << vproto.pack_64bit_field(o.last_update_steamid, 12)
	}
	if o.event_notes != '' {
		res << vproto.pack_string_field(o.event_notes, 13)
	}
	if o.jsondata != '' {
		res << vproto.pack_string_field(o.jsondata, 14)
	}
	if o.announcement_body.ne(zzz_vproto_internal_new_ccommunity_clanannouncementinfo()) {
		res << zzz_vproto_internal_pack_ccommunity_clanannouncementinfo(o.announcement_body, 15)
	}
	if o.published != bool(0) {
		res << vproto.pack_bool_field(o.published, 16)
	}
	if o.hidden != bool(0) {
		res << vproto.pack_bool_field(o.hidden, 17)
	}
	if o.rtime32_visibility_start != u32(0) {
		res << vproto.pack_uint32_field(o.rtime32_visibility_start, 18)
	}
	if o.rtime32_visibility_end != u32(0) {
		res << vproto.pack_uint32_field(o.rtime32_visibility_end, 19)
	}
	if o.broadcaster_accountid != u32(0) {
		res << vproto.pack_uint32_field(o.broadcaster_accountid, 20)
	}
	if o.follower_count != u32(0) {
		res << vproto.pack_uint32_field(o.follower_count, 21)
	}
	if o.ignore_count != u32(0) {
		res << vproto.pack_uint32_field(o.ignore_count, 22)
	}
	if o.forum_topic_id != u64(0) {
		res << vproto.pack_64bit_field(o.forum_topic_id, 23)
	}
	if o.rtime32_last_modified != u32(0) {
		res << vproto.pack_uint32_field(o.rtime32_last_modified, 24)
	}
	if o.news_post_gid != u64(0) {
		res << vproto.pack_64bit_field(o.news_post_gid, 25)
	}
	if o.rtime_mod_reviewed != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_mod_reviewed, 26)
	}
	return res
}

pub fn cclaneventdata_unpack(buf []byte) ?CClanEventData {
	mut res := zzz_vproto_internal_new_cclaneventdata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.clan_steamid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.event_name = v
				i = ii
			}
			4 {
				ii, v := zzz_vproto_internal_unpack_eprotoclaneventtype(cur_buf, tag_wiretype.wire_type)?
				res.event_type = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_address = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_password = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_start_time = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_end_time = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.comment_count = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_steamid = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.last_update_steamid = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.event_notes = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.jsondata = v
				i = ii
			}
			15 {
				ii, v := zzz_vproto_internal_unpack_ccommunity_clanannouncementinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.announcement_body = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.published = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_visibility_start = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_visibility_end = v
				i = ii
			}
			20 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_accountid = v
				i = ii
			}
			21 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.follower_count = v
				i = ii
			}
			22 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ignore_count = v
				i = ii
			}
			23 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.forum_topic_id = v
				i = ii
			}
			24 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_last_modified = v
				i = ii
			}
			25 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.news_post_gid = v
				i = ii
			}
			26 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_mod_reviewed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CClanEventData) eq(b CClanEventData) bool {
	return true && a.gid == b.gid &&
		a.clan_steamid == b.clan_steamid &&
		a.event_name == b.event_name && a.event_type == b.event_type &&
		a.appid == b.appid && a.server_address == b.server_address &&
		a.server_password == b.server_password &&
		a.rtime32_start_time == b.rtime32_start_time &&
		a.rtime32_end_time == b.rtime32_end_time &&
		a.comment_count == b.comment_count &&
		a.creator_steamid == b.creator_steamid &&
		a.last_update_steamid == b.last_update_steamid &&
		a.event_notes == b.event_notes &&
		a.jsondata == b.jsondata && a.announcement_body.eq(b.announcement_body) &&
		a.published == b.published && a.hidden == b.hidden &&
		a.rtime32_visibility_start == b.rtime32_visibility_start &&
		a.rtime32_visibility_end == b.rtime32_visibility_end &&
		a.broadcaster_accountid == b.broadcaster_accountid &&
		a.follower_count == b.follower_count &&
		a.ignore_count == b.ignore_count &&
		a.forum_topic_id == b.forum_topic_id &&
		a.rtime32_last_modified == b.rtime32_last_modified &&
		a.news_post_gid == b.news_post_gid &&
		a.rtime_mod_reviewed == b.rtime_mod_reviewed
}

[inline]
pub fn (a CClanEventData) ne(b CClanEventData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CClanEventData) eq(b []CClanEventData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CClanEventData) ne(b []CClanEventData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cclaneventdata() CClanEventData {
	return CClanEventData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cclaneventdata(o CClanEventData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cclaneventdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanEventData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclaneventdata_unpack(v)?
	return i, unpacked
}

pub struct CBilling_Address {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	first_name     string
	last_name      string
	address1       string
	address2       string
	city           string
	us_state       string
	country_code   string
	postcode       string
	zip_plus4      int
	phone          string
}

pub fn (o &CBilling_Address) pack() []byte {
	mut res := []byte{}
	if o.first_name != '' {
		res << vproto.pack_string_field(o.first_name, 1)
	}
	if o.last_name != '' {
		res << vproto.pack_string_field(o.last_name, 2)
	}
	if o.address1 != '' {
		res << vproto.pack_string_field(o.address1, 3)
	}
	if o.address2 != '' {
		res << vproto.pack_string_field(o.address2, 4)
	}
	if o.city != '' {
		res << vproto.pack_string_field(o.city, 5)
	}
	if o.us_state != '' {
		res << vproto.pack_string_field(o.us_state, 6)
	}
	if o.country_code != '' {
		res << vproto.pack_string_field(o.country_code, 7)
	}
	if o.postcode != '' {
		res << vproto.pack_string_field(o.postcode, 8)
	}
	if o.zip_plus4 != int(0) {
		res << vproto.pack_int32_field(o.zip_plus4, 9)
	}
	if o.phone != '' {
		res << vproto.pack_string_field(o.phone, 10)
	}
	return res
}

pub fn cbilling_address_unpack(buf []byte) ?CBilling_Address {
	mut res := zzz_vproto_internal_new_cbilling_address()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.first_name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.last_name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.address1 = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.address2 = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.city = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.us_state = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.postcode = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.zip_plus4 = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.phone = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CBilling_Address) eq(b CBilling_Address) bool {
	return true && a.first_name == b.first_name &&
		a.last_name == b.last_name && a.address1 == b.address1 &&
		a.address2 == b.address2 && a.city == b.city &&
		a.us_state == b.us_state && a.country_code == b.country_code &&
		a.postcode == b.postcode && a.zip_plus4 == b.zip_plus4 &&
		a.phone == b.phone
}

[inline]
pub fn (a CBilling_Address) ne(b CBilling_Address) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CBilling_Address) eq(b []CBilling_Address) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CBilling_Address) ne(b []CBilling_Address) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cbilling_address() CBilling_Address {
	return CBilling_Address{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cbilling_address(o CBilling_Address, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cbilling_address(buf []byte, tag_wiretype vproto.WireType) ?(int, CBilling_Address) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbilling_address_unpack(v)?
	return i, unpacked
}
