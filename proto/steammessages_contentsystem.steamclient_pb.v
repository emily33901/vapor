// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CContentServerDirectory_GetServersForSteamPipe_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cell_id        u32
	max_servers    u32 = 20
	ip_override    string
	launcher_type  int = 0
}

pub fn (o &CContentServerDirectory_GetServersForSteamPipe_Request) pack() []byte {
	mut res := []byte{}
	if o.cell_id != u32(0) {
		res << vproto.pack_uint32_field(o.cell_id, 1)
	}
	if o.max_servers != u32(0) {
		res << vproto.pack_uint32_field(o.max_servers, 2)
	}
	if o.ip_override != '' {
		res << vproto.pack_string_field(o.ip_override, 3)
	}
	if o.launcher_type != int(0) {
		res << vproto.pack_int32_field(o.launcher_type, 4)
	}
	return res
}

pub fn ccontentserverdirectory_getserversforsteampipe_request_unpack(buf []byte) ?CContentServerDirectory_GetServersForSteamPipe_Request {
	mut res := zzz_vproto_internal_new_ccontentserverdirectory_getserversforsteampipe_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_servers = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_override = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.launcher_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CContentServerDirectory_GetServersForSteamPipe_Request) eq(b CContentServerDirectory_GetServersForSteamPipe_Request) bool {
	return true && a.cell_id == b.cell_id &&
		a.max_servers == b.max_servers && a.ip_override == b.ip_override &&
		a.launcher_type == b.launcher_type
}

[inline]
pub fn (a CContentServerDirectory_GetServersForSteamPipe_Request) ne(b CContentServerDirectory_GetServersForSteamPipe_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CContentServerDirectory_GetServersForSteamPipe_Request) eq(b []CContentServerDirectory_GetServersForSteamPipe_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CContentServerDirectory_GetServersForSteamPipe_Request) ne(b []CContentServerDirectory_GetServersForSteamPipe_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccontentserverdirectory_getserversforsteampipe_request() CContentServerDirectory_GetServersForSteamPipe_Request {
	return CContentServerDirectory_GetServersForSteamPipe_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccontentserverdirectory_getserversforsteampipe_request(o CContentServerDirectory_GetServersForSteamPipe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccontentserverdirectory_getserversforsteampipe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectory_GetServersForSteamPipe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectory_getserversforsteampipe_request_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectory_ServerInfo {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	@type                       string
	source_id                   int
	cell_id                     int
	load                        int
	weighted_load               f32
	num_entries_in_client_list  int
	steam_china_only            bool
	host                        string
	vhost                       string
	use_as_proxy                bool
	proxy_request_path_template string
	https_support               string
	allowed_app_ids             []u32
	preferred_server            bool
}

pub fn (o &CContentServerDirectory_ServerInfo) pack() []byte {
	mut res := []byte{}
	if o.@type != '' {
		res << vproto.pack_string_field(o.@type, 1)
	}
	if o.source_id != int(0) {
		res << vproto.pack_int32_field(o.source_id, 2)
	}
	if o.cell_id != int(0) {
		res << vproto.pack_int32_field(o.cell_id, 3)
	}
	if o.load != int(0) {
		res << vproto.pack_int32_field(o.load, 4)
	}
	if o.weighted_load != f32(0) {
		res << vproto.pack_float_field(o.weighted_load, 5)
	}
	if o.num_entries_in_client_list != int(0) {
		res << vproto.pack_int32_field(o.num_entries_in_client_list, 6)
	}
	if o.steam_china_only != bool(0) {
		res << vproto.pack_bool_field(o.steam_china_only, 7)
	}
	if o.host != '' {
		res << vproto.pack_string_field(o.host, 8)
	}
	if o.vhost != '' {
		res << vproto.pack_string_field(o.vhost, 9)
	}
	if o.use_as_proxy != bool(0) {
		res << vproto.pack_bool_field(o.use_as_proxy, 10)
	}
	if o.proxy_request_path_template != '' {
		res << vproto.pack_string_field(o.proxy_request_path_template, 11)
	}
	if o.https_support != '' {
		res << vproto.pack_string_field(o.https_support, 12)
	}
	// [packed=false]
	for _, x in o.allowed_app_ids {
		res << vproto.pack_uint32_field(x, 13)
	}
	if o.preferred_server != bool(0) {
		res << vproto.pack_bool_field(o.preferred_server, 14)
	}
	return res
}

pub fn ccontentserverdirectory_serverinfo_unpack(buf []byte) ?CContentServerDirectory_ServerInfo {
	mut res := zzz_vproto_internal_new_ccontentserverdirectory_serverinfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.source_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.load = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.weighted_load = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_entries_in_client_list = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_china_only = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vhost = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_as_proxy = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.proxy_request_path_template = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.https_support = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.allowed_app_ids << v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.preferred_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CContentServerDirectory_ServerInfo) eq(b CContentServerDirectory_ServerInfo) bool {
	return true && a.@type == b.@type &&
		a.source_id == b.source_id && a.cell_id == b.cell_id &&
		a.load == b.load && a.weighted_load == b.weighted_load &&
		a.num_entries_in_client_list == b.num_entries_in_client_list &&
		a.steam_china_only == b.steam_china_only &&
		a.host == b.host && a.vhost == b.vhost &&
		a.use_as_proxy == b.use_as_proxy &&
		a.proxy_request_path_template == b.proxy_request_path_template &&
		a.https_support == b.https_support &&
		a.allowed_app_ids == b.allowed_app_ids &&
		a.preferred_server == b.preferred_server
}

[inline]
pub fn (a CContentServerDirectory_ServerInfo) ne(b CContentServerDirectory_ServerInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CContentServerDirectory_ServerInfo) eq(b []CContentServerDirectory_ServerInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CContentServerDirectory_ServerInfo) ne(b []CContentServerDirectory_ServerInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccontentserverdirectory_serverinfo() CContentServerDirectory_ServerInfo {
	return CContentServerDirectory_ServerInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccontentserverdirectory_serverinfo(o CContentServerDirectory_ServerInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccontentserverdirectory_serverinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectory_ServerInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectory_serverinfo_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectory_GetServersForSteamPipe_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	servers        []CContentServerDirectory_ServerInfo
}

pub fn (o &CContentServerDirectory_GetServersForSteamPipe_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_ccontentserverdirectory_serverinfo(x, 1)
	}
	return res
}

pub fn ccontentserverdirectory_getserversforsteampipe_response_unpack(buf []byte) ?CContentServerDirectory_GetServersForSteamPipe_Response {
	mut res := zzz_vproto_internal_new_ccontentserverdirectory_getserversforsteampipe_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccontentserverdirectory_serverinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CContentServerDirectory_GetServersForSteamPipe_Response) eq(b CContentServerDirectory_GetServersForSteamPipe_Response) bool {
	return true && a.servers.eq(b.servers)
}

[inline]
pub fn (a CContentServerDirectory_GetServersForSteamPipe_Response) ne(b CContentServerDirectory_GetServersForSteamPipe_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CContentServerDirectory_GetServersForSteamPipe_Response) eq(b []CContentServerDirectory_GetServersForSteamPipe_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CContentServerDirectory_GetServersForSteamPipe_Response) ne(b []CContentServerDirectory_GetServersForSteamPipe_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccontentserverdirectory_getserversforsteampipe_response() CContentServerDirectory_GetServersForSteamPipe_Response {
	return CContentServerDirectory_GetServersForSteamPipe_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccontentserverdirectory_getserversforsteampipe_response(o CContentServerDirectory_GetServersForSteamPipe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccontentserverdirectory_getserversforsteampipe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectory_GetServersForSteamPipe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectory_getserversforsteampipe_response_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectory_GetDepotPatchInfo_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appid             u32
	depotid           u32
	source_manifestid u64
	target_manifestid u64
}

pub fn (o &CContentServerDirectory_GetDepotPatchInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.depotid != u32(0) {
		res << vproto.pack_uint32_field(o.depotid, 2)
	}
	if o.source_manifestid != u64(0) {
		res << vproto.pack_uint64_field(o.source_manifestid, 3)
	}
	if o.target_manifestid != u64(0) {
		res << vproto.pack_uint64_field(o.target_manifestid, 4)
	}
	return res
}

pub fn ccontentserverdirectory_getdepotpatchinfo_request_unpack(buf []byte) ?CContentServerDirectory_GetDepotPatchInfo_Request {
	mut res := zzz_vproto_internal_new_ccontentserverdirectory_getdepotpatchinfo_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.source_manifestid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.target_manifestid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CContentServerDirectory_GetDepotPatchInfo_Request) eq(b CContentServerDirectory_GetDepotPatchInfo_Request) bool {
	return true && a.appid == b.appid &&
		a.depotid == b.depotid && a.source_manifestid == b.source_manifestid &&
		a.target_manifestid == b.target_manifestid
}

[inline]
pub fn (a CContentServerDirectory_GetDepotPatchInfo_Request) ne(b CContentServerDirectory_GetDepotPatchInfo_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CContentServerDirectory_GetDepotPatchInfo_Request) eq(b []CContentServerDirectory_GetDepotPatchInfo_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CContentServerDirectory_GetDepotPatchInfo_Request) ne(b []CContentServerDirectory_GetDepotPatchInfo_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccontentserverdirectory_getdepotpatchinfo_request() CContentServerDirectory_GetDepotPatchInfo_Request {
	return CContentServerDirectory_GetDepotPatchInfo_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccontentserverdirectory_getdepotpatchinfo_request(o CContentServerDirectory_GetDepotPatchInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccontentserverdirectory_getdepotpatchinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectory_GetDepotPatchInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectory_getdepotpatchinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectory_GetDepotPatchInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	is_available   bool
}

pub fn (o &CContentServerDirectory_GetDepotPatchInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.is_available != bool(0) {
		res << vproto.pack_bool_field(o.is_available, 1)
	}
	return res
}

pub fn ccontentserverdirectory_getdepotpatchinfo_response_unpack(buf []byte) ?CContentServerDirectory_GetDepotPatchInfo_Response {
	mut res := zzz_vproto_internal_new_ccontentserverdirectory_getdepotpatchinfo_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_available = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CContentServerDirectory_GetDepotPatchInfo_Response) eq(b CContentServerDirectory_GetDepotPatchInfo_Response) bool {
	return true && a.is_available == b.is_available
}

[inline]
pub fn (a CContentServerDirectory_GetDepotPatchInfo_Response) ne(b CContentServerDirectory_GetDepotPatchInfo_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CContentServerDirectory_GetDepotPatchInfo_Response) eq(b []CContentServerDirectory_GetDepotPatchInfo_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CContentServerDirectory_GetDepotPatchInfo_Response) ne(b []CContentServerDirectory_GetDepotPatchInfo_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_ccontentserverdirectory_getdepotpatchinfo_response() CContentServerDirectory_GetDepotPatchInfo_Response {
	return CContentServerDirectory_GetDepotPatchInfo_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_ccontentserverdirectory_getdepotpatchinfo_response(o CContentServerDirectory_GetDepotPatchInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_ccontentserverdirectory_getdepotpatchinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectory_GetDepotPatchInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectory_getdepotpatchinfo_response_unpack(v)?
	return i, unpacked
}
