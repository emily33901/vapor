// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CDataPublisher_ClientContentCorruptionReport_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	depotid               u32
	has_depotid           bool
	download_source       string
	has_download_source   bool
	objectid              string
	has_objectid          bool
	cellid                u32
	has_cellid            bool
	is_manifest           bool
	has_is_manifest       bool
	object_size           u64
	has_object_size       bool
	corruption_type       u32
	has_corruption_type   bool
	used_https            bool
	has_used_https        bool
	oc_proxy_detected     bool
	has_oc_proxy_detected bool
}

pub fn (o &CDataPublisher_ClientContentCorruptionReport_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depotid {
		res << vproto.pack_uint32_field(o.depotid, 2)
	}
	if o.has_download_source {
		res << vproto.pack_string_field(o.download_source, 3)
	}
	if o.has_objectid {
		res << vproto.pack_string_field(o.objectid, 4)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 5)
	}
	if o.has_is_manifest {
		res << vproto.pack_bool_field(o.is_manifest, 6)
	}
	if o.has_object_size {
		res << vproto.pack_uint64_field(o.object_size, 7)
	}
	if o.has_corruption_type {
		res << vproto.pack_uint32_field(o.corruption_type, 8)
	}
	if o.has_used_https {
		res << vproto.pack_bool_field(o.used_https, 9)
	}
	if o.has_oc_proxy_detected {
		res << vproto.pack_bool_field(o.oc_proxy_detected, 10)
	}
	return res
}

pub fn cdatapublisher_clientcontentcorruptionreport_notification_unpack(buf []byte) ?CDataPublisher_ClientContentCorruptionReport_Notification {
	mut res := CDataPublisher_ClientContentCorruptionReport_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			3 {
				res.has_download_source = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.download_source = v
				i = ii
			}
			4 {
				res.has_objectid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.objectid = v
				i = ii
			}
			5 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			6 {
				res.has_is_manifest = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_manifest = v
				i = ii
			}
			7 {
				res.has_object_size = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.object_size = v
				i = ii
			}
			8 {
				res.has_corruption_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.corruption_type = v
				i = ii
			}
			9 {
				res.has_used_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.used_https = v
				i = ii
			}
			10 {
				res.has_oc_proxy_detected = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.oc_proxy_detected = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdatapublisher_clientcontentcorruptionreport_notification() CDataPublisher_ClientContentCorruptionReport_Notification {
	return CDataPublisher_ClientContentCorruptionReport_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdatapublisher_clientcontentcorruptionreport_notification(o CDataPublisher_ClientContentCorruptionReport_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdatapublisher_clientcontentcorruptionreport_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CDataPublisher_ClientContentCorruptionReport_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdatapublisher_clientcontentcorruptionreport_notification_unpack(v)?
	return i, unpacked
}

pub struct CValveHWSurvey_GetSurveySchedule_Request {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	surveydatetoken            string
	has_surveydatetoken        bool
	surveydatetokenversion     u64
	has_surveydatetokenversion bool
}

pub fn (o &CValveHWSurvey_GetSurveySchedule_Request) pack() []byte {
	mut res := []byte{}
	if o.has_surveydatetoken {
		res << vproto.pack_string_field(o.surveydatetoken, 1)
	}
	if o.has_surveydatetokenversion {
		res << vproto.pack_64bit_field(o.surveydatetokenversion, 2)
	}
	return res
}

pub fn cvalvehwsurvey_getsurveyschedule_request_unpack(buf []byte) ?CValveHWSurvey_GetSurveySchedule_Request {
	mut res := CValveHWSurvey_GetSurveySchedule_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_surveydatetoken = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.surveydatetoken = v
				i = ii
			}
			2 {
				res.has_surveydatetokenversion = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.surveydatetokenversion = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvalvehwsurvey_getsurveyschedule_request() CValveHWSurvey_GetSurveySchedule_Request {
	return CValveHWSurvey_GetSurveySchedule_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvalvehwsurvey_getsurveyschedule_request(o CValveHWSurvey_GetSurveySchedule_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvalvehwsurvey_getsurveyschedule_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CValveHWSurvey_GetSurveySchedule_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvalvehwsurvey_getsurveyschedule_request_unpack(v)?
	return i, unpacked
}

pub struct CValveHWSurvey_GetSurveySchedule_Response {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	surveydatetoken            u32
	has_surveydatetoken        bool
	surveydatetokenversion     u64
	has_surveydatetokenversion bool
}

pub fn (o &CValveHWSurvey_GetSurveySchedule_Response) pack() []byte {
	mut res := []byte{}
	if o.has_surveydatetoken {
		res << vproto.pack_uint32_field(o.surveydatetoken, 1)
	}
	if o.has_surveydatetokenversion {
		res << vproto.pack_64bit_field(o.surveydatetokenversion, 2)
	}
	return res
}

pub fn cvalvehwsurvey_getsurveyschedule_response_unpack(buf []byte) ?CValveHWSurvey_GetSurveySchedule_Response {
	mut res := CValveHWSurvey_GetSurveySchedule_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_surveydatetoken = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.surveydatetoken = v
				i = ii
			}
			2 {
				res.has_surveydatetokenversion = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.surveydatetokenversion = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvalvehwsurvey_getsurveyschedule_response() CValveHWSurvey_GetSurveySchedule_Response {
	return CValveHWSurvey_GetSurveySchedule_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvalvehwsurvey_getsurveyschedule_response(o CValveHWSurvey_GetSurveySchedule_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvalvehwsurvey_getsurveyschedule_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CValveHWSurvey_GetSurveySchedule_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvalvehwsurvey_getsurveyschedule_response_unpack(v)?
	return i, unpacked
}
