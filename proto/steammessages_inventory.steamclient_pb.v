// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CInventory_GetInventory_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	steamid        u64
}

pub fn (o &CInventory_GetInventory_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	return res
}

pub fn cinventory_getinventory_request_unpack(buf []byte) ?CInventory_GetInventory_Request {
	mut res := zzz_vproto_internal_new_cinventory_getinventory_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_GetInventory_Request) eq(b CInventory_GetInventory_Request) bool {
	return true && a.appid == b.appid && a.steamid == b.steamid
}

[inline]
pub fn (a CInventory_GetInventory_Request) ne(b CInventory_GetInventory_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetInventory_Request) eq(b []CInventory_GetInventory_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetInventory_Request) ne(b []CInventory_GetInventory_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_getinventory_request() CInventory_GetInventory_Request {
	return CInventory_GetInventory_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_getinventory_request(o CInventory_GetInventory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_getinventory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetInventory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getinventory_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	etag           string
	removeditemids []u64
	item_json      string
	itemdef_json   string
	ticket         []byte
	replayed       bool
}

pub fn (o &CInventory_Response) pack() []byte {
	mut res := []byte{}
	if o.etag != '' {
		res << vproto.pack_string_field(o.etag, 1)
	}
	// [packed=false]
	for _, x in o.removeditemids {
		res << vproto.pack_uint64_field(x, 2)
	}
	if o.item_json != '' {
		res << vproto.pack_string_field(o.item_json, 3)
	}
	if o.itemdef_json != '' {
		res << vproto.pack_string_field(o.itemdef_json, 4)
	}
	if o.ticket != []byte{} {
		res << vproto.pack_bytes_field(o.ticket, 5)
	}
	if o.replayed != bool(0) {
		res << vproto.pack_bool_field(o.replayed, 6)
	}
	return res
}

pub fn cinventory_response_unpack(buf []byte) ?CInventory_Response {
	mut res := zzz_vproto_internal_new_cinventory_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.etag = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.removeditemids << v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.item_json = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdef_json = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.replayed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_Response) eq(b CInventory_Response) bool {
	return true && a.etag == b.etag &&
		a.removeditemids == b.removeditemids &&
		a.item_json == b.item_json && a.itemdef_json == b.itemdef_json &&
		a.ticket == b.ticket && a.replayed == b.replayed
}

[inline]
pub fn (a CInventory_Response) ne(b CInventory_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_Response) eq(b []CInventory_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_Response) ne(b []CInventory_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_response() CInventory_Response {
	return CInventory_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_response(o CInventory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ExchangeItem_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appid             u32
	steamid           u64
	materialsitemid   []u64
	materialsquantity []u32
	outputitemdefid   u64
}

pub fn (o &CInventory_ExchangeItem_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	// [packed=false]
	for _, x in o.materialsitemid {
		res << vproto.pack_uint64_field(x, 3)
	}
	// [packed=false]
	for _, x in o.materialsquantity {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.outputitemdefid != u64(0) {
		res << vproto.pack_uint64_field(o.outputitemdefid, 5)
	}
	return res
}

pub fn cinventory_exchangeitem_request_unpack(buf []byte) ?CInventory_ExchangeItem_Request {
	mut res := zzz_vproto_internal_new_cinventory_exchangeitem_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.materialsitemid << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.materialsquantity << v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.outputitemdefid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_ExchangeItem_Request) eq(b CInventory_ExchangeItem_Request) bool {
	return true && a.appid == b.appid &&
		a.steamid == b.steamid && a.materialsitemid == b.materialsitemid &&
		a.materialsquantity == b.materialsquantity &&
		a.outputitemdefid == b.outputitemdefid
}

[inline]
pub fn (a CInventory_ExchangeItem_Request) ne(b CInventory_ExchangeItem_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_ExchangeItem_Request) eq(b []CInventory_ExchangeItem_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_ExchangeItem_Request) ne(b []CInventory_ExchangeItem_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_exchangeitem_request() CInventory_ExchangeItem_Request {
	return CInventory_ExchangeItem_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_exchangeitem_request(o CInventory_ExchangeItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_exchangeitem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ExchangeItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_exchangeitem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetEligiblePromoItemDefIDs_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	steamid        u64
}

pub fn (o &CInventory_GetEligiblePromoItemDefIDs_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	return res
}

pub fn cinventory_geteligiblepromoitemdefids_request_unpack(buf []byte) ?CInventory_GetEligiblePromoItemDefIDs_Request {
	mut res := zzz_vproto_internal_new_cinventory_geteligiblepromoitemdefids_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_GetEligiblePromoItemDefIDs_Request) eq(b CInventory_GetEligiblePromoItemDefIDs_Request) bool {
	return true && a.appid == b.appid && a.steamid == b.steamid
}

[inline]
pub fn (a CInventory_GetEligiblePromoItemDefIDs_Request) ne(b CInventory_GetEligiblePromoItemDefIDs_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetEligiblePromoItemDefIDs_Request) eq(b []CInventory_GetEligiblePromoItemDefIDs_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetEligiblePromoItemDefIDs_Request) ne(b []CInventory_GetEligiblePromoItemDefIDs_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_geteligiblepromoitemdefids_request() CInventory_GetEligiblePromoItemDefIDs_Request {
	return CInventory_GetEligiblePromoItemDefIDs_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_geteligiblepromoitemdefids_request(o CInventory_GetEligiblePromoItemDefIDs_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_geteligiblepromoitemdefids_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetEligiblePromoItemDefIDs_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_geteligiblepromoitemdefids_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetEligiblePromoItemDefIDs_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	itemdefids     []u64
}

pub fn (o &CInventory_GetEligiblePromoItemDefIDs_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.itemdefids {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn cinventory_geteligiblepromoitemdefids_response_unpack(buf []byte) ?CInventory_GetEligiblePromoItemDefIDs_Response {
	mut res := zzz_vproto_internal_new_cinventory_geteligiblepromoitemdefids_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_GetEligiblePromoItemDefIDs_Response) eq(b CInventory_GetEligiblePromoItemDefIDs_Response) bool {
	return true && a.itemdefids == b.itemdefids
}

[inline]
pub fn (a CInventory_GetEligiblePromoItemDefIDs_Response) ne(b CInventory_GetEligiblePromoItemDefIDs_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetEligiblePromoItemDefIDs_Response) eq(b []CInventory_GetEligiblePromoItemDefIDs_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetEligiblePromoItemDefIDs_Response) ne(b []CInventory_GetEligiblePromoItemDefIDs_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_geteligiblepromoitemdefids_response() CInventory_GetEligiblePromoItemDefIDs_Response {
	return CInventory_GetEligiblePromoItemDefIDs_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_geteligiblepromoitemdefids_response(o CInventory_GetEligiblePromoItemDefIDs_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_geteligiblepromoitemdefids_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetEligiblePromoItemDefIDs_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_geteligiblepromoitemdefids_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_AddItem_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appid             u32
	itemdefid         []u64
	itempropsjson     []string
	steamid           u64
	notify            bool
	requestid         u64
	trade_restriction bool
	is_purchase       bool = false
}

pub fn (o &CInventory_AddItem_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.itemdefid {
		res << vproto.pack_uint64_field(x, 2)
	}
	// [packed=false]
	for _, x in o.itempropsjson {
		res << vproto.pack_string_field(x, 3)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 4)
	}
	if o.notify != bool(0) {
		res << vproto.pack_bool_field(o.notify, 5)
	}
	if o.requestid != u64(0) {
		res << vproto.pack_uint64_field(o.requestid, 6)
	}
	if o.trade_restriction != bool(0) {
		res << vproto.pack_bool_field(o.trade_restriction, 7)
	}
	if o.is_purchase != bool(0) {
		res << vproto.pack_bool_field(o.is_purchase, 8)
	}
	return res
}

pub fn cinventory_additem_request_unpack(buf []byte) ?CInventory_AddItem_Request {
	mut res := zzz_vproto_internal_new_cinventory_additem_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.itempropsjson << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notify = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.requestid = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.trade_restriction = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_purchase = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_AddItem_Request) eq(b CInventory_AddItem_Request) bool {
	return true && a.appid == b.appid &&
		a.itemdefid == b.itemdefid && a.itempropsjson == b.itempropsjson &&
		a.steamid == b.steamid && a.notify == b.notify &&
		a.requestid == b.requestid && a.trade_restriction == b.trade_restriction &&
		a.is_purchase == b.is_purchase
}

[inline]
pub fn (a CInventory_AddItem_Request) ne(b CInventory_AddItem_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_AddItem_Request) eq(b []CInventory_AddItem_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_AddItem_Request) ne(b []CInventory_AddItem_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_additem_request() CInventory_AddItem_Request {
	return CInventory_AddItem_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_additem_request(o CInventory_AddItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_additem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_AddItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_additem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ModifyItems_Request_ItemPropertyUpdate {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	itemid                u64
	remove_property       bool
	property_name         string
	property_value_bool   bool
	property_value_int    i64
	property_value_string string
	property_value_float  f32
}

pub fn (o &CInventory_ModifyItems_Request_ItemPropertyUpdate) pack() []byte {
	mut res := []byte{}
	if o.itemid != u64(0) {
		res << vproto.pack_uint64_field(o.itemid, 1)
	}
	if o.remove_property != bool(0) {
		res << vproto.pack_bool_field(o.remove_property, 2)
	}
	if o.property_name != '' {
		res << vproto.pack_string_field(o.property_name, 3)
	}
	if o.property_value_bool != bool(0) {
		res << vproto.pack_bool_field(o.property_value_bool, 4)
	}
	if o.property_value_int != i64(0) {
		res << vproto.pack_int64_field(o.property_value_int, 5)
	}
	if o.property_value_string != '' {
		res << vproto.pack_string_field(o.property_value_string, 6)
	}
	if o.property_value_float != f32(0) {
		res << vproto.pack_float_field(o.property_value_float, 7)
	}
	return res
}

pub fn cinventory_modifyitems_request_itempropertyupdate_unpack(buf []byte) ?CInventory_ModifyItems_Request_ItemPropertyUpdate {
	mut res := zzz_vproto_internal_new_cinventory_modifyitems_request_itempropertyupdate()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remove_property = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.property_name = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_bool = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_int = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_string = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_float = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_ModifyItems_Request_ItemPropertyUpdate) eq(b CInventory_ModifyItems_Request_ItemPropertyUpdate) bool {
	return true && a.itemid == b.itemid &&
		a.remove_property == b.remove_property &&
		a.property_name == b.property_name &&
		a.property_value_bool == b.property_value_bool &&
		a.property_value_int == b.property_value_int &&
		a.property_value_string == b.property_value_string &&
		a.property_value_float == b.property_value_float
}

[inline]
pub fn (a CInventory_ModifyItems_Request_ItemPropertyUpdate) ne(b CInventory_ModifyItems_Request_ItemPropertyUpdate) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_ModifyItems_Request_ItemPropertyUpdate) eq(b []CInventory_ModifyItems_Request_ItemPropertyUpdate) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_ModifyItems_Request_ItemPropertyUpdate) ne(b []CInventory_ModifyItems_Request_ItemPropertyUpdate) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_modifyitems_request_itempropertyupdate() CInventory_ModifyItems_Request_ItemPropertyUpdate {
	return CInventory_ModifyItems_Request_ItemPropertyUpdate{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_modifyitems_request_itempropertyupdate(o CInventory_ModifyItems_Request_ItemPropertyUpdate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_modifyitems_request_itempropertyupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ModifyItems_Request_ItemPropertyUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_modifyitems_request_itempropertyupdate_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ModifyItems_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	steamid        u64
	updates        []CInventory_ModifyItems_Request_ItemPropertyUpdate
	timestamp      u32
}

pub fn (o &CInventory_ModifyItems_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	// [packed=false]
	for _, x in o.updates {
		res << zzz_vproto_internal_pack_cinventory_modifyitems_request_itempropertyupdate(x, 3)
	}
	if o.timestamp != u32(0) {
		res << vproto.pack_uint32_field(o.timestamp, 4)
	}
	return res
}

pub fn cinventory_modifyitems_request_unpack(buf []byte) ?CInventory_ModifyItems_Request {
	mut res := zzz_vproto_internal_new_cinventory_modifyitems_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cinventory_modifyitems_request_itempropertyupdate(cur_buf,
					tag_wiretype.wire_type)?
				res.updates << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_ModifyItems_Request) eq(b CInventory_ModifyItems_Request) bool {
	return true && a.appid == b.appid &&
		a.steamid == b.steamid && a.updates.eq(b.updates) &&
		a.timestamp == b.timestamp
}

[inline]
pub fn (a CInventory_ModifyItems_Request) ne(b CInventory_ModifyItems_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_ModifyItems_Request) eq(b []CInventory_ModifyItems_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_ModifyItems_Request) ne(b []CInventory_ModifyItems_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_modifyitems_request() CInventory_ModifyItems_Request {
	return CInventory_ModifyItems_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_modifyitems_request(o CInventory_ModifyItems_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_modifyitems_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ModifyItems_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_modifyitems_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ConsumePlaytime_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	itemdefid      u64
}

pub fn (o &CInventory_ConsumePlaytime_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.itemdefid != u64(0) {
		res << vproto.pack_uint64_field(o.itemdefid, 2)
	}
	return res
}

pub fn cinventory_consumeplaytime_request_unpack(buf []byte) ?CInventory_ConsumePlaytime_Request {
	mut res := zzz_vproto_internal_new_cinventory_consumeplaytime_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_ConsumePlaytime_Request) eq(b CInventory_ConsumePlaytime_Request) bool {
	return true && a.appid == b.appid && a.itemdefid == b.itemdefid
}

[inline]
pub fn (a CInventory_ConsumePlaytime_Request) ne(b CInventory_ConsumePlaytime_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_ConsumePlaytime_Request) eq(b []CInventory_ConsumePlaytime_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_ConsumePlaytime_Request) ne(b []CInventory_ConsumePlaytime_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_consumeplaytime_request() CInventory_ConsumePlaytime_Request {
	return CInventory_ConsumePlaytime_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_consumeplaytime_request(o CInventory_ConsumePlaytime_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_consumeplaytime_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ConsumePlaytime_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_consumeplaytime_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ConsumeItem_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	itemid         u64
	quantity       u32
	timestamp      string
	steamid        u64
	requestid      u64
}

pub fn (o &CInventory_ConsumeItem_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.itemid != u64(0) {
		res << vproto.pack_uint64_field(o.itemid, 2)
	}
	if o.quantity != u32(0) {
		res << vproto.pack_uint32_field(o.quantity, 3)
	}
	if o.timestamp != '' {
		res << vproto.pack_string_field(o.timestamp, 4)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 5)
	}
	if o.requestid != u64(0) {
		res << vproto.pack_uint64_field(o.requestid, 6)
	}
	return res
}

pub fn cinventory_consumeitem_request_unpack(buf []byte) ?CInventory_ConsumeItem_Request {
	mut res := zzz_vproto_internal_new_cinventory_consumeitem_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.requestid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_ConsumeItem_Request) eq(b CInventory_ConsumeItem_Request) bool {
	return true && a.appid == b.appid &&
		a.itemid == b.itemid && a.quantity == b.quantity &&
		a.timestamp == b.timestamp && a.steamid == b.steamid &&
		a.requestid == b.requestid
}

[inline]
pub fn (a CInventory_ConsumeItem_Request) ne(b CInventory_ConsumeItem_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_ConsumeItem_Request) eq(b []CInventory_ConsumeItem_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_ConsumeItem_Request) ne(b []CInventory_ConsumeItem_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_consumeitem_request() CInventory_ConsumeItem_Request {
	return CInventory_ConsumeItem_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_consumeitem_request(o CInventory_ConsumeItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_consumeitem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ConsumeItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_consumeitem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_DevSetNextDrop_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	itemdefid      u64
	droptime       string
}

pub fn (o &CInventory_DevSetNextDrop_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.itemdefid != u64(0) {
		res << vproto.pack_uint64_field(o.itemdefid, 2)
	}
	if o.droptime != '' {
		res << vproto.pack_string_field(o.droptime, 3)
	}
	return res
}

pub fn cinventory_devsetnextdrop_request_unpack(buf []byte) ?CInventory_DevSetNextDrop_Request {
	mut res := zzz_vproto_internal_new_cinventory_devsetnextdrop_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.droptime = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_DevSetNextDrop_Request) eq(b CInventory_DevSetNextDrop_Request) bool {
	return true && a.appid == b.appid && a.itemdefid == b.itemdefid && a.droptime == b.droptime
}

[inline]
pub fn (a CInventory_DevSetNextDrop_Request) ne(b CInventory_DevSetNextDrop_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_DevSetNextDrop_Request) eq(b []CInventory_DevSetNextDrop_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_DevSetNextDrop_Request) ne(b []CInventory_DevSetNextDrop_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_devsetnextdrop_request() CInventory_DevSetNextDrop_Request {
	return CInventory_DevSetNextDrop_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_devsetnextdrop_request(o CInventory_DevSetNextDrop_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_devsetnextdrop_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_DevSetNextDrop_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_devsetnextdrop_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_SplitItemStack_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	itemid         u64
	quantity       u32
	steamid        u64
}

pub fn (o &CInventory_SplitItemStack_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.itemid != u64(0) {
		res << vproto.pack_uint64_field(o.itemid, 2)
	}
	if o.quantity != u32(0) {
		res << vproto.pack_uint32_field(o.quantity, 3)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_uint64_field(o.steamid, 5)
	}
	return res
}

pub fn cinventory_splititemstack_request_unpack(buf []byte) ?CInventory_SplitItemStack_Request {
	mut res := zzz_vproto_internal_new_cinventory_splititemstack_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_SplitItemStack_Request) eq(b CInventory_SplitItemStack_Request) bool {
	return true && a.appid == b.appid &&
		a.itemid == b.itemid && a.quantity == b.quantity &&
		a.steamid == b.steamid
}

[inline]
pub fn (a CInventory_SplitItemStack_Request) ne(b CInventory_SplitItemStack_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_SplitItemStack_Request) eq(b []CInventory_SplitItemStack_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_SplitItemStack_Request) ne(b []CInventory_SplitItemStack_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_splititemstack_request() CInventory_SplitItemStack_Request {
	return CInventory_SplitItemStack_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_splititemstack_request(o CInventory_SplitItemStack_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_splititemstack_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_SplitItemStack_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_splititemstack_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_CombineItemStacks_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	fromitemid     u64
	destitemid     u64
	quantity       u32
	steamid        u64
}

pub fn (o &CInventory_CombineItemStacks_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.fromitemid != u64(0) {
		res << vproto.pack_uint64_field(o.fromitemid, 2)
	}
	if o.destitemid != u64(0) {
		res << vproto.pack_uint64_field(o.destitemid, 3)
	}
	if o.quantity != u32(0) {
		res << vproto.pack_uint32_field(o.quantity, 4)
	}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 7)
	}
	return res
}

pub fn cinventory_combineitemstacks_request_unpack(buf []byte) ?CInventory_CombineItemStacks_Request {
	mut res := zzz_vproto_internal_new_cinventory_combineitemstacks_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.fromitemid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.destitemid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_CombineItemStacks_Request) eq(b CInventory_CombineItemStacks_Request) bool {
	return true && a.appid == b.appid &&
		a.fromitemid == b.fromitemid && a.destitemid == b.destitemid &&
		a.quantity == b.quantity && a.steamid == b.steamid
}

[inline]
pub fn (a CInventory_CombineItemStacks_Request) ne(b CInventory_CombineItemStacks_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_CombineItemStacks_Request) eq(b []CInventory_CombineItemStacks_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_CombineItemStacks_Request) ne(b []CInventory_CombineItemStacks_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_combineitemstacks_request() CInventory_CombineItemStacks_Request {
	return CInventory_CombineItemStacks_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_combineitemstacks_request(o CInventory_CombineItemStacks_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_combineitemstacks_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_CombineItemStacks_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_combineitemstacks_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetItemDefMeta_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
}

pub fn (o &CInventory_GetItemDefMeta_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cinventory_getitemdefmeta_request_unpack(buf []byte) ?CInventory_GetItemDefMeta_Request {
	mut res := zzz_vproto_internal_new_cinventory_getitemdefmeta_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_GetItemDefMeta_Request) eq(b CInventory_GetItemDefMeta_Request) bool {
	return true && a.appid == b.appid
}

[inline]
pub fn (a CInventory_GetItemDefMeta_Request) ne(b CInventory_GetItemDefMeta_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetItemDefMeta_Request) eq(b []CInventory_GetItemDefMeta_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetItemDefMeta_Request) ne(b []CInventory_GetItemDefMeta_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_getitemdefmeta_request() CInventory_GetItemDefMeta_Request {
	return CInventory_GetItemDefMeta_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_getitemdefmeta_request(o CInventory_GetItemDefMeta_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_getitemdefmeta_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetItemDefMeta_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getitemdefmeta_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetItemDefMeta_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	modified       u32
	digest         string
}

pub fn (o &CInventory_GetItemDefMeta_Response) pack() []byte {
	mut res := []byte{}
	if o.modified != u32(0) {
		res << vproto.pack_uint32_field(o.modified, 1)
	}
	if o.digest != '' {
		res << vproto.pack_string_field(o.digest, 2)
	}
	return res
}

pub fn cinventory_getitemdefmeta_response_unpack(buf []byte) ?CInventory_GetItemDefMeta_Response {
	mut res := zzz_vproto_internal_new_cinventory_getitemdefmeta_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modified = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.digest = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_GetItemDefMeta_Response) eq(b CInventory_GetItemDefMeta_Response) bool {
	return true && a.modified == b.modified && a.digest == b.digest
}

[inline]
pub fn (a CInventory_GetItemDefMeta_Response) ne(b CInventory_GetItemDefMeta_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetItemDefMeta_Response) eq(b []CInventory_GetItemDefMeta_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetItemDefMeta_Response) ne(b []CInventory_GetItemDefMeta_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_getitemdefmeta_response() CInventory_GetItemDefMeta_Response {
	return CInventory_GetItemDefMeta_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_getitemdefmeta_response(o CInventory_GetItemDefMeta_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_getitemdefmeta_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetItemDefMeta_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getitemdefmeta_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetUserPurchaseInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CInventory_GetUserPurchaseInfo_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cinventory_getuserpurchaseinfo_request_unpack(buf []byte) ?CInventory_GetUserPurchaseInfo_Request {
	res := zzz_vproto_internal_new_cinventory_getuserpurchaseinfo_request()
	return res
}

[inline]
pub fn (a CInventory_GetUserPurchaseInfo_Request) eq(b CInventory_GetUserPurchaseInfo_Request) bool {
	return true
}

[inline]
pub fn (a CInventory_GetUserPurchaseInfo_Request) ne(b CInventory_GetUserPurchaseInfo_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetUserPurchaseInfo_Request) eq(b []CInventory_GetUserPurchaseInfo_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetUserPurchaseInfo_Request) ne(b []CInventory_GetUserPurchaseInfo_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_getuserpurchaseinfo_request() CInventory_GetUserPurchaseInfo_Request {
	return CInventory_GetUserPurchaseInfo_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_getuserpurchaseinfo_request(o CInventory_GetUserPurchaseInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_getuserpurchaseinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetUserPurchaseInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getuserpurchaseinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetUserPurchaseInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ecurrency      int
}

pub fn (o &CInventory_GetUserPurchaseInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.ecurrency != int(0) {
		res << vproto.pack_int32_field(o.ecurrency, 1)
	}
	return res
}

pub fn cinventory_getuserpurchaseinfo_response_unpack(buf []byte) ?CInventory_GetUserPurchaseInfo_Response {
	mut res := zzz_vproto_internal_new_cinventory_getuserpurchaseinfo_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ecurrency = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_GetUserPurchaseInfo_Response) eq(b CInventory_GetUserPurchaseInfo_Response) bool {
	return true && a.ecurrency == b.ecurrency
}

[inline]
pub fn (a CInventory_GetUserPurchaseInfo_Response) ne(b CInventory_GetUserPurchaseInfo_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_GetUserPurchaseInfo_Response) eq(b []CInventory_GetUserPurchaseInfo_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_GetUserPurchaseInfo_Response) ne(b []CInventory_GetUserPurchaseInfo_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_getuserpurchaseinfo_response() CInventory_GetUserPurchaseInfo_Response {
	return CInventory_GetUserPurchaseInfo_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_getuserpurchaseinfo_response(o CInventory_GetUserPurchaseInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_getuserpurchaseinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetUserPurchaseInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getuserpurchaseinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseInit_Request_LineItem {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	itemdefid      u64
	quantity       u32
}

pub fn (o &CInventory_PurchaseInit_Request_LineItem) pack() []byte {
	mut res := []byte{}
	if o.itemdefid != u64(0) {
		res << vproto.pack_uint64_field(o.itemdefid, 1)
	}
	if o.quantity != u32(0) {
		res << vproto.pack_uint32_field(o.quantity, 2)
	}
	return res
}

pub fn cinventory_purchaseinit_request_lineitem_unpack(buf []byte) ?CInventory_PurchaseInit_Request_LineItem {
	mut res := zzz_vproto_internal_new_cinventory_purchaseinit_request_lineitem()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_PurchaseInit_Request_LineItem) eq(b CInventory_PurchaseInit_Request_LineItem) bool {
	return true && a.itemdefid == b.itemdefid && a.quantity == b.quantity
}

[inline]
pub fn (a CInventory_PurchaseInit_Request_LineItem) ne(b CInventory_PurchaseInit_Request_LineItem) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_PurchaseInit_Request_LineItem) eq(b []CInventory_PurchaseInit_Request_LineItem) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_PurchaseInit_Request_LineItem) ne(b []CInventory_PurchaseInit_Request_LineItem) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_purchaseinit_request_lineitem() CInventory_PurchaseInit_Request_LineItem {
	return CInventory_PurchaseInit_Request_LineItem{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_purchaseinit_request_lineitem(o CInventory_PurchaseInit_Request_LineItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_purchaseinit_request_lineitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseInit_Request_LineItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchaseinit_request_lineitem_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseInit_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	language       int
	line_items     []CInventory_PurchaseInit_Request_LineItem
}

pub fn (o &CInventory_PurchaseInit_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 2)
	}
	// [packed=false]
	for _, x in o.line_items {
		res << zzz_vproto_internal_pack_cinventory_purchaseinit_request_lineitem(x, 3)
	}
	return res
}

pub fn cinventory_purchaseinit_request_unpack(buf []byte) ?CInventory_PurchaseInit_Request {
	mut res := zzz_vproto_internal_new_cinventory_purchaseinit_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cinventory_purchaseinit_request_lineitem(cur_buf,
					tag_wiretype.wire_type)?
				res.line_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_PurchaseInit_Request) eq(b CInventory_PurchaseInit_Request) bool {
	return true && a.appid == b.appid && a.language == b.language && a.line_items.eq(b.line_items)
}

[inline]
pub fn (a CInventory_PurchaseInit_Request) ne(b CInventory_PurchaseInit_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_PurchaseInit_Request) eq(b []CInventory_PurchaseInit_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_PurchaseInit_Request) ne(b []CInventory_PurchaseInit_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_purchaseinit_request() CInventory_PurchaseInit_Request {
	return CInventory_PurchaseInit_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_purchaseinit_request(o CInventory_PurchaseInit_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_purchaseinit_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseInit_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchaseinit_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseInit_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	orderid        u64
	transid        u64
}

pub fn (o &CInventory_PurchaseInit_Response) pack() []byte {
	mut res := []byte{}
	if o.orderid != u64(0) {
		res << vproto.pack_uint64_field(o.orderid, 1)
	}
	if o.transid != u64(0) {
		res << vproto.pack_uint64_field(o.transid, 2)
	}
	return res
}

pub fn cinventory_purchaseinit_response_unpack(buf []byte) ?CInventory_PurchaseInit_Response {
	mut res := zzz_vproto_internal_new_cinventory_purchaseinit_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.orderid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.transid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_PurchaseInit_Response) eq(b CInventory_PurchaseInit_Response) bool {
	return true && a.orderid == b.orderid && a.transid == b.transid
}

[inline]
pub fn (a CInventory_PurchaseInit_Response) ne(b CInventory_PurchaseInit_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_PurchaseInit_Response) eq(b []CInventory_PurchaseInit_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_PurchaseInit_Response) ne(b []CInventory_PurchaseInit_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_purchaseinit_response() CInventory_PurchaseInit_Response {
	return CInventory_PurchaseInit_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_purchaseinit_response(o CInventory_PurchaseInit_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_purchaseinit_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseInit_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchaseinit_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseFinalize_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	language       int
	orderid        u64
}

pub fn (o &CInventory_PurchaseFinalize_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 2)
	}
	if o.orderid != u64(0) {
		res << vproto.pack_uint64_field(o.orderid, 3)
	}
	return res
}

pub fn cinventory_purchasefinalize_request_unpack(buf []byte) ?CInventory_PurchaseFinalize_Request {
	mut res := zzz_vproto_internal_new_cinventory_purchasefinalize_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.orderid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_PurchaseFinalize_Request) eq(b CInventory_PurchaseFinalize_Request) bool {
	return true && a.appid == b.appid && a.language == b.language && a.orderid == b.orderid
}

[inline]
pub fn (a CInventory_PurchaseFinalize_Request) ne(b CInventory_PurchaseFinalize_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_PurchaseFinalize_Request) eq(b []CInventory_PurchaseFinalize_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_PurchaseFinalize_Request) ne(b []CInventory_PurchaseFinalize_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_purchasefinalize_request() CInventory_PurchaseFinalize_Request {
	return CInventory_PurchaseFinalize_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_purchasefinalize_request(o CInventory_PurchaseFinalize_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_purchasefinalize_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseFinalize_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchasefinalize_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_InspectItem_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	itemdefid      u64
	itemid         u64
	tags           string
}

pub fn (o &CInventory_InspectItem_Request) pack() []byte {
	mut res := []byte{}
	if o.itemdefid != u64(0) {
		res << vproto.pack_uint64_field(o.itemdefid, 1)
	}
	if o.itemid != u64(0) {
		res << vproto.pack_64bit_field(o.itemid, 2)
	}
	if o.tags != '' {
		res << vproto.pack_string_field(o.tags, 3)
	}
	return res
}

pub fn cinventory_inspectitem_request_unpack(buf []byte) ?CInventory_InspectItem_Request {
	mut res := zzz_vproto_internal_new_cinventory_inspectitem_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventory_InspectItem_Request) eq(b CInventory_InspectItem_Request) bool {
	return true && a.itemdefid == b.itemdefid && a.itemid == b.itemid && a.tags == b.tags
}

[inline]
pub fn (a CInventory_InspectItem_Request) ne(b CInventory_InspectItem_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventory_InspectItem_Request) eq(b []CInventory_InspectItem_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventory_InspectItem_Request) ne(b []CInventory_InspectItem_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventory_inspectitem_request() CInventory_InspectItem_Request {
	return CInventory_InspectItem_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventory_inspectitem_request(o CInventory_InspectItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventory_inspectitem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_InspectItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_inspectitem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventoryClient_NewItems_Notification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	appid              u32
	inventory_response CInventory_Response
}

pub fn (o &CInventoryClient_NewItems_Notification) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.inventory_response.ne(zzz_vproto_internal_new_cinventory_response()) {
		res << zzz_vproto_internal_pack_cinventory_response(o.inventory_response, 2)
	}
	return res
}

pub fn cinventoryclient_newitems_notification_unpack(buf []byte) ?CInventoryClient_NewItems_Notification {
	mut res := zzz_vproto_internal_new_cinventoryclient_newitems_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_cinventory_response(cur_buf, tag_wiretype.wire_type)?
				res.inventory_response = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CInventoryClient_NewItems_Notification) eq(b CInventoryClient_NewItems_Notification) bool {
	return true && a.appid == b.appid && a.inventory_response.eq(b.inventory_response)
}

[inline]
pub fn (a CInventoryClient_NewItems_Notification) ne(b CInventoryClient_NewItems_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CInventoryClient_NewItems_Notification) eq(b []CInventoryClient_NewItems_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CInventoryClient_NewItems_Notification) ne(b []CInventoryClient_NewItems_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cinventoryclient_newitems_notification() CInventoryClient_NewItems_Notification {
	return CInventoryClient_NewItems_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cinventoryclient_newitems_notification(o CInventoryClient_NewItems_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cinventoryclient_newitems_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryClient_NewItems_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventoryclient_newitems_notification_unpack(v)?
	return i, unpacked
}
