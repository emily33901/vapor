// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EPublishedFileRevision {
	k_epublishedfilerevision_default = 0
	k_epublishedfilerevision_latest = 1
	k_epublishedfilerevision_approvedsnapshot = 2
	k_epublishedfilerevision_approvedsnapshot_china = 3
	k_epublishedfilerevision_rejectedsnapshot = 4
	k_epublishedfilerevision_rejectedsnapshot_china = 5
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_epublishedfilerevision() EPublishedFileRevision {
	return .k_epublishedfilerevision_default
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_epublishedfilerevision(e EPublishedFileRevision, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_epublishedfilerevision_packed(e []EPublishedFileRevision, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_epublishedfilerevision(buf []byte, tag_wiretype vproto.WireType) ?(int, EPublishedFileRevision) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EPublishedFileRevision(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_epublishedfilerevision_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EPublishedFileRevision) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EPublishedFileForSaleStatus {
	k_pffss_notforsale = 0
	k_pffss_pendingapproval = 1
	k_pffss_approvedforsale = 2
	k_pffss_rejectedforsale = 3
	k_pffss_nolongerforsale = 4
	k_pffss_tentativeapproval = 5
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_epublishedfileforsalestatus() EPublishedFileForSaleStatus {
	return .k_pffss_notforsale
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_epublishedfileforsalestatus(e EPublishedFileForSaleStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_epublishedfileforsalestatus_packed(e []EPublishedFileForSaleStatus, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_epublishedfileforsalestatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EPublishedFileForSaleStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EPublishedFileForSaleStatus(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_epublishedfileforsalestatus_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EPublishedFileForSaleStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CPublishedFile_Subscribe_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	list_type       u32
	appid           int
	notify_client   bool
}

pub fn (o &CPublishedFile_Subscribe_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.list_type != u32(0) {
		res << vproto.pack_uint32_field(o.list_type, 2)
	}
	if o.appid != int(0) {
		res << vproto.pack_int32_field(o.appid, 3)
	}
	if o.notify_client != bool(0) {
		res << vproto.pack_bool_field(o.notify_client, 4)
	}
	return res
}

pub fn cpublishedfile_subscribe_request_unpack(buf []byte) ?CPublishedFile_Subscribe_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_subscribe_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.list_type = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notify_client = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_Subscribe_Request) eq(b CPublishedFile_Subscribe_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.list_type == b.list_type && a.appid == b.appid &&
		a.notify_client == b.notify_client
}

[inline]
pub fn (a CPublishedFile_Subscribe_Request) ne(b CPublishedFile_Subscribe_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Subscribe_Request) eq(b []CPublishedFile_Subscribe_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Subscribe_Request) ne(b []CPublishedFile_Subscribe_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_subscribe_request() CPublishedFile_Subscribe_Request {
	return CPublishedFile_Subscribe_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_subscribe_request(o CPublishedFile_Subscribe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_subscribe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Subscribe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_subscribe_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Subscribe_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_Subscribe_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_subscribe_response_unpack(buf []byte) ?CPublishedFile_Subscribe_Response {
	res := zzz_vproto_internal_new_cpublishedfile_subscribe_response()
	return res
}

[inline]
pub fn (a CPublishedFile_Subscribe_Response) eq(b CPublishedFile_Subscribe_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_Subscribe_Response) ne(b CPublishedFile_Subscribe_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Subscribe_Response) eq(b []CPublishedFile_Subscribe_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Subscribe_Response) ne(b []CPublishedFile_Subscribe_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_subscribe_response() CPublishedFile_Subscribe_Response {
	return CPublishedFile_Subscribe_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_subscribe_response(o CPublishedFile_Subscribe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_subscribe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Subscribe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_subscribe_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Unsubscribe_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	list_type       u32
	appid           int
	notify_client   bool
}

pub fn (o &CPublishedFile_Unsubscribe_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.list_type != u32(0) {
		res << vproto.pack_uint32_field(o.list_type, 2)
	}
	if o.appid != int(0) {
		res << vproto.pack_int32_field(o.appid, 3)
	}
	if o.notify_client != bool(0) {
		res << vproto.pack_bool_field(o.notify_client, 4)
	}
	return res
}

pub fn cpublishedfile_unsubscribe_request_unpack(buf []byte) ?CPublishedFile_Unsubscribe_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_unsubscribe_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.list_type = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notify_client = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_Unsubscribe_Request) eq(b CPublishedFile_Unsubscribe_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.list_type == b.list_type && a.appid == b.appid &&
		a.notify_client == b.notify_client
}

[inline]
pub fn (a CPublishedFile_Unsubscribe_Request) ne(b CPublishedFile_Unsubscribe_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Unsubscribe_Request) eq(b []CPublishedFile_Unsubscribe_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Unsubscribe_Request) ne(b []CPublishedFile_Unsubscribe_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_unsubscribe_request() CPublishedFile_Unsubscribe_Request {
	return CPublishedFile_Unsubscribe_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_unsubscribe_request(o CPublishedFile_Unsubscribe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_unsubscribe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Unsubscribe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_unsubscribe_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Unsubscribe_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_Unsubscribe_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_unsubscribe_response_unpack(buf []byte) ?CPublishedFile_Unsubscribe_Response {
	res := zzz_vproto_internal_new_cpublishedfile_unsubscribe_response()
	return res
}

[inline]
pub fn (a CPublishedFile_Unsubscribe_Response) eq(b CPublishedFile_Unsubscribe_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_Unsubscribe_Response) ne(b CPublishedFile_Unsubscribe_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Unsubscribe_Response) eq(b []CPublishedFile_Unsubscribe_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Unsubscribe_Response) ne(b []CPublishedFile_Unsubscribe_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_unsubscribe_response() CPublishedFile_Unsubscribe_Response {
	return CPublishedFile_Unsubscribe_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_unsubscribe_response(o CPublishedFile_Unsubscribe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_unsubscribe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Unsubscribe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_unsubscribe_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_CanSubscribe_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
}

pub fn (o &CPublishedFile_CanSubscribe_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	return res
}

pub fn cpublishedfile_cansubscribe_request_unpack(buf []byte) ?CPublishedFile_CanSubscribe_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_cansubscribe_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_CanSubscribe_Request) eq(b CPublishedFile_CanSubscribe_Request) bool {
	return true && a.publishedfileid == b.publishedfileid
}

[inline]
pub fn (a CPublishedFile_CanSubscribe_Request) ne(b CPublishedFile_CanSubscribe_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_CanSubscribe_Request) eq(b []CPublishedFile_CanSubscribe_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_CanSubscribe_Request) ne(b []CPublishedFile_CanSubscribe_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_cansubscribe_request() CPublishedFile_CanSubscribe_Request {
	return CPublishedFile_CanSubscribe_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_cansubscribe_request(o CPublishedFile_CanSubscribe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_cansubscribe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_CanSubscribe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_cansubscribe_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_CanSubscribe_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	can_subscribe  bool
}

pub fn (o &CPublishedFile_CanSubscribe_Response) pack() []byte {
	mut res := []byte{}
	if o.can_subscribe != bool(0) {
		res << vproto.pack_bool_field(o.can_subscribe, 1)
	}
	return res
}

pub fn cpublishedfile_cansubscribe_response_unpack(buf []byte) ?CPublishedFile_CanSubscribe_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_cansubscribe_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_subscribe = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_CanSubscribe_Response) eq(b CPublishedFile_CanSubscribe_Response) bool {
	return true && a.can_subscribe == b.can_subscribe
}

[inline]
pub fn (a CPublishedFile_CanSubscribe_Response) ne(b CPublishedFile_CanSubscribe_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_CanSubscribe_Response) eq(b []CPublishedFile_CanSubscribe_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_CanSubscribe_Response) ne(b []CPublishedFile_CanSubscribe_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_cansubscribe_response() CPublishedFile_CanSubscribe_Response {
	return CPublishedFile_CanSubscribe_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_cansubscribe_response(o CPublishedFile_CanSubscribe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_cansubscribe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_CanSubscribe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_cansubscribe_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Publish_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	consumer_appid         u32
	cloudfilename          string
	preview_cloudfilename  string
	title                  string
	file_description       string
	file_type              u32
	consumer_shortcut_name string
	youtube_username       string
	youtube_videoid        string
	visibility             u32
	redirect_uri           string
	tags                   []string
	collection_type        string
	game_type              string
	url                    string
}

pub fn (o &CPublishedFile_Publish_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.consumer_appid != u32(0) {
		res << vproto.pack_uint32_field(o.consumer_appid, 2)
	}
	if o.cloudfilename != '' {
		res << vproto.pack_string_field(o.cloudfilename, 3)
	}
	if o.preview_cloudfilename != '' {
		res << vproto.pack_string_field(o.preview_cloudfilename, 4)
	}
	if o.title != '' {
		res << vproto.pack_string_field(o.title, 5)
	}
	if o.file_description != '' {
		res << vproto.pack_string_field(o.file_description, 6)
	}
	if o.file_type != u32(0) {
		res << vproto.pack_uint32_field(o.file_type, 7)
	}
	if o.consumer_shortcut_name != '' {
		res << vproto.pack_string_field(o.consumer_shortcut_name, 8)
	}
	if o.youtube_username != '' {
		res << vproto.pack_string_field(o.youtube_username, 9)
	}
	if o.youtube_videoid != '' {
		res << vproto.pack_string_field(o.youtube_videoid, 10)
	}
	if o.visibility != u32(0) {
		res << vproto.pack_uint32_field(o.visibility, 11)
	}
	if o.redirect_uri != '' {
		res << vproto.pack_string_field(o.redirect_uri, 12)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 13)
	}
	if o.collection_type != '' {
		res << vproto.pack_string_field(o.collection_type, 14)
	}
	if o.game_type != '' {
		res << vproto.pack_string_field(o.game_type, 15)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 16)
	}
	return res
}

pub fn cpublishedfile_publish_request_unpack(buf []byte) ?CPublishedFile_Publish_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_publish_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_appid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cloudfilename = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_cloudfilename = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_description = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_shortcut_name = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtube_username = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtube_videoid = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.redirect_uri = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.collection_type = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_type = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_Publish_Request) eq(b CPublishedFile_Publish_Request) bool {
	return true && a.appid == b.appid &&
		a.consumer_appid == b.consumer_appid &&
		a.cloudfilename == b.cloudfilename &&
		a.preview_cloudfilename == b.preview_cloudfilename &&
		a.title == b.title && a.file_description == b.file_description &&
		a.file_type == b.file_type && a.consumer_shortcut_name == b.consumer_shortcut_name &&
		a.youtube_username == b.youtube_username &&
		a.youtube_videoid == b.youtube_videoid &&
		a.visibility == b.visibility && a.redirect_uri == b.redirect_uri &&
		a.tags == b.tags && a.collection_type == b.collection_type &&
		a.game_type == b.game_type && a.url == b.url
}

[inline]
pub fn (a CPublishedFile_Publish_Request) ne(b CPublishedFile_Publish_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Publish_Request) eq(b []CPublishedFile_Publish_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Publish_Request) ne(b []CPublishedFile_Publish_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_publish_request() CPublishedFile_Publish_Request {
	return CPublishedFile_Publish_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_publish_request(o CPublishedFile_Publish_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_publish_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Publish_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_publish_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Publish_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	redirect_uri    string
}

pub fn (o &CPublishedFile_Publish_Response) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.redirect_uri != '' {
		res << vproto.pack_string_field(o.redirect_uri, 2)
	}
	return res
}

pub fn cpublishedfile_publish_response_unpack(buf []byte) ?CPublishedFile_Publish_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_publish_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.redirect_uri = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_Publish_Response) eq(b CPublishedFile_Publish_Response) bool {
	return true && a.publishedfileid == b.publishedfileid && a.redirect_uri == b.redirect_uri
}

[inline]
pub fn (a CPublishedFile_Publish_Response) ne(b CPublishedFile_Publish_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Publish_Response) eq(b []CPublishedFile_Publish_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Publish_Response) ne(b []CPublishedFile_Publish_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_publish_response() CPublishedFile_Publish_Response {
	return CPublishedFile_Publish_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_publish_response(o CPublishedFile_Publish_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_publish_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Publish_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_publish_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetDetails_Request {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	publishedfileids          []u64
	includetags               bool
	includeadditionalpreviews bool
	includechildren           bool
	includekvtags             bool
	includevotes              bool
	short_description         bool
	includeforsaledata        bool
	includemetadata           bool
	language                  int = 0
	return_playtime_stats     u32
	appid                     u32
	strip_description_bbcode  bool
	desired_revision          EPublishedFileRevision = .k_epublishedfilerevision_default
	includereactions          bool = false
}

pub fn (o &CPublishedFile_GetDetails_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_64bit_field(x, 1)
	}
	if o.includetags != bool(0) {
		res << vproto.pack_bool_field(o.includetags, 2)
	}
	if o.includeadditionalpreviews != bool(0) {
		res << vproto.pack_bool_field(o.includeadditionalpreviews, 3)
	}
	if o.includechildren != bool(0) {
		res << vproto.pack_bool_field(o.includechildren, 4)
	}
	if o.includekvtags != bool(0) {
		res << vproto.pack_bool_field(o.includekvtags, 5)
	}
	if o.includevotes != bool(0) {
		res << vproto.pack_bool_field(o.includevotes, 6)
	}
	if o.short_description != bool(0) {
		res << vproto.pack_bool_field(o.short_description, 8)
	}
	if o.includeforsaledata != bool(0) {
		res << vproto.pack_bool_field(o.includeforsaledata, 10)
	}
	if o.includemetadata != bool(0) {
		res << vproto.pack_bool_field(o.includemetadata, 11)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 12)
	}
	if o.return_playtime_stats != u32(0) {
		res << vproto.pack_uint32_field(o.return_playtime_stats, 13)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 14)
	}
	if o.strip_description_bbcode != bool(0) {
		res << vproto.pack_bool_field(o.strip_description_bbcode, 15)
	}
	if o.desired_revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 16)
	}
	if o.includereactions != bool(0) {
		res << vproto.pack_bool_field(o.includereactions, 17)
	}
	return res
}

pub fn cpublishedfile_getdetails_request_unpack(buf []byte) ?CPublishedFile_GetDetails_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getdetails_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includetags = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includeadditionalpreviews = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includechildren = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includekvtags = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includevotes = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.short_description = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includeforsaledata = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includemetadata = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.return_playtime_stats = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.strip_description_bbcode = v
				i = ii
			}
			16 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includereactions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetDetails_Request) eq(b CPublishedFile_GetDetails_Request) bool {
	return true && a.publishedfileids == b.publishedfileids &&
		a.includetags == b.includetags && a.includeadditionalpreviews == b.includeadditionalpreviews &&
		a.includechildren == b.includechildren &&
		a.includekvtags == b.includekvtags &&
		a.includevotes == b.includevotes &&
		a.short_description == b.short_description &&
		a.includeforsaledata == b.includeforsaledata &&
		a.includemetadata == b.includemetadata &&
		a.language == b.language && a.return_playtime_stats == b.return_playtime_stats &&
		a.appid == b.appid && a.strip_description_bbcode == b.strip_description_bbcode &&
		a.desired_revision == b.desired_revision &&
		a.includereactions == b.includereactions
}

[inline]
pub fn (a CPublishedFile_GetDetails_Request) ne(b CPublishedFile_GetDetails_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetDetails_Request) eq(b []CPublishedFile_GetDetails_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetDetails_Request) ne(b []CPublishedFile_GetDetails_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getdetails_request() CPublishedFile_GetDetails_Request {
	return CPublishedFile_GetDetails_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getdetails_request(o CPublishedFile_GetDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getdetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getdetails_request_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Tag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tag            string
	adminonly      bool
}

pub fn (o &PublishedFileDetails_Tag) pack() []byte {
	mut res := []byte{}
	if o.tag != '' {
		res << vproto.pack_string_field(o.tag, 1)
	}
	if o.adminonly != bool(0) {
		res << vproto.pack_bool_field(o.adminonly, 2)
	}
	return res
}

pub fn publishedfiledetails_tag_unpack(buf []byte) ?PublishedFileDetails_Tag {
	mut res := zzz_vproto_internal_new_publishedfiledetails_tag()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tag = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.adminonly = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_Tag) eq(b PublishedFileDetails_Tag) bool {
	return true && a.tag == b.tag && a.adminonly == b.adminonly
}

[inline]
pub fn (a PublishedFileDetails_Tag) ne(b PublishedFileDetails_Tag) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_Tag) eq(b []PublishedFileDetails_Tag) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_Tag) ne(b []PublishedFileDetails_Tag) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_tag() PublishedFileDetails_Tag {
	return PublishedFileDetails_Tag{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_tag(o PublishedFileDetails_Tag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_tag(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Tag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_tag_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Preview {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	previewid          u64
	sortorder          u32
	url                string
	size               u32
	filename           string
	youtubevideoid     string
	preview_type       u32
	external_reference string
}

pub fn (o &PublishedFileDetails_Preview) pack() []byte {
	mut res := []byte{}
	if o.previewid != u64(0) {
		res << vproto.pack_uint64_field(o.previewid, 1)
	}
	if o.sortorder != u32(0) {
		res << vproto.pack_uint32_field(o.sortorder, 2)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 3)
	}
	if o.size != u32(0) {
		res << vproto.pack_uint32_field(o.size, 4)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 5)
	}
	if o.youtubevideoid != '' {
		res << vproto.pack_string_field(o.youtubevideoid, 6)
	}
	if o.preview_type != u32(0) {
		res << vproto.pack_uint32_field(o.preview_type, 7)
	}
	if o.external_reference != '' {
		res << vproto.pack_string_field(o.external_reference, 8)
	}
	return res
}

pub fn publishedfiledetails_preview_unpack(buf []byte) ?PublishedFileDetails_Preview {
	mut res := zzz_vproto_internal_new_publishedfiledetails_preview()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.previewid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sortorder = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.size = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtubevideoid = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_type = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.external_reference = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_Preview) eq(b PublishedFileDetails_Preview) bool {
	return true && a.previewid == b.previewid &&
		a.sortorder == b.sortorder && a.url == b.url &&
		a.size == b.size && a.filename == b.filename &&
		a.youtubevideoid == b.youtubevideoid &&
		a.preview_type == b.preview_type &&
		a.external_reference == b.external_reference
}

[inline]
pub fn (a PublishedFileDetails_Preview) ne(b PublishedFileDetails_Preview) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_Preview) eq(b []PublishedFileDetails_Preview) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_Preview) ne(b []PublishedFileDetails_Preview) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_preview() PublishedFileDetails_Preview {
	return PublishedFileDetails_Preview{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_preview(o PublishedFileDetails_Preview, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_preview(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Preview) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_preview_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Child {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	sortorder       u32
	file_type       u32
}

pub fn (o &PublishedFileDetails_Child) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.sortorder != u32(0) {
		res << vproto.pack_uint32_field(o.sortorder, 2)
	}
	if o.file_type != u32(0) {
		res << vproto.pack_uint32_field(o.file_type, 3)
	}
	return res
}

pub fn publishedfiledetails_child_unpack(buf []byte) ?PublishedFileDetails_Child {
	mut res := zzz_vproto_internal_new_publishedfiledetails_child()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sortorder = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_Child) eq(b PublishedFileDetails_Child) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.sortorder == b.sortorder && a.file_type == b.file_type
}

[inline]
pub fn (a PublishedFileDetails_Child) ne(b PublishedFileDetails_Child) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_Child) eq(b []PublishedFileDetails_Child) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_Child) ne(b []PublishedFileDetails_Child) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_child() PublishedFileDetails_Child {
	return PublishedFileDetails_Child{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_child(o PublishedFileDetails_Child, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_child(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Child) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_child_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_KVTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
}

pub fn (o &PublishedFileDetails_KVTag) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn publishedfiledetails_kvtag_unpack(buf []byte) ?PublishedFileDetails_KVTag {
	mut res := zzz_vproto_internal_new_publishedfiledetails_kvtag()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_KVTag) eq(b PublishedFileDetails_KVTag) bool {
	return true && a.key == b.key && a.value == b.value
}

[inline]
pub fn (a PublishedFileDetails_KVTag) ne(b PublishedFileDetails_KVTag) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_KVTag) eq(b []PublishedFileDetails_KVTag) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_KVTag) ne(b []PublishedFileDetails_KVTag) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_kvtag() PublishedFileDetails_KVTag {
	return PublishedFileDetails_KVTag{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_kvtag(o PublishedFileDetails_KVTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_kvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_KVTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_kvtag_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_VoteData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	score          f32
	votes_up       u32
	votes_down     u32
}

pub fn (o &PublishedFileDetails_VoteData) pack() []byte {
	mut res := []byte{}
	if o.score != f32(0) {
		res << vproto.pack_float_field(o.score, 1)
	}
	if o.votes_up != u32(0) {
		res << vproto.pack_uint32_field(o.votes_up, 2)
	}
	if o.votes_down != u32(0) {
		res << vproto.pack_uint32_field(o.votes_down, 3)
	}
	return res
}

pub fn publishedfiledetails_votedata_unpack(buf []byte) ?PublishedFileDetails_VoteData {
	mut res := zzz_vproto_internal_new_publishedfiledetails_votedata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.votes_up = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.votes_down = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_VoteData) eq(b PublishedFileDetails_VoteData) bool {
	return true && a.score == b.score && a.votes_up == b.votes_up && a.votes_down == b.votes_down
}

[inline]
pub fn (a PublishedFileDetails_VoteData) ne(b PublishedFileDetails_VoteData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_VoteData) eq(b []PublishedFileDetails_VoteData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_VoteData) ne(b []PublishedFileDetails_VoteData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_votedata() PublishedFileDetails_VoteData {
	return PublishedFileDetails_VoteData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_votedata(o PublishedFileDetails_VoteData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_votedata(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_VoteData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_votedata_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_ForSaleData {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	is_for_sale                bool
	price_category             u32
	estatus                    EPublishedFileForSaleStatus = .k_pffss_notforsale
	price_category_floor       u32
	price_is_pay_what_you_want bool
	discount_percentage        u32
}

pub fn (o &PublishedFileDetails_ForSaleData) pack() []byte {
	mut res := []byte{}
	if o.is_for_sale != bool(0) {
		res << vproto.pack_bool_field(o.is_for_sale, 1)
	}
	if o.price_category != u32(0) {
		res << vproto.pack_uint32_field(o.price_category, 2)
	}
	if o.estatus != zzz_vproto_internal_new_epublishedfileforsalestatus() {
		res << zzz_vproto_internal_pack_epublishedfileforsalestatus(o.estatus, 3)
	}
	if o.price_category_floor != u32(0) {
		res << vproto.pack_uint32_field(o.price_category_floor, 4)
	}
	if o.price_is_pay_what_you_want != bool(0) {
		res << vproto.pack_bool_field(o.price_is_pay_what_you_want, 5)
	}
	if o.discount_percentage != u32(0) {
		res << vproto.pack_uint32_field(o.discount_percentage, 6)
	}
	return res
}

pub fn publishedfiledetails_forsaledata_unpack(buf []byte) ?PublishedFileDetails_ForSaleData {
	mut res := zzz_vproto_internal_new_publishedfiledetails_forsaledata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_for_sale = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.price_category = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_epublishedfileforsalestatus(cur_buf,
					tag_wiretype.wire_type)?
				res.estatus = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.price_category_floor = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.price_is_pay_what_you_want = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.discount_percentage = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_ForSaleData) eq(b PublishedFileDetails_ForSaleData) bool {
	return true && a.is_for_sale == b.is_for_sale &&
		a.price_category == b.price_category &&
		a.estatus == b.estatus && a.price_category_floor == b.price_category_floor &&
		a.price_is_pay_what_you_want == b.price_is_pay_what_you_want &&
		a.discount_percentage == b.discount_percentage
}

[inline]
pub fn (a PublishedFileDetails_ForSaleData) ne(b PublishedFileDetails_ForSaleData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_ForSaleData) eq(b []PublishedFileDetails_ForSaleData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_ForSaleData) ne(b []PublishedFileDetails_ForSaleData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_forsaledata() PublishedFileDetails_ForSaleData {
	return PublishedFileDetails_ForSaleData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_forsaledata(o PublishedFileDetails_ForSaleData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_forsaledata(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_ForSaleData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_forsaledata_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_PlaytimeStats {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	playtime_seconds u64
	num_sessions     u64
}

pub fn (o &PublishedFileDetails_PlaytimeStats) pack() []byte {
	mut res := []byte{}
	if o.playtime_seconds != u64(0) {
		res << vproto.pack_uint64_field(o.playtime_seconds, 1)
	}
	if o.num_sessions != u64(0) {
		res << vproto.pack_uint64_field(o.num_sessions, 2)
	}
	return res
}

pub fn publishedfiledetails_playtimestats_unpack(buf []byte) ?PublishedFileDetails_PlaytimeStats {
	mut res := zzz_vproto_internal_new_publishedfiledetails_playtimestats()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_seconds = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.num_sessions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_PlaytimeStats) eq(b PublishedFileDetails_PlaytimeStats) bool {
	return true && a.playtime_seconds == b.playtime_seconds && a.num_sessions == b.num_sessions
}

[inline]
pub fn (a PublishedFileDetails_PlaytimeStats) ne(b PublishedFileDetails_PlaytimeStats) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_PlaytimeStats) eq(b []PublishedFileDetails_PlaytimeStats) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_PlaytimeStats) ne(b []PublishedFileDetails_PlaytimeStats) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_playtimestats() PublishedFileDetails_PlaytimeStats {
	return PublishedFileDetails_PlaytimeStats{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_playtimestats(o PublishedFileDetails_PlaytimeStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_playtimestats(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_PlaytimeStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_playtimestats_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Reaction {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	reactionid     u32
	count          u32
}

pub fn (o &PublishedFileDetails_Reaction) pack() []byte {
	mut res := []byte{}
	if o.reactionid != u32(0) {
		res << vproto.pack_uint32_field(o.reactionid, 1)
	}
	if o.count != u32(0) {
		res << vproto.pack_uint32_field(o.count, 2)
	}
	return res
}

pub fn publishedfiledetails_reaction_unpack(buf []byte) ?PublishedFileDetails_Reaction {
	mut res := zzz_vproto_internal_new_publishedfiledetails_reaction()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.reactionid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails_Reaction) eq(b PublishedFileDetails_Reaction) bool {
	return true && a.reactionid == b.reactionid && a.count == b.count
}

[inline]
pub fn (a PublishedFileDetails_Reaction) ne(b PublishedFileDetails_Reaction) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails_Reaction) eq(b []PublishedFileDetails_Reaction) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails_Reaction) ne(b []PublishedFileDetails_Reaction) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails_reaction() PublishedFileDetails_Reaction {
	return PublishedFileDetails_Reaction{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails_reaction(o PublishedFileDetails_Reaction, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails_reaction(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Reaction) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_reaction_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	result                       u32
	publishedfileid              u64
	creator                      u64
	creator_appid                u32
	consumer_appid               u32
	consumer_shortcutid          u32
	filename                     string
	file_size                    u64
	preview_file_size            u64
	file_url                     string
	preview_url                  string
	youtubevideoid               string
	url                          string
	hcontent_file                u64
	hcontent_preview             u64
	title                        string
	file_description             string
	short_description            string
	time_created                 u32
	time_updated                 u32
	visibility                   u32
	flags                        u32
	workshop_file                bool
	workshop_accepted            bool
	show_subscribe_all           bool
	num_comments_developer       int
	num_comments_public          int
	banned                       bool
	ban_reason                   string
	banner                       u64
	can_be_deleted               bool
	incompatible                 bool
	app_name                     string
	file_type                    u32
	can_subscribe                bool
	subscriptions                u32
	favorited                    u32
	followers                    u32
	lifetime_subscriptions       u32
	lifetime_favorited           u32
	lifetime_followers           u32
	lifetime_playtime            u64
	lifetime_playtime_sessions   u64
	views                        u32
	image_width                  u32
	image_height                 u32
	image_url                    string
	spoiler_tag                  bool
	shortcutid                   u32
	shortcutname                 string
	num_children                 u32
	num_reports                  u32
	previews                     []PublishedFileDetails_Preview
	tags                         []PublishedFileDetails_Tag
	children                     []PublishedFileDetails_Child
	kvtags                       []PublishedFileDetails_KVTag
	vote_data                    PublishedFileDetails_VoteData
	playtime_stats               PublishedFileDetails_PlaytimeStats
	time_subscribed              u32
	for_sale_data                PublishedFileDetails_ForSaleData
	metadata                     string
	language                     int = 0
	maybe_inappropriate_sex      bool
	maybe_inappropriate_violence bool
	revision_change_number       u64
	revision                     EPublishedFileRevision = .k_epublishedfilerevision_default
	available_revisions          []EPublishedFileRevision
	reactions                    []PublishedFileDetails_Reaction
}

pub fn (o &PublishedFileDetails) pack() []byte {
	mut res := []byte{}
	if o.result != u32(0) {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.creator != u64(0) {
		res << vproto.pack_64bit_field(o.creator, 3)
	}
	if o.creator_appid != u32(0) {
		res << vproto.pack_uint32_field(o.creator_appid, 4)
	}
	if o.consumer_appid != u32(0) {
		res << vproto.pack_uint32_field(o.consumer_appid, 5)
	}
	if o.consumer_shortcutid != u32(0) {
		res << vproto.pack_uint32_field(o.consumer_shortcutid, 6)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 7)
	}
	if o.file_size != u64(0) {
		res << vproto.pack_uint64_field(o.file_size, 8)
	}
	if o.preview_file_size != u64(0) {
		res << vproto.pack_uint64_field(o.preview_file_size, 9)
	}
	if o.file_url != '' {
		res << vproto.pack_string_field(o.file_url, 10)
	}
	if o.preview_url != '' {
		res << vproto.pack_string_field(o.preview_url, 11)
	}
	if o.youtubevideoid != '' {
		res << vproto.pack_string_field(o.youtubevideoid, 12)
	}
	if o.url != '' {
		res << vproto.pack_string_field(o.url, 13)
	}
	if o.hcontent_file != u64(0) {
		res << vproto.pack_64bit_field(o.hcontent_file, 14)
	}
	if o.hcontent_preview != u64(0) {
		res << vproto.pack_64bit_field(o.hcontent_preview, 15)
	}
	if o.title != '' {
		res << vproto.pack_string_field(o.title, 16)
	}
	if o.file_description != '' {
		res << vproto.pack_string_field(o.file_description, 17)
	}
	if o.short_description != '' {
		res << vproto.pack_string_field(o.short_description, 18)
	}
	if o.time_created != u32(0) {
		res << vproto.pack_uint32_field(o.time_created, 19)
	}
	if o.time_updated != u32(0) {
		res << vproto.pack_uint32_field(o.time_updated, 20)
	}
	if o.visibility != u32(0) {
		res << vproto.pack_uint32_field(o.visibility, 21)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 22)
	}
	if o.workshop_file != bool(0) {
		res << vproto.pack_bool_field(o.workshop_file, 23)
	}
	if o.workshop_accepted != bool(0) {
		res << vproto.pack_bool_field(o.workshop_accepted, 24)
	}
	if o.show_subscribe_all != bool(0) {
		res << vproto.pack_bool_field(o.show_subscribe_all, 25)
	}
	if o.num_comments_developer != int(0) {
		res << vproto.pack_int32_field(o.num_comments_developer, 26)
	}
	if o.num_comments_public != int(0) {
		res << vproto.pack_int32_field(o.num_comments_public, 27)
	}
	if o.banned != bool(0) {
		res << vproto.pack_bool_field(o.banned, 28)
	}
	if o.ban_reason != '' {
		res << vproto.pack_string_field(o.ban_reason, 29)
	}
	if o.banner != u64(0) {
		res << vproto.pack_64bit_field(o.banner, 30)
	}
	if o.can_be_deleted != bool(0) {
		res << vproto.pack_bool_field(o.can_be_deleted, 31)
	}
	if o.incompatible != bool(0) {
		res << vproto.pack_bool_field(o.incompatible, 32)
	}
	if o.app_name != '' {
		res << vproto.pack_string_field(o.app_name, 33)
	}
	if o.file_type != u32(0) {
		res << vproto.pack_uint32_field(o.file_type, 34)
	}
	if o.can_subscribe != bool(0) {
		res << vproto.pack_bool_field(o.can_subscribe, 35)
	}
	if o.subscriptions != u32(0) {
		res << vproto.pack_uint32_field(o.subscriptions, 36)
	}
	if o.favorited != u32(0) {
		res << vproto.pack_uint32_field(o.favorited, 37)
	}
	if o.followers != u32(0) {
		res << vproto.pack_uint32_field(o.followers, 38)
	}
	if o.lifetime_subscriptions != u32(0) {
		res << vproto.pack_uint32_field(o.lifetime_subscriptions, 39)
	}
	if o.lifetime_favorited != u32(0) {
		res << vproto.pack_uint32_field(o.lifetime_favorited, 40)
	}
	if o.lifetime_followers != u32(0) {
		res << vproto.pack_uint32_field(o.lifetime_followers, 41)
	}
	if o.lifetime_playtime != u64(0) {
		res << vproto.pack_uint64_field(o.lifetime_playtime, 62)
	}
	if o.lifetime_playtime_sessions != u64(0) {
		res << vproto.pack_uint64_field(o.lifetime_playtime_sessions, 63)
	}
	if o.views != u32(0) {
		res << vproto.pack_uint32_field(o.views, 42)
	}
	if o.image_width != u32(0) {
		res << vproto.pack_uint32_field(o.image_width, 43)
	}
	if o.image_height != u32(0) {
		res << vproto.pack_uint32_field(o.image_height, 44)
	}
	if o.image_url != '' {
		res << vproto.pack_string_field(o.image_url, 45)
	}
	if o.spoiler_tag != bool(0) {
		res << vproto.pack_bool_field(o.spoiler_tag, 46)
	}
	if o.shortcutid != u32(0) {
		res << vproto.pack_uint32_field(o.shortcutid, 47)
	}
	if o.shortcutname != '' {
		res << vproto.pack_string_field(o.shortcutname, 48)
	}
	if o.num_children != u32(0) {
		res << vproto.pack_uint32_field(o.num_children, 49)
	}
	if o.num_reports != u32(0) {
		res << vproto.pack_uint32_field(o.num_reports, 50)
	}
	// [packed=false]
	for _, x in o.previews {
		res << zzz_vproto_internal_pack_publishedfiledetails_preview(x, 51)
	}
	// [packed=false]
	for _, x in o.tags {
		res << zzz_vproto_internal_pack_publishedfiledetails_tag(x, 52)
	}
	// [packed=false]
	for _, x in o.children {
		res << zzz_vproto_internal_pack_publishedfiledetails_child(x, 53)
	}
	// [packed=false]
	for _, x in o.kvtags {
		res << zzz_vproto_internal_pack_publishedfiledetails_kvtag(x, 54)
	}
	if o.vote_data.ne(zzz_vproto_internal_new_publishedfiledetails_votedata()) {
		res << zzz_vproto_internal_pack_publishedfiledetails_votedata(o.vote_data, 55)
	}
	if o.playtime_stats.ne(zzz_vproto_internal_new_publishedfiledetails_playtimestats()) {
		res << zzz_vproto_internal_pack_publishedfiledetails_playtimestats(o.playtime_stats, 64)
	}
	if o.time_subscribed != u32(0) {
		res << vproto.pack_uint32_field(o.time_subscribed, 56)
	}
	if o.for_sale_data.ne(zzz_vproto_internal_new_publishedfiledetails_forsaledata()) {
		res << zzz_vproto_internal_pack_publishedfiledetails_forsaledata(o.for_sale_data, 57)
	}
	if o.metadata != '' {
		res << vproto.pack_string_field(o.metadata, 58)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 61)
	}
	if o.maybe_inappropriate_sex != bool(0) {
		res << vproto.pack_bool_field(o.maybe_inappropriate_sex, 65)
	}
	if o.maybe_inappropriate_violence != bool(0) {
		res << vproto.pack_bool_field(o.maybe_inappropriate_violence, 66)
	}
	if o.revision_change_number != u64(0) {
		res << vproto.pack_uint64_field(o.revision_change_number, 67)
	}
	if o.revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.revision, 68)
	}
	// [packed=false]
	for _, x in o.available_revisions {
		res << zzz_vproto_internal_pack_epublishedfilerevision(x, 69)
	}
	// [packed=false]
	for _, x in o.reactions {
		res << zzz_vproto_internal_pack_publishedfiledetails_reaction(x, 70)
	}
	return res
}

pub fn publishedfiledetails_unpack(buf []byte) ?PublishedFileDetails {
	mut res := zzz_vproto_internal_new_publishedfiledetails()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.creator = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_appid = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_appid = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_shortcutid = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_file_size = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_url = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_url = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtubevideoid = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent_file = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent_preview = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_description = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.short_description = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			20 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			21 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			22 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			23 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_file = v
				i = ii
			}
			24 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_accepted = v
				i = ii
			}
			25 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.show_subscribe_all = v
				i = ii
			}
			26 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_comments_developer = v
				i = ii
			}
			27 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_comments_public = v
				i = ii
			}
			28 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.banned = v
				i = ii
			}
			29 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ban_reason = v
				i = ii
			}
			30 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.banner = v
				i = ii
			}
			31 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_be_deleted = v
				i = ii
			}
			32 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.incompatible = v
				i = ii
			}
			33 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.app_name = v
				i = ii
			}
			34 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			35 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_subscribe = v
				i = ii
			}
			36 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.subscriptions = v
				i = ii
			}
			37 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.favorited = v
				i = ii
			}
			38 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.followers = v
				i = ii
			}
			39 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_subscriptions = v
				i = ii
			}
			40 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_favorited = v
				i = ii
			}
			41 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_followers = v
				i = ii
			}
			62 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_playtime = v
				i = ii
			}
			63 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_playtime_sessions = v
				i = ii
			}
			42 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.views = v
				i = ii
			}
			43 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_width = v
				i = ii
			}
			44 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_height = v
				i = ii
			}
			45 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.image_url = v
				i = ii
			}
			46 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.spoiler_tag = v
				i = ii
			}
			47 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcutid = v
				i = ii
			}
			48 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcutname = v
				i = ii
			}
			49 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_children = v
				i = ii
			}
			50 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_reports = v
				i = ii
			}
			51 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_preview(cur_buf,
					tag_wiretype.wire_type)?
				res.previews << v
				i = ii
			}
			52 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_tag(cur_buf,
					tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			53 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_child(cur_buf,
					tag_wiretype.wire_type)?
				res.children << v
				i = ii
			}
			54 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_kvtag(cur_buf,
					tag_wiretype.wire_type)?
				res.kvtags << v
				i = ii
			}
			55 {
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_votedata(cur_buf,
					tag_wiretype.wire_type)?
				res.vote_data = v
				i = ii
			}
			64 {
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_playtimestats(cur_buf,
					tag_wiretype.wire_type)?
				res.playtime_stats = v
				i = ii
			}
			56 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_subscribed = v
				i = ii
			}
			57 {
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_forsaledata(cur_buf,
					tag_wiretype.wire_type)?
				res.for_sale_data = v
				i = ii
			}
			58 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			61 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			65 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.maybe_inappropriate_sex = v
				i = ii
			}
			66 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.maybe_inappropriate_violence = v
				i = ii
			}
			67 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.revision_change_number = v
				i = ii
			}
			68 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			69 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.available_revisions << v
				i = ii
			}
			70 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_reaction(cur_buf,
					tag_wiretype.wire_type)?
				res.reactions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a PublishedFileDetails) eq(b PublishedFileDetails) bool {
	return true && a.result == b.result &&
		a.publishedfileid == b.publishedfileid &&
		a.creator == b.creator && a.creator_appid == b.creator_appid &&
		a.consumer_appid == b.consumer_appid &&
		a.consumer_shortcutid == b.consumer_shortcutid &&
		a.filename == b.filename && a.file_size == b.file_size &&
		a.preview_file_size == b.preview_file_size &&
		a.file_url == b.file_url && a.preview_url == b.preview_url &&
		a.youtubevideoid == b.youtubevideoid &&
		a.url == b.url && a.hcontent_file == b.hcontent_file &&
		a.hcontent_preview == b.hcontent_preview &&
		a.title == b.title && a.file_description == b.file_description &&
		a.short_description == b.short_description &&
		a.time_created == b.time_created &&
		a.time_updated == b.time_updated &&
		a.visibility == b.visibility && a.flags == b.flags &&
		a.workshop_file == b.workshop_file &&
		a.workshop_accepted == b.workshop_accepted &&
		a.show_subscribe_all == b.show_subscribe_all &&
		a.num_comments_developer == b.num_comments_developer &&
		a.num_comments_public == b.num_comments_public &&
		a.banned == b.banned && a.ban_reason == b.ban_reason &&
		a.banner == b.banner && a.can_be_deleted == b.can_be_deleted &&
		a.incompatible == b.incompatible &&
		a.app_name == b.app_name && a.file_type == b.file_type &&
		a.can_subscribe == b.can_subscribe &&
		a.subscriptions == b.subscriptions &&
		a.favorited == b.favorited && a.followers == b.followers &&
		a.lifetime_subscriptions == b.lifetime_subscriptions &&
		a.lifetime_favorited == b.lifetime_favorited &&
		a.lifetime_followers == b.lifetime_followers &&
		a.lifetime_playtime == b.lifetime_playtime &&
		a.lifetime_playtime_sessions == b.lifetime_playtime_sessions &&
		a.views == b.views && a.image_width == b.image_width &&
		a.image_height == b.image_height &&
		a.image_url == b.image_url && a.spoiler_tag == b.spoiler_tag &&
		a.shortcutid == b.shortcutid && a.shortcutname == b.shortcutname &&
		a.num_children == b.num_children &&
		a.num_reports == b.num_reports && a.previews.eq(b.previews) && a.tags.eq(b.tags) && a.children.eq(b.children) &&
		a.kvtags.eq(b.kvtags) && a.vote_data.eq(b.vote_data) && a.playtime_stats.eq(b.playtime_stats) &&
		a.time_subscribed == b.time_subscribed && a.for_sale_data.eq(b.for_sale_data) &&
		a.metadata == b.metadata && a.language == b.language &&
		a.maybe_inappropriate_sex == b.maybe_inappropriate_sex &&
		a.maybe_inappropriate_violence == b.maybe_inappropriate_violence &&
		a.revision_change_number == b.revision_change_number &&
		a.revision == b.revision &&
		a.available_revisions == b.available_revisions && a.reactions.eq(b.reactions)
}

[inline]
pub fn (a PublishedFileDetails) ne(b PublishedFileDetails) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []PublishedFileDetails) eq(b []PublishedFileDetails) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []PublishedFileDetails) ne(b []PublishedFileDetails) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_publishedfiledetails() PublishedFileDetails {
	return PublishedFileDetails{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_publishedfiledetails(o PublishedFileDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_publishedfiledetails(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetDetails_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	publishedfiledetails []PublishedFileDetails
}

pub fn (o &CPublishedFile_GetDetails_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.publishedfiledetails {
		res << zzz_vproto_internal_pack_publishedfiledetails(x, 1)
	}
	return res
}

pub fn cpublishedfile_getdetails_response_unpack(buf []byte) ?CPublishedFile_GetDetails_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getdetails_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
				res.publishedfiledetails << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetDetails_Response) eq(b CPublishedFile_GetDetails_Response) bool {
	return true && a.publishedfiledetails.eq(b.publishedfiledetails)
}

[inline]
pub fn (a CPublishedFile_GetDetails_Response) ne(b CPublishedFile_GetDetails_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetDetails_Response) eq(b []CPublishedFile_GetDetails_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetDetails_Response) ne(b []CPublishedFile_GetDetails_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getdetails_response() CPublishedFile_GetDetails_Response {
	return CPublishedFile_GetDetails_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getdetails_response(o CPublishedFile_GetDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getdetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getdetails_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Request_WorkshopItem {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	published_file_id u64
	time_updated      u32
	desired_revision  EPublishedFileRevision = .k_epublishedfilerevision_default
}

pub fn (o &CPublishedFile_GetItemInfo_Request_WorkshopItem) pack() []byte {
	mut res := []byte{}
	if o.published_file_id != u64(0) {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.time_updated != u32(0) {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	if o.desired_revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 3)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_request_workshopitem_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Request_WorkshopItem {
	mut res := zzz_vproto_internal_new_cpublishedfile_getiteminfo_request_workshopitem()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Request_WorkshopItem) eq(b CPublishedFile_GetItemInfo_Request_WorkshopItem) bool {
	return true && a.published_file_id == b.published_file_id &&
		a.time_updated == b.time_updated &&
		a.desired_revision == b.desired_revision
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Request_WorkshopItem) ne(b CPublishedFile_GetItemInfo_Request_WorkshopItem) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Request_WorkshopItem) eq(b []CPublishedFile_GetItemInfo_Request_WorkshopItem) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Request_WorkshopItem) ne(b []CPublishedFile_GetItemInfo_Request_WorkshopItem) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_request_workshopitem() CPublishedFile_GetItemInfo_Request_WorkshopItem {
	return CPublishedFile_GetItemInfo_Request_WorkshopItem{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_request_workshopitem(o CPublishedFile_GetItemInfo_Request_WorkshopItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_request_workshopitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Request_WorkshopItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_request_workshopitem_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	last_time_updated u32
	workshop_items    []CPublishedFile_GetItemInfo_Request_WorkshopItem
}

pub fn (o &CPublishedFile_GetItemInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.last_time_updated != u32(0) {
		res << vproto.pack_uint32_field(o.last_time_updated, 2)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res << zzz_vproto_internal_pack_cpublishedfile_getiteminfo_request_workshopitem(x, 3)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_request_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getiteminfo_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_updated = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_request_workshopitem(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Request) eq(b CPublishedFile_GetItemInfo_Request) bool {
	return true && a.app_id == b.app_id &&
		a.last_time_updated == b.last_time_updated && a.workshop_items.eq(b.workshop_items)
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Request) ne(b CPublishedFile_GetItemInfo_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Request) eq(b []CPublishedFile_GetItemInfo_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Request) ne(b []CPublishedFile_GetItemInfo_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_request() CPublishedFile_GetItemInfo_Request {
	return CPublishedFile_GetItemInfo_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_request(o CPublishedFile_GetItemInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	published_file_id u64
	time_updated      u32
	manifest_id       u64
	flags             u32
}

pub fn (o &CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) pack() []byte {
	mut res := []byte{}
	if o.published_file_id != u64(0) {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.time_updated != u32(0) {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	if o.manifest_id != u64(0) {
		res << vproto.pack_64bit_field(o.manifest_id, 3)
	}
	if o.flags != u32(0) {
		res << vproto.pack_uint32_field(o.flags, 4)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_response_workshopiteminfo_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
	mut res := zzz_vproto_internal_new_cpublishedfile_getiteminfo_response_workshopiteminfo()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.manifest_id = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) eq(b CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) bool {
	return true && a.published_file_id == b.published_file_id &&
		a.time_updated == b.time_updated &&
		a.manifest_id == b.manifest_id && a.flags == b.flags
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) ne(b CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) eq(b []CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) ne(b []CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_response_workshopiteminfo() CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
	return CPublishedFile_GetItemInfo_Response_WorkshopItemInfo{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_response_workshopiteminfo(o CPublishedFile_GetItemInfo_Response_WorkshopItemInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_response_workshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_response_workshopiteminfo_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	update_time    u32
	workshop_items []CPublishedFile_GetItemInfo_Response_WorkshopItemInfo
	private_items  []u64
}

pub fn (o &CPublishedFile_GetItemInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.update_time != u32(0) {
		res << vproto.pack_uint32_field(o.update_time, 1)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res << zzz_vproto_internal_pack_cpublishedfile_getiteminfo_response_workshopiteminfo(x, 2)
	}
	// [packed=false]
	for _, x in o.private_items {
		res << vproto.pack_64bit_field(x, 3)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_response_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getiteminfo_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_time = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_response_workshopiteminfo(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.private_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Response) eq(b CPublishedFile_GetItemInfo_Response) bool {
	return true && a.update_time == b.update_time && a.workshop_items.eq(b.workshop_items) &&
		a.private_items == b.private_items
}

[inline]
pub fn (a CPublishedFile_GetItemInfo_Response) ne(b CPublishedFile_GetItemInfo_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Response) eq(b []CPublishedFile_GetItemInfo_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetItemInfo_Response) ne(b []CPublishedFile_GetItemInfo_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_response() CPublishedFile_GetItemInfo_Response {
	return CPublishedFile_GetItemInfo_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_response(o CPublishedFile_GetItemInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Request_KVTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
}

pub fn (o &CPublishedFile_GetUserFiles_Request_KVTag) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_request_kvtag_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Request_KVTag {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuserfiles_request_kvtag()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Request_KVTag) eq(b CPublishedFile_GetUserFiles_Request_KVTag) bool {
	return true && a.key == b.key && a.value == b.value
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Request_KVTag) ne(b CPublishedFile_GetUserFiles_Request_KVTag) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Request_KVTag) eq(b []CPublishedFile_GetUserFiles_Request_KVTag) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Request_KVTag) ne(b []CPublishedFile_GetUserFiles_Request_KVTag) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_request_kvtag() CPublishedFile_GetUserFiles_Request_KVTag {
	return CPublishedFile_GetUserFiles_Request_KVTag{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_kvtag(o CPublishedFile_GetUserFiles_Request_KVTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_kvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Request_KVTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_request_kvtag_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Request_TagGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tags           []string
}

pub fn (o &CPublishedFile_GetUserFiles_Request_TagGroup) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_request_taggroup_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Request_TagGroup {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuserfiles_request_taggroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Request_TagGroup) eq(b CPublishedFile_GetUserFiles_Request_TagGroup) bool {
	return true && a.tags == b.tags
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Request_TagGroup) ne(b CPublishedFile_GetUserFiles_Request_TagGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Request_TagGroup) eq(b []CPublishedFile_GetUserFiles_Request_TagGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Request_TagGroup) ne(b []CPublishedFile_GetUserFiles_Request_TagGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_request_taggroup() CPublishedFile_GetUserFiles_Request_TagGroup {
	return CPublishedFile_GetUserFiles_Request_TagGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_taggroup(o CPublishedFile_GetUserFiles_Request_TagGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_taggroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Request_TagGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_request_taggroup_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Request {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steamid                  u64
	appid                    u32
	page                     u32 = 1
	numperpage               u32 = 1
	@type                    string = myfiles
	sortmethod               string = lastupdated
	privacy                  u32
	requiredtags             []string
	excludedtags             []string
	required_kv_tags         []CPublishedFile_GetUserFiles_Request_KVTag
	filetype                 u32
	creator_appid            u32
	match_cloud_filename     string
	cache_max_age_seconds    u32 = 0
	language                 int = 0
	taggroups                []CPublishedFile_GetUserFiles_Request_TagGroup
	totalonly                bool
	ids_only                 bool
	return_vote_data         bool = true
	return_tags              bool
	return_kv_tags           bool = true
	return_previews          bool
	return_children          bool
	return_short_description bool = true
	return_for_sale_data     bool
	return_metadata          bool = false
	return_playtime_stats    u32
	strip_description_bbcode bool
	return_reactions         bool = false
	desired_revision         EPublishedFileRevision = .k_epublishedfilerevision_default
}

pub fn (o &CPublishedFile_GetUserFiles_Request) pack() []byte {
	mut res := []byte{}
	if o.steamid != u64(0) {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.page != u32(0) {
		res << vproto.pack_uint32_field(o.page, 4)
	}
	if o.numperpage != u32(0) {
		res << vproto.pack_uint32_field(o.numperpage, 5)
	}
	if o.@type != '' {
		res << vproto.pack_string_field(o.@type, 6)
	}
	if o.sortmethod != '' {
		res << vproto.pack_string_field(o.sortmethod, 7)
	}
	if o.privacy != u32(0) {
		res << vproto.pack_uint32_field(o.privacy, 9)
	}
	// [packed=false]
	for _, x in o.requiredtags {
		res << vproto.pack_string_field(x, 10)
	}
	// [packed=false]
	for _, x in o.excludedtags {
		res << vproto.pack_string_field(x, 11)
	}
	// [packed=false]
	for _, x in o.required_kv_tags {
		res << zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_kvtag(x, 30)
	}
	if o.filetype != u32(0) {
		res << vproto.pack_uint32_field(o.filetype, 14)
	}
	if o.creator_appid != u32(0) {
		res << vproto.pack_uint32_field(o.creator_appid, 15)
	}
	if o.match_cloud_filename != '' {
		res << vproto.pack_string_field(o.match_cloud_filename, 16)
	}
	if o.cache_max_age_seconds != u32(0) {
		res << vproto.pack_uint32_field(o.cache_max_age_seconds, 27)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 29)
	}
	// [packed=false]
	for _, x in o.taggroups {
		res << zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_taggroup(x, 34)
	}
	if o.totalonly != bool(0) {
		res << vproto.pack_bool_field(o.totalonly, 17)
	}
	if o.ids_only != bool(0) {
		res << vproto.pack_bool_field(o.ids_only, 18)
	}
	if o.return_vote_data != bool(0) {
		res << vproto.pack_bool_field(o.return_vote_data, 19)
	}
	if o.return_tags != bool(0) {
		res << vproto.pack_bool_field(o.return_tags, 20)
	}
	if o.return_kv_tags != bool(0) {
		res << vproto.pack_bool_field(o.return_kv_tags, 21)
	}
	if o.return_previews != bool(0) {
		res << vproto.pack_bool_field(o.return_previews, 22)
	}
	if o.return_children != bool(0) {
		res << vproto.pack_bool_field(o.return_children, 23)
	}
	if o.return_short_description != bool(0) {
		res << vproto.pack_bool_field(o.return_short_description, 24)
	}
	if o.return_for_sale_data != bool(0) {
		res << vproto.pack_bool_field(o.return_for_sale_data, 26)
	}
	if o.return_metadata != bool(0) {
		res << vproto.pack_bool_field(o.return_metadata, 28)
	}
	if o.return_playtime_stats != u32(0) {
		res << vproto.pack_uint32_field(o.return_playtime_stats, 31)
	}
	if o.strip_description_bbcode != bool(0) {
		res << vproto.pack_bool_field(o.strip_description_bbcode, 32)
	}
	if o.return_reactions != bool(0) {
		res << vproto.pack_bool_field(o.return_reactions, 35)
	}
	if o.desired_revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 33)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_request_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuserfiles_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.numperpage = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sortmethod = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.requiredtags << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excludedtags << v
				i = ii
			}
			30 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_kvtag(cur_buf,
					tag_wiretype.wire_type)?
				res.required_kv_tags << v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filetype = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_appid = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.match_cloud_filename = v
				i = ii
			}
			27 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_max_age_seconds = v
				i = ii
			}
			29 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			34 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_taggroup(cur_buf,
					tag_wiretype.wire_type)?
				res.taggroups << v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.totalonly = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ids_only = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_vote_data = v
				i = ii
			}
			20 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_tags = v
				i = ii
			}
			21 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_kv_tags = v
				i = ii
			}
			22 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_previews = v
				i = ii
			}
			23 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_children = v
				i = ii
			}
			24 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_short_description = v
				i = ii
			}
			26 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_for_sale_data = v
				i = ii
			}
			28 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_metadata = v
				i = ii
			}
			31 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.return_playtime_stats = v
				i = ii
			}
			32 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.strip_description_bbcode = v
				i = ii
			}
			35 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_reactions = v
				i = ii
			}
			33 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Request) eq(b CPublishedFile_GetUserFiles_Request) bool {
	return true && a.steamid == b.steamid &&
		a.appid == b.appid && a.page == b.page &&
		a.numperpage == b.numperpage && a.@type == b.@type &&
		a.sortmethod == b.sortmethod && a.privacy == b.privacy &&
		a.requiredtags == b.requiredtags &&
		a.excludedtags == b.excludedtags && a.required_kv_tags.eq(b.required_kv_tags) &&
		a.filetype == b.filetype && a.creator_appid == b.creator_appid &&
		a.match_cloud_filename == b.match_cloud_filename &&
		a.cache_max_age_seconds == b.cache_max_age_seconds &&
		a.language == b.language && a.taggroups.eq(b.taggroups) &&
		a.totalonly == b.totalonly && a.ids_only == b.ids_only &&
		a.return_vote_data == b.return_vote_data &&
		a.return_tags == b.return_tags && a.return_kv_tags == b.return_kv_tags &&
		a.return_previews == b.return_previews &&
		a.return_children == b.return_children &&
		a.return_short_description == b.return_short_description &&
		a.return_for_sale_data == b.return_for_sale_data &&
		a.return_metadata == b.return_metadata &&
		a.return_playtime_stats == b.return_playtime_stats &&
		a.strip_description_bbcode == b.strip_description_bbcode &&
		a.return_reactions == b.return_reactions &&
		a.desired_revision == b.desired_revision
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Request) ne(b CPublishedFile_GetUserFiles_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Request) eq(b []CPublishedFile_GetUserFiles_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Request) ne(b []CPublishedFile_GetUserFiles_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_request() CPublishedFile_GetUserFiles_Request {
	return CPublishedFile_GetUserFiles_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request(o CPublishedFile_GetUserFiles_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Response_App {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	name           string
	shortcutid     u32
	private        bool
}

pub fn (o &CPublishedFile_GetUserFiles_Response_App) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.shortcutid != u32(0) {
		res << vproto.pack_uint32_field(o.shortcutid, 3)
	}
	if o.private != bool(0) {
		res << vproto.pack_bool_field(o.private, 4)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_response_app_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Response_App {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuserfiles_response_app()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcutid = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Response_App) eq(b CPublishedFile_GetUserFiles_Response_App) bool {
	return true && a.appid == b.appid &&
		a.name == b.name && a.shortcutid == b.shortcutid &&
		a.private == b.private
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Response_App) ne(b CPublishedFile_GetUserFiles_Response_App) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Response_App) eq(b []CPublishedFile_GetUserFiles_Response_App) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Response_App) ne(b []CPublishedFile_GetUserFiles_Response_App) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_response_app() CPublishedFile_GetUserFiles_Response_App {
	return CPublishedFile_GetUserFiles_Response_App{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_response_app(o CPublishedFile_GetUserFiles_Response_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_response_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Response_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_response_app_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	total                u32
	startindex           u32
	publishedfiledetails []PublishedFileDetails
	apps                 []CPublishedFile_GetUserFiles_Response_App
}

pub fn (o &CPublishedFile_GetUserFiles_Response) pack() []byte {
	mut res := []byte{}
	if o.total != u32(0) {
		res << vproto.pack_uint32_field(o.total, 1)
	}
	if o.startindex != u32(0) {
		res << vproto.pack_uint32_field(o.startindex, 2)
	}
	// [packed=false]
	for _, x in o.publishedfiledetails {
		res << zzz_vproto_internal_pack_publishedfiledetails(x, 3)
	}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cpublishedfile_getuserfiles_response_app(x, 4)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_response_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuserfiles_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.startindex = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
				res.publishedfiledetails << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_response_app(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Response) eq(b CPublishedFile_GetUserFiles_Response) bool {
	return true && a.total == b.total &&
		a.startindex == b.startindex && a.publishedfiledetails.eq(b.publishedfiledetails) && a.apps.eq(b.apps)
}

[inline]
pub fn (a CPublishedFile_GetUserFiles_Response) ne(b CPublishedFile_GetUserFiles_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Response) eq(b []CPublishedFile_GetUserFiles_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserFiles_Response) ne(b []CPublishedFile_GetUserFiles_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_response() CPublishedFile_GetUserFiles_Response {
	return CPublishedFile_GetUserFiles_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_response(o CPublishedFile_GetUserFiles_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AreFilesInSubscriptionList_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	publishedfileids []u64
	listtype         u32
	filetype         u32
	workshopfiletype u32
}

pub fn (o &CPublishedFile_AreFilesInSubscriptionList_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_64bit_field(x, 2)
	}
	if o.listtype != u32(0) {
		res << vproto.pack_uint32_field(o.listtype, 3)
	}
	if o.filetype != u32(0) {
		res << vproto.pack_uint32_field(o.filetype, 4)
	}
	if o.workshopfiletype != u32(0) {
		res << vproto.pack_uint32_field(o.workshopfiletype, 5)
	}
	return res
}

pub fn cpublishedfile_arefilesinsubscriptionlist_request_unpack(buf []byte) ?CPublishedFile_AreFilesInSubscriptionList_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.listtype = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filetype = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.workshopfiletype = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_AreFilesInSubscriptionList_Request) eq(b CPublishedFile_AreFilesInSubscriptionList_Request) bool {
	return true && a.appid == b.appid &&
		a.publishedfileids == b.publishedfileids &&
		a.listtype == b.listtype && a.filetype == b.filetype &&
		a.workshopfiletype == b.workshopfiletype
}

[inline]
pub fn (a CPublishedFile_AreFilesInSubscriptionList_Request) ne(b CPublishedFile_AreFilesInSubscriptionList_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AreFilesInSubscriptionList_Request) eq(b []CPublishedFile_AreFilesInSubscriptionList_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AreFilesInSubscriptionList_Request) ne(b []CPublishedFile_AreFilesInSubscriptionList_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_request() CPublishedFile_AreFilesInSubscriptionList_Request {
	return CPublishedFile_AreFilesInSubscriptionList_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_request(o CPublishedFile_AreFilesInSubscriptionList_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AreFilesInSubscriptionList_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_arefilesinsubscriptionlist_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AreFilesInSubscriptionList_Response_InList {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	inlist          bool
}

pub fn (o &CPublishedFile_AreFilesInSubscriptionList_Response_InList) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.inlist != bool(0) {
		res << vproto.pack_bool_field(o.inlist, 2)
	}
	return res
}

pub fn cpublishedfile_arefilesinsubscriptionlist_response_inlist_unpack(buf []byte) ?CPublishedFile_AreFilesInSubscriptionList_Response_InList {
	mut res := zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_response_inlist()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.inlist = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_AreFilesInSubscriptionList_Response_InList) eq(b CPublishedFile_AreFilesInSubscriptionList_Response_InList) bool {
	return true && a.publishedfileid == b.publishedfileid && a.inlist == b.inlist
}

[inline]
pub fn (a CPublishedFile_AreFilesInSubscriptionList_Response_InList) ne(b CPublishedFile_AreFilesInSubscriptionList_Response_InList) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AreFilesInSubscriptionList_Response_InList) eq(b []CPublishedFile_AreFilesInSubscriptionList_Response_InList) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AreFilesInSubscriptionList_Response_InList) ne(b []CPublishedFile_AreFilesInSubscriptionList_Response_InList) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_response_inlist() CPublishedFile_AreFilesInSubscriptionList_Response_InList {
	return CPublishedFile_AreFilesInSubscriptionList_Response_InList{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(o CPublishedFile_AreFilesInSubscriptionList_Response_InList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AreFilesInSubscriptionList_Response_InList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_arefilesinsubscriptionlist_response_inlist_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AreFilesInSubscriptionList_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CPublishedFile_AreFilesInSubscriptionList_Response_InList
}

pub fn (o &CPublishedFile_AreFilesInSubscriptionList_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(x, 1)
	}
	return res
}

pub fn cpublishedfile_arefilesinsubscriptionlist_response_unpack(buf []byte) ?CPublishedFile_AreFilesInSubscriptionList_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(cur_buf,
					tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_AreFilesInSubscriptionList_Response) eq(b CPublishedFile_AreFilesInSubscriptionList_Response) bool {
	return true && a.files.eq(b.files)
}

[inline]
pub fn (a CPublishedFile_AreFilesInSubscriptionList_Response) ne(b CPublishedFile_AreFilesInSubscriptionList_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AreFilesInSubscriptionList_Response) eq(b []CPublishedFile_AreFilesInSubscriptionList_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AreFilesInSubscriptionList_Response) ne(b []CPublishedFile_AreFilesInSubscriptionList_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_response() CPublishedFile_AreFilesInSubscriptionList_Response {
	return CPublishedFile_AreFilesInSubscriptionList_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_response(o CPublishedFile_AreFilesInSubscriptionList_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AreFilesInSubscriptionList_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_arefilesinsubscriptionlist_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Update_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	publishedfileid  u64
	title            string
	file_description string
	visibility       u32
	tags             []string
	filename         string
	preview_filename string
	image_width      u32
	image_height     u32
}

pub fn (o &CPublishedFile_Update_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_64bit_field(o.publishedfileid, 2)
	}
	if o.title != '' {
		res << vproto.pack_string_field(o.title, 3)
	}
	if o.file_description != '' {
		res << vproto.pack_string_field(o.file_description, 4)
	}
	if o.visibility != u32(0) {
		res << vproto.pack_uint32_field(o.visibility, 5)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 6)
	}
	if o.filename != '' {
		res << vproto.pack_string_field(o.filename, 7)
	}
	if o.preview_filename != '' {
		res << vproto.pack_string_field(o.preview_filename, 8)
	}
	if o.image_width != u32(0) {
		res << vproto.pack_uint32_field(o.image_width, 15)
	}
	if o.image_height != u32(0) {
		res << vproto.pack_uint32_field(o.image_height, 16)
	}
	return res
}

pub fn cpublishedfile_update_request_unpack(buf []byte) ?CPublishedFile_Update_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_update_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_description = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_filename = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_width = v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_Update_Request) eq(b CPublishedFile_Update_Request) bool {
	return true && a.appid == b.appid &&
		a.publishedfileid == b.publishedfileid &&
		a.title == b.title && a.file_description == b.file_description &&
		a.visibility == b.visibility && a.tags == b.tags &&
		a.filename == b.filename && a.preview_filename == b.preview_filename &&
		a.image_width == b.image_width && a.image_height == b.image_height
}

[inline]
pub fn (a CPublishedFile_Update_Request) ne(b CPublishedFile_Update_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Update_Request) eq(b []CPublishedFile_Update_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Update_Request) ne(b []CPublishedFile_Update_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_update_request() CPublishedFile_Update_Request {
	return CPublishedFile_Update_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_update_request(o CPublishedFile_Update_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_update_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Update_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_update_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Update_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_Update_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_update_response_unpack(buf []byte) ?CPublishedFile_Update_Response {
	res := zzz_vproto_internal_new_cpublishedfile_update_response()
	return res
}

[inline]
pub fn (a CPublishedFile_Update_Response) eq(b CPublishedFile_Update_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_Update_Response) ne(b CPublishedFile_Update_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_Update_Response) eq(b []CPublishedFile_Update_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_Update_Response) ne(b []CPublishedFile_Update_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_update_response() CPublishedFile_Update_Response {
	return CPublishedFile_Update_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_update_response(o CPublishedFile_Update_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_update_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Update_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_update_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistoryEntry_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	timestamp       u32
	language        int
}

pub fn (o &CPublishedFile_GetChangeHistoryEntry_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.timestamp != u32(0) {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 3)
	}
	return res
}

pub fn cpublishedfile_getchangehistoryentry_request_unpack(buf []byte) ?CPublishedFile_GetChangeHistoryEntry_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getchangehistoryentry_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetChangeHistoryEntry_Request) eq(b CPublishedFile_GetChangeHistoryEntry_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.timestamp == b.timestamp && a.language == b.language
}

[inline]
pub fn (a CPublishedFile_GetChangeHistoryEntry_Request) ne(b CPublishedFile_GetChangeHistoryEntry_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistoryEntry_Request) eq(b []CPublishedFile_GetChangeHistoryEntry_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistoryEntry_Request) ne(b []CPublishedFile_GetChangeHistoryEntry_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistoryentry_request() CPublishedFile_GetChangeHistoryEntry_Request {
	return CPublishedFile_GetChangeHistoryEntry_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistoryentry_request(o CPublishedFile_GetChangeHistoryEntry_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistoryentry_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistoryEntry_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistoryentry_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistoryEntry_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	change_description string
	language           int
}

pub fn (o &CPublishedFile_GetChangeHistoryEntry_Response) pack() []byte {
	mut res := []byte{}
	if o.change_description != '' {
		res << vproto.pack_string_field(o.change_description, 1)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 2)
	}
	return res
}

pub fn cpublishedfile_getchangehistoryentry_response_unpack(buf []byte) ?CPublishedFile_GetChangeHistoryEntry_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getchangehistoryentry_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.change_description = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetChangeHistoryEntry_Response) eq(b CPublishedFile_GetChangeHistoryEntry_Response) bool {
	return true && a.change_description == b.change_description && a.language == b.language
}

[inline]
pub fn (a CPublishedFile_GetChangeHistoryEntry_Response) ne(b CPublishedFile_GetChangeHistoryEntry_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistoryEntry_Response) eq(b []CPublishedFile_GetChangeHistoryEntry_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistoryEntry_Response) ne(b []CPublishedFile_GetChangeHistoryEntry_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistoryentry_response() CPublishedFile_GetChangeHistoryEntry_Response {
	return CPublishedFile_GetChangeHistoryEntry_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistoryentry_response(o CPublishedFile_GetChangeHistoryEntry_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistoryentry_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistoryEntry_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistoryentry_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistory_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	total_only      bool
	startindex      u32
	count           u32
	language        int = 0
}

pub fn (o &CPublishedFile_GetChangeHistory_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.total_only != bool(0) {
		res << vproto.pack_bool_field(o.total_only, 2)
	}
	if o.startindex != u32(0) {
		res << vproto.pack_uint32_field(o.startindex, 3)
	}
	if o.count != u32(0) {
		res << vproto.pack_uint32_field(o.count, 4)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 5)
	}
	return res
}

pub fn cpublishedfile_getchangehistory_request_unpack(buf []byte) ?CPublishedFile_GetChangeHistory_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getchangehistory_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.total_only = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.startindex = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetChangeHistory_Request) eq(b CPublishedFile_GetChangeHistory_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.total_only == b.total_only && a.startindex == b.startindex &&
		a.count == b.count && a.language == b.language
}

[inline]
pub fn (a CPublishedFile_GetChangeHistory_Request) ne(b CPublishedFile_GetChangeHistory_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistory_Request) eq(b []CPublishedFile_GetChangeHistory_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistory_Request) ne(b []CPublishedFile_GetChangeHistory_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistory_request() CPublishedFile_GetChangeHistory_Request {
	return CPublishedFile_GetChangeHistory_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistory_request(o CPublishedFile_GetChangeHistory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistory_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistory_Response_ChangeLog {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	timestamp          u32
	change_description string
	language           int
}

pub fn (o &CPublishedFile_GetChangeHistory_Response_ChangeLog) pack() []byte {
	mut res := []byte{}
	if o.timestamp != u32(0) {
		res << vproto.pack_uint32_field(o.timestamp, 1)
	}
	if o.change_description != '' {
		res << vproto.pack_string_field(o.change_description, 2)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 3)
	}
	return res
}

pub fn cpublishedfile_getchangehistory_response_changelog_unpack(buf []byte) ?CPublishedFile_GetChangeHistory_Response_ChangeLog {
	mut res := zzz_vproto_internal_new_cpublishedfile_getchangehistory_response_changelog()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.change_description = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetChangeHistory_Response_ChangeLog) eq(b CPublishedFile_GetChangeHistory_Response_ChangeLog) bool {
	return true && a.timestamp == b.timestamp &&
		a.change_description == b.change_description &&
		a.language == b.language
}

[inline]
pub fn (a CPublishedFile_GetChangeHistory_Response_ChangeLog) ne(b CPublishedFile_GetChangeHistory_Response_ChangeLog) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistory_Response_ChangeLog) eq(b []CPublishedFile_GetChangeHistory_Response_ChangeLog) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistory_Response_ChangeLog) ne(b []CPublishedFile_GetChangeHistory_Response_ChangeLog) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistory_response_changelog() CPublishedFile_GetChangeHistory_Response_ChangeLog {
	return CPublishedFile_GetChangeHistory_Response_ChangeLog{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistory_response_changelog(o CPublishedFile_GetChangeHistory_Response_ChangeLog, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_response_changelog(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistory_Response_ChangeLog) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistory_response_changelog_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistory_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	changes        []CPublishedFile_GetChangeHistory_Response_ChangeLog
	total          u32
}

pub fn (o &CPublishedFile_GetChangeHistory_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.changes {
		res << zzz_vproto_internal_pack_cpublishedfile_getchangehistory_response_changelog(x, 1)
	}
	if o.total != u32(0) {
		res << vproto.pack_uint32_field(o.total, 2)
	}
	return res
}

pub fn cpublishedfile_getchangehistory_response_unpack(buf []byte) ?CPublishedFile_GetChangeHistory_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getchangehistory_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_response_changelog(cur_buf,
					tag_wiretype.wire_type)?
				res.changes << v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetChangeHistory_Response) eq(b CPublishedFile_GetChangeHistory_Response) bool {
	return true && a.changes.eq(b.changes) && a.total == b.total
}

[inline]
pub fn (a CPublishedFile_GetChangeHistory_Response) ne(b CPublishedFile_GetChangeHistory_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistory_Response) eq(b []CPublishedFile_GetChangeHistory_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetChangeHistory_Response) ne(b []CPublishedFile_GetChangeHistory_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistory_response() CPublishedFile_GetChangeHistory_Response {
	return CPublishedFile_GetChangeHistory_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistory_response(o CPublishedFile_GetChangeHistory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistory_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RefreshVotingQueue_Request {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	appid              u32
	matching_file_type u32
	tags               []string
	match_all_tags     bool = true
	excluded_tags      []string
	desired_queue_size u32
	desired_revision   EPublishedFileRevision = .k_epublishedfilerevision_default
}

pub fn (o &CPublishedFile_RefreshVotingQueue_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.matching_file_type != u32(0) {
		res << vproto.pack_uint32_field(o.matching_file_type, 2)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 3)
	}
	if o.match_all_tags != bool(0) {
		res << vproto.pack_bool_field(o.match_all_tags, 4)
	}
	// [packed=false]
	for _, x in o.excluded_tags {
		res << vproto.pack_string_field(x, 5)
	}
	if o.desired_queue_size != u32(0) {
		res << vproto.pack_uint32_field(o.desired_queue_size, 6)
	}
	if o.desired_revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 8)
	}
	return res
}

pub fn cpublishedfile_refreshvotingqueue_request_unpack(buf []byte) ?CPublishedFile_RefreshVotingQueue_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_refreshvotingqueue_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.matching_file_type = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.match_all_tags = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excluded_tags << v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.desired_queue_size = v
				i = ii
			}
			8 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_RefreshVotingQueue_Request) eq(b CPublishedFile_RefreshVotingQueue_Request) bool {
	return true && a.appid == b.appid &&
		a.matching_file_type == b.matching_file_type &&
		a.tags == b.tags && a.match_all_tags == b.match_all_tags &&
		a.excluded_tags == b.excluded_tags &&
		a.desired_queue_size == b.desired_queue_size &&
		a.desired_revision == b.desired_revision
}

[inline]
pub fn (a CPublishedFile_RefreshVotingQueue_Request) ne(b CPublishedFile_RefreshVotingQueue_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_RefreshVotingQueue_Request) eq(b []CPublishedFile_RefreshVotingQueue_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_RefreshVotingQueue_Request) ne(b []CPublishedFile_RefreshVotingQueue_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_refreshvotingqueue_request() CPublishedFile_RefreshVotingQueue_Request {
	return CPublishedFile_RefreshVotingQueue_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_refreshvotingqueue_request(o CPublishedFile_RefreshVotingQueue_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_refreshvotingqueue_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RefreshVotingQueue_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_refreshvotingqueue_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RefreshVotingQueue_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_RefreshVotingQueue_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_refreshvotingqueue_response_unpack(buf []byte) ?CPublishedFile_RefreshVotingQueue_Response {
	res := zzz_vproto_internal_new_cpublishedfile_refreshvotingqueue_response()
	return res
}

[inline]
pub fn (a CPublishedFile_RefreshVotingQueue_Response) eq(b CPublishedFile_RefreshVotingQueue_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_RefreshVotingQueue_Response) ne(b CPublishedFile_RefreshVotingQueue_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_RefreshVotingQueue_Response) eq(b []CPublishedFile_RefreshVotingQueue_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_RefreshVotingQueue_Response) ne(b []CPublishedFile_RefreshVotingQueue_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_refreshvotingqueue_response() CPublishedFile_RefreshVotingQueue_Response {
	return CPublishedFile_RefreshVotingQueue_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_refreshvotingqueue_response(o CPublishedFile_RefreshVotingQueue_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_refreshvotingqueue_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RefreshVotingQueue_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_refreshvotingqueue_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Request_KVTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	value          string
}

pub fn (o &CPublishedFile_QueryFiles_Request_KVTag) pack() []byte {
	mut res := []byte{}
	if o.key != '' {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.value != '' {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cpublishedfile_queryfiles_request_kvtag_unpack(buf []byte) ?CPublishedFile_QueryFiles_Request_KVTag {
	mut res := zzz_vproto_internal_new_cpublishedfile_queryfiles_request_kvtag()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Request_KVTag) eq(b CPublishedFile_QueryFiles_Request_KVTag) bool {
	return true && a.key == b.key && a.value == b.value
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Request_KVTag) ne(b CPublishedFile_QueryFiles_Request_KVTag) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Request_KVTag) eq(b []CPublishedFile_QueryFiles_Request_KVTag) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Request_KVTag) ne(b []CPublishedFile_QueryFiles_Request_KVTag) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_request_kvtag() CPublishedFile_QueryFiles_Request_KVTag {
	return CPublishedFile_QueryFiles_Request_KVTag{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_kvtag(o CPublishedFile_QueryFiles_Request_KVTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_kvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Request_KVTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_request_kvtag_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Request_TagGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tags           []string
}

pub fn (o &CPublishedFile_QueryFiles_Request_TagGroup) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cpublishedfile_queryfiles_request_taggroup_unpack(buf []byte) ?CPublishedFile_QueryFiles_Request_TagGroup {
	mut res := zzz_vproto_internal_new_cpublishedfile_queryfiles_request_taggroup()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Request_TagGroup) eq(b CPublishedFile_QueryFiles_Request_TagGroup) bool {
	return true && a.tags == b.tags
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Request_TagGroup) ne(b CPublishedFile_QueryFiles_Request_TagGroup) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Request_TagGroup) eq(b []CPublishedFile_QueryFiles_Request_TagGroup) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Request_TagGroup) ne(b []CPublishedFile_QueryFiles_Request_TagGroup) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_request_taggroup() CPublishedFile_QueryFiles_Request_TagGroup {
	return CPublishedFile_QueryFiles_Request_TagGroup{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_taggroup(o CPublishedFile_QueryFiles_Request_TagGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_taggroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Request_TagGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_request_taggroup_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Request {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	query_type                u32
	page                      u32
	cursor                    string
	numperpage                u32 = 1
	creator_appid             u32
	appid                     u32
	requiredtags              []string
	excludedtags              []string
	match_all_tags            bool = true
	required_flags            []string
	omitted_flags             []string
	search_text               string
	filetype                  u32
	child_publishedfileid     u64
	days                      u32
	include_recent_votes_only bool
	cache_max_age_seconds     u32 = 0
	language                  int = 0
	required_kv_tags          []CPublishedFile_QueryFiles_Request_KVTag
	taggroups                 []CPublishedFile_QueryFiles_Request_TagGroup
	totalonly                 bool
	ids_only                  bool
	return_vote_data          bool
	return_tags               bool
	return_kv_tags            bool
	return_previews           bool
	return_children           bool
	return_short_description  bool
	return_for_sale_data      bool
	return_metadata           bool = false
	return_playtime_stats     u32
	return_details            bool
	strip_description_bbcode  bool
	desired_revision          EPublishedFileRevision = .k_epublishedfilerevision_default
	return_reactions          bool = false
}

pub fn (o &CPublishedFile_QueryFiles_Request) pack() []byte {
	mut res := []byte{}
	if o.query_type != u32(0) {
		res << vproto.pack_uint32_field(o.query_type, 1)
	}
	if o.page != u32(0) {
		res << vproto.pack_uint32_field(o.page, 2)
	}
	if o.cursor != '' {
		res << vproto.pack_string_field(o.cursor, 39)
	}
	if o.numperpage != u32(0) {
		res << vproto.pack_uint32_field(o.numperpage, 3)
	}
	if o.creator_appid != u32(0) {
		res << vproto.pack_uint32_field(o.creator_appid, 4)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	// [packed=false]
	for _, x in o.requiredtags {
		res << vproto.pack_string_field(x, 6)
	}
	// [packed=false]
	for _, x in o.excludedtags {
		res << vproto.pack_string_field(x, 7)
	}
	if o.match_all_tags != bool(0) {
		res << vproto.pack_bool_field(o.match_all_tags, 8)
	}
	// [packed=false]
	for _, x in o.required_flags {
		res << vproto.pack_string_field(x, 9)
	}
	// [packed=false]
	for _, x in o.omitted_flags {
		res << vproto.pack_string_field(x, 10)
	}
	if o.search_text != '' {
		res << vproto.pack_string_field(o.search_text, 11)
	}
	if o.filetype != u32(0) {
		res << vproto.pack_uint32_field(o.filetype, 12)
	}
	if o.child_publishedfileid != u64(0) {
		res << vproto.pack_64bit_field(o.child_publishedfileid, 13)
	}
	if o.days != u32(0) {
		res << vproto.pack_uint32_field(o.days, 14)
	}
	if o.include_recent_votes_only != bool(0) {
		res << vproto.pack_bool_field(o.include_recent_votes_only, 15)
	}
	if o.cache_max_age_seconds != u32(0) {
		res << vproto.pack_uint32_field(o.cache_max_age_seconds, 31)
	}
	if o.language != int(0) {
		res << vproto.pack_int32_field(o.language, 33)
	}
	// [packed=false]
	for _, x in o.required_kv_tags {
		res << zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_kvtag(x, 34)
	}
	// [packed=false]
	for _, x in o.taggroups {
		res << zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_taggroup(x, 42)
	}
	if o.totalonly != bool(0) {
		res << vproto.pack_bool_field(o.totalonly, 16)
	}
	if o.ids_only != bool(0) {
		res << vproto.pack_bool_field(o.ids_only, 35)
	}
	if o.return_vote_data != bool(0) {
		res << vproto.pack_bool_field(o.return_vote_data, 17)
	}
	if o.return_tags != bool(0) {
		res << vproto.pack_bool_field(o.return_tags, 18)
	}
	if o.return_kv_tags != bool(0) {
		res << vproto.pack_bool_field(o.return_kv_tags, 19)
	}
	if o.return_previews != bool(0) {
		res << vproto.pack_bool_field(o.return_previews, 20)
	}
	if o.return_children != bool(0) {
		res << vproto.pack_bool_field(o.return_children, 21)
	}
	if o.return_short_description != bool(0) {
		res << vproto.pack_bool_field(o.return_short_description, 22)
	}
	if o.return_for_sale_data != bool(0) {
		res << vproto.pack_bool_field(o.return_for_sale_data, 30)
	}
	if o.return_metadata != bool(0) {
		res << vproto.pack_bool_field(o.return_metadata, 32)
	}
	if o.return_playtime_stats != u32(0) {
		res << vproto.pack_uint32_field(o.return_playtime_stats, 36)
	}
	if o.return_details != bool(0) {
		res << vproto.pack_bool_field(o.return_details, 37)
	}
	if o.strip_description_bbcode != bool(0) {
		res << vproto.pack_bool_field(o.strip_description_bbcode, 38)
	}
	if o.desired_revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 40)
	}
	if o.return_reactions != bool(0) {
		res << vproto.pack_bool_field(o.return_reactions, 43)
	}
	return res
}

pub fn cpublishedfile_queryfiles_request_unpack(buf []byte) ?CPublishedFile_QueryFiles_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_queryfiles_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.query_type = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page = v
				i = ii
			}
			39 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.numperpage = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_appid = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.requiredtags << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excludedtags << v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.match_all_tags = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.required_flags << v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.omitted_flags << v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.search_text = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filetype = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.child_publishedfileid = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.days = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_recent_votes_only = v
				i = ii
			}
			31 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_max_age_seconds = v
				i = ii
			}
			33 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			34 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_kvtag(cur_buf,
					tag_wiretype.wire_type)?
				res.required_kv_tags << v
				i = ii
			}
			42 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_taggroup(cur_buf,
					tag_wiretype.wire_type)?
				res.taggroups << v
				i = ii
			}
			16 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.totalonly = v
				i = ii
			}
			35 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ids_only = v
				i = ii
			}
			17 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_vote_data = v
				i = ii
			}
			18 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_tags = v
				i = ii
			}
			19 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_kv_tags = v
				i = ii
			}
			20 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_previews = v
				i = ii
			}
			21 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_children = v
				i = ii
			}
			22 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_short_description = v
				i = ii
			}
			30 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_for_sale_data = v
				i = ii
			}
			32 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_metadata = v
				i = ii
			}
			36 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.return_playtime_stats = v
				i = ii
			}
			37 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_details = v
				i = ii
			}
			38 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.strip_description_bbcode = v
				i = ii
			}
			40 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			43 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_reactions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Request) eq(b CPublishedFile_QueryFiles_Request) bool {
	return true && a.query_type == b.query_type &&
		a.page == b.page && a.cursor == b.cursor &&
		a.numperpage == b.numperpage && a.creator_appid == b.creator_appid &&
		a.appid == b.appid && a.requiredtags == b.requiredtags &&
		a.excludedtags == b.excludedtags &&
		a.match_all_tags == b.match_all_tags &&
		a.required_flags == b.required_flags &&
		a.omitted_flags == b.omitted_flags &&
		a.search_text == b.search_text && a.filetype == b.filetype &&
		a.child_publishedfileid == b.child_publishedfileid &&
		a.days == b.days && a.include_recent_votes_only == b.include_recent_votes_only &&
		a.cache_max_age_seconds == b.cache_max_age_seconds &&
		a.language == b.language && a.required_kv_tags.eq(b.required_kv_tags) && a.taggroups.eq(b.taggroups) &&
		a.totalonly == b.totalonly && a.ids_only == b.ids_only &&
		a.return_vote_data == b.return_vote_data &&
		a.return_tags == b.return_tags && a.return_kv_tags == b.return_kv_tags &&
		a.return_previews == b.return_previews &&
		a.return_children == b.return_children &&
		a.return_short_description == b.return_short_description &&
		a.return_for_sale_data == b.return_for_sale_data &&
		a.return_metadata == b.return_metadata &&
		a.return_playtime_stats == b.return_playtime_stats &&
		a.return_details == b.return_details &&
		a.strip_description_bbcode == b.strip_description_bbcode &&
		a.desired_revision == b.desired_revision &&
		a.return_reactions == b.return_reactions
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Request) ne(b CPublishedFile_QueryFiles_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Request) eq(b []CPublishedFile_QueryFiles_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Request) ne(b []CPublishedFile_QueryFiles_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_request() CPublishedFile_QueryFiles_Request {
	return CPublishedFile_QueryFiles_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_request(o CPublishedFile_QueryFiles_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	total                u32
	publishedfiledetails []PublishedFileDetails
	next_cursor          string
}

pub fn (o &CPublishedFile_QueryFiles_Response) pack() []byte {
	mut res := []byte{}
	if o.total != u32(0) {
		res << vproto.pack_uint32_field(o.total, 1)
	}
	// [packed=false]
	for _, x in o.publishedfiledetails {
		res << zzz_vproto_internal_pack_publishedfiledetails(x, 2)
	}
	if o.next_cursor != '' {
		res << vproto.pack_string_field(o.next_cursor, 3)
	}
	return res
}

pub fn cpublishedfile_queryfiles_response_unpack(buf []byte) ?CPublishedFile_QueryFiles_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_queryfiles_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
				res.publishedfiledetails << v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.next_cursor = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Response) eq(b CPublishedFile_QueryFiles_Response) bool {
	return true && a.total == b.total && a.publishedfiledetails.eq(b.publishedfiledetails) &&
		a.next_cursor == b.next_cursor
}

[inline]
pub fn (a CPublishedFile_QueryFiles_Response) ne(b CPublishedFile_QueryFiles_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Response) eq(b []CPublishedFile_QueryFiles_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_QueryFiles_Response) ne(b []CPublishedFile_QueryFiles_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_response() CPublishedFile_QueryFiles_Response {
	return CPublishedFile_QueryFiles_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_response(o CPublishedFile_QueryFiles_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddAppRelationship_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	appid           u32
	relationship    u32
}

pub fn (o &CPublishedFile_AddAppRelationship_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.relationship != u32(0) {
		res << vproto.pack_uint32_field(o.relationship, 3)
	}
	return res
}

pub fn cpublishedfile_addapprelationship_request_unpack(buf []byte) ?CPublishedFile_AddAppRelationship_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_addapprelationship_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_AddAppRelationship_Request) eq(b CPublishedFile_AddAppRelationship_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.appid == b.appid && a.relationship == b.relationship
}

[inline]
pub fn (a CPublishedFile_AddAppRelationship_Request) ne(b CPublishedFile_AddAppRelationship_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AddAppRelationship_Request) eq(b []CPublishedFile_AddAppRelationship_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AddAppRelationship_Request) ne(b []CPublishedFile_AddAppRelationship_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_addapprelationship_request() CPublishedFile_AddAppRelationship_Request {
	return CPublishedFile_AddAppRelationship_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_addapprelationship_request(o CPublishedFile_AddAppRelationship_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_addapprelationship_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddAppRelationship_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addapprelationship_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddAppRelationship_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_AddAppRelationship_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_addapprelationship_response_unpack(buf []byte) ?CPublishedFile_AddAppRelationship_Response {
	res := zzz_vproto_internal_new_cpublishedfile_addapprelationship_response()
	return res
}

[inline]
pub fn (a CPublishedFile_AddAppRelationship_Response) eq(b CPublishedFile_AddAppRelationship_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_AddAppRelationship_Response) ne(b CPublishedFile_AddAppRelationship_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AddAppRelationship_Response) eq(b []CPublishedFile_AddAppRelationship_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AddAppRelationship_Response) ne(b []CPublishedFile_AddAppRelationship_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_addapprelationship_response() CPublishedFile_AddAppRelationship_Response {
	return CPublishedFile_AddAppRelationship_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_addapprelationship_response(o CPublishedFile_AddAppRelationship_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_addapprelationship_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddAppRelationship_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addapprelationship_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveAppRelationship_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	appid           u32
	relationship    u32
}

pub fn (o &CPublishedFile_RemoveAppRelationship_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.relationship != u32(0) {
		res << vproto.pack_uint32_field(o.relationship, 3)
	}
	return res
}

pub fn cpublishedfile_removeapprelationship_request_unpack(buf []byte) ?CPublishedFile_RemoveAppRelationship_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_removeapprelationship_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_RemoveAppRelationship_Request) eq(b CPublishedFile_RemoveAppRelationship_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.appid == b.appid && a.relationship == b.relationship
}

[inline]
pub fn (a CPublishedFile_RemoveAppRelationship_Request) ne(b CPublishedFile_RemoveAppRelationship_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_RemoveAppRelationship_Request) eq(b []CPublishedFile_RemoveAppRelationship_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_RemoveAppRelationship_Request) ne(b []CPublishedFile_RemoveAppRelationship_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_removeapprelationship_request() CPublishedFile_RemoveAppRelationship_Request {
	return CPublishedFile_RemoveAppRelationship_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_removeapprelationship_request(o CPublishedFile_RemoveAppRelationship_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_removeapprelationship_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveAppRelationship_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removeapprelationship_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveAppRelationship_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_RemoveAppRelationship_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_removeapprelationship_response_unpack(buf []byte) ?CPublishedFile_RemoveAppRelationship_Response {
	res := zzz_vproto_internal_new_cpublishedfile_removeapprelationship_response()
	return res
}

[inline]
pub fn (a CPublishedFile_RemoveAppRelationship_Response) eq(b CPublishedFile_RemoveAppRelationship_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_RemoveAppRelationship_Response) ne(b CPublishedFile_RemoveAppRelationship_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_RemoveAppRelationship_Response) eq(b []CPublishedFile_RemoveAppRelationship_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_RemoveAppRelationship_Response) ne(b []CPublishedFile_RemoveAppRelationship_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_removeapprelationship_response() CPublishedFile_RemoveAppRelationship_Response {
	return CPublishedFile_RemoveAppRelationship_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_removeapprelationship_response(o CPublishedFile_RemoveAppRelationship_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_removeapprelationship_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveAppRelationship_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removeapprelationship_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetAppRelationships_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
}

pub fn (o &CPublishedFile_GetAppRelationships_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	return res
}

pub fn cpublishedfile_getapprelationships_request_unpack(buf []byte) ?CPublishedFile_GetAppRelationships_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getapprelationships_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetAppRelationships_Request) eq(b CPublishedFile_GetAppRelationships_Request) bool {
	return true && a.publishedfileid == b.publishedfileid
}

[inline]
pub fn (a CPublishedFile_GetAppRelationships_Request) ne(b CPublishedFile_GetAppRelationships_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetAppRelationships_Request) eq(b []CPublishedFile_GetAppRelationships_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetAppRelationships_Request) ne(b []CPublishedFile_GetAppRelationships_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getapprelationships_request() CPublishedFile_GetAppRelationships_Request {
	return CPublishedFile_GetAppRelationships_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getapprelationships_request(o CPublishedFile_GetAppRelationships_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetAppRelationships_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getapprelationships_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetAppRelationships_Response_AppRelationship {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	relationship   u32
}

pub fn (o &CPublishedFile_GetAppRelationships_Response_AppRelationship) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.relationship != u32(0) {
		res << vproto.pack_uint32_field(o.relationship, 2)
	}
	return res
}

pub fn cpublishedfile_getapprelationships_response_apprelationship_unpack(buf []byte) ?CPublishedFile_GetAppRelationships_Response_AppRelationship {
	mut res := zzz_vproto_internal_new_cpublishedfile_getapprelationships_response_apprelationship()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetAppRelationships_Response_AppRelationship) eq(b CPublishedFile_GetAppRelationships_Response_AppRelationship) bool {
	return true && a.appid == b.appid && a.relationship == b.relationship
}

[inline]
pub fn (a CPublishedFile_GetAppRelationships_Response_AppRelationship) ne(b CPublishedFile_GetAppRelationships_Response_AppRelationship) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetAppRelationships_Response_AppRelationship) eq(b []CPublishedFile_GetAppRelationships_Response_AppRelationship) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetAppRelationships_Response_AppRelationship) ne(b []CPublishedFile_GetAppRelationships_Response_AppRelationship) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getapprelationships_response_apprelationship() CPublishedFile_GetAppRelationships_Response_AppRelationship {
	return CPublishedFile_GetAppRelationships_Response_AppRelationship{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getapprelationships_response_apprelationship(o CPublishedFile_GetAppRelationships_Response_AppRelationship, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_response_apprelationship(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetAppRelationships_Response_AppRelationship) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getapprelationships_response_apprelationship_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetAppRelationships_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_relationships []CPublishedFile_GetAppRelationships_Response_AppRelationship
}

pub fn (o &CPublishedFile_GetAppRelationships_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_relationships {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_getapprelationships_response_apprelationship(x, 3)
	}
	return res
}

pub fn cpublishedfile_getapprelationships_response_unpack(buf []byte) ?CPublishedFile_GetAppRelationships_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getapprelationships_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_response_apprelationship(cur_buf,
					tag_wiretype.wire_type)?
				res.app_relationships << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetAppRelationships_Response) eq(b CPublishedFile_GetAppRelationships_Response) bool {
	return true && a.app_relationships.eq(b.app_relationships)
}

[inline]
pub fn (a CPublishedFile_GetAppRelationships_Response) ne(b CPublishedFile_GetAppRelationships_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetAppRelationships_Response) eq(b []CPublishedFile_GetAppRelationships_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetAppRelationships_Response) ne(b []CPublishedFile_GetAppRelationships_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getapprelationships_response() CPublishedFile_GetAppRelationships_Response {
	return CPublishedFile_GetAppRelationships_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getapprelationships_response(o CPublishedFile_GetAppRelationships_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetAppRelationships_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getapprelationships_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StartPlaytimeTracking_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	publishedfileids []u64
}

pub fn (o &CPublishedFile_StartPlaytimeTracking_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cpublishedfile_startplaytimetracking_request_unpack(buf []byte) ?CPublishedFile_StartPlaytimeTracking_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_startplaytimetracking_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_StartPlaytimeTracking_Request) eq(b CPublishedFile_StartPlaytimeTracking_Request) bool {
	return true && a.appid == b.appid && a.publishedfileids == b.publishedfileids
}

[inline]
pub fn (a CPublishedFile_StartPlaytimeTracking_Request) ne(b CPublishedFile_StartPlaytimeTracking_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_StartPlaytimeTracking_Request) eq(b []CPublishedFile_StartPlaytimeTracking_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_StartPlaytimeTracking_Request) ne(b []CPublishedFile_StartPlaytimeTracking_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_startplaytimetracking_request() CPublishedFile_StartPlaytimeTracking_Request {
	return CPublishedFile_StartPlaytimeTracking_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_startplaytimetracking_request(o CPublishedFile_StartPlaytimeTracking_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_startplaytimetracking_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StartPlaytimeTracking_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_startplaytimetracking_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StartPlaytimeTracking_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_StartPlaytimeTracking_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_startplaytimetracking_response_unpack(buf []byte) ?CPublishedFile_StartPlaytimeTracking_Response {
	res := zzz_vproto_internal_new_cpublishedfile_startplaytimetracking_response()
	return res
}

[inline]
pub fn (a CPublishedFile_StartPlaytimeTracking_Response) eq(b CPublishedFile_StartPlaytimeTracking_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_StartPlaytimeTracking_Response) ne(b CPublishedFile_StartPlaytimeTracking_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_StartPlaytimeTracking_Response) eq(b []CPublishedFile_StartPlaytimeTracking_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_StartPlaytimeTracking_Response) ne(b []CPublishedFile_StartPlaytimeTracking_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_startplaytimetracking_response() CPublishedFile_StartPlaytimeTracking_Response {
	return CPublishedFile_StartPlaytimeTracking_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_startplaytimetracking_response(o CPublishedFile_StartPlaytimeTracking_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_startplaytimetracking_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StartPlaytimeTracking_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_startplaytimetracking_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTracking_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	publishedfileids []u64
}

pub fn (o &CPublishedFile_StopPlaytimeTracking_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cpublishedfile_stopplaytimetracking_request_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTracking_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_stopplaytimetracking_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTracking_Request) eq(b CPublishedFile_StopPlaytimeTracking_Request) bool {
	return true && a.appid == b.appid && a.publishedfileids == b.publishedfileids
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTracking_Request) ne(b CPublishedFile_StopPlaytimeTracking_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTracking_Request) eq(b []CPublishedFile_StopPlaytimeTracking_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTracking_Request) ne(b []CPublishedFile_StopPlaytimeTracking_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetracking_request() CPublishedFile_StopPlaytimeTracking_Request {
	return CPublishedFile_StopPlaytimeTracking_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetracking_request(o CPublishedFile_StopPlaytimeTracking_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetracking_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTracking_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetracking_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTracking_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_StopPlaytimeTracking_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_stopplaytimetracking_response_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTracking_Response {
	res := zzz_vproto_internal_new_cpublishedfile_stopplaytimetracking_response()
	return res
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTracking_Response) eq(b CPublishedFile_StopPlaytimeTracking_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTracking_Response) ne(b CPublishedFile_StopPlaytimeTracking_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTracking_Response) eq(b []CPublishedFile_StopPlaytimeTracking_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTracking_Response) ne(b []CPublishedFile_StopPlaytimeTracking_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetracking_response() CPublishedFile_StopPlaytimeTracking_Response {
	return CPublishedFile_StopPlaytimeTracking_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetracking_response(o CPublishedFile_StopPlaytimeTracking_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetracking_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTracking_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetracking_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
}

pub fn (o &CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cpublishedfile_stopplaytimetrackingforallappitems_request_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_stopplaytimetrackingforallappitems_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) eq(b CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) bool {
	return true && a.appid == b.appid
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) ne(b CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) eq(b []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) ne(b []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetrackingforallappitems_request() CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
	return CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetrackingforallappitems_request(o CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetrackingforallappitems_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetrackingforallappitems_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_stopplaytimetrackingforallappitems_response_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
	res := zzz_vproto_internal_new_cpublishedfile_stopplaytimetrackingforallappitems_response()
	return res
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) eq(b CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) ne(b CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) eq(b []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) ne(b []CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetrackingforallappitems_response() CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
	return CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetrackingforallappitems_response(o CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetrackingforallappitems_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetrackingforallappitems_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	seconds_active  f32
}

pub fn (o &CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.seconds_active != f32(0) {
		res << vproto.pack_float_field(o.seconds_active, 2)
	}
	return res
}

pub fn cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage_unpack(buf []byte) ?CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
	mut res := zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_active = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) eq(b CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) bool {
	return true && a.publishedfileid == b.publishedfileid && a.seconds_active == b.seconds_active
}

[inline]
pub fn (a CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) ne(b CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) eq(b []CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) ne(b []CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage() CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
	return CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(o CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	appid                   u32
	controller_config_usage []CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage
}

pub fn (o &CPublishedFile_SetPlaytimeForControllerConfigs_Request) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.controller_config_usage {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(x, 2)
	}
	return res
}

pub fn cpublishedfile_setplaytimeforcontrollerconfigs_request_unpack(buf []byte) ?CPublishedFile_SetPlaytimeForControllerConfigs_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(cur_buf,
					tag_wiretype.wire_type)?
				res.controller_config_usage << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_SetPlaytimeForControllerConfigs_Request) eq(b CPublishedFile_SetPlaytimeForControllerConfigs_Request) bool {
	return true && a.appid == b.appid && a.controller_config_usage.eq(b.controller_config_usage)
}

[inline]
pub fn (a CPublishedFile_SetPlaytimeForControllerConfigs_Request) ne(b CPublishedFile_SetPlaytimeForControllerConfigs_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_SetPlaytimeForControllerConfigs_Request) eq(b []CPublishedFile_SetPlaytimeForControllerConfigs_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_SetPlaytimeForControllerConfigs_Request) ne(b []CPublishedFile_SetPlaytimeForControllerConfigs_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_request() CPublishedFile_SetPlaytimeForControllerConfigs_Request {
	return CPublishedFile_SetPlaytimeForControllerConfigs_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_request(o CPublishedFile_SetPlaytimeForControllerConfigs_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_SetPlaytimeForControllerConfigs_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_setplaytimeforcontrollerconfigs_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_SetPlaytimeForControllerConfigs_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_setplaytimeforcontrollerconfigs_response_unpack(buf []byte) ?CPublishedFile_SetPlaytimeForControllerConfigs_Response {
	res := zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_response()
	return res
}

[inline]
pub fn (a CPublishedFile_SetPlaytimeForControllerConfigs_Response) eq(b CPublishedFile_SetPlaytimeForControllerConfigs_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_SetPlaytimeForControllerConfigs_Response) ne(b CPublishedFile_SetPlaytimeForControllerConfigs_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_SetPlaytimeForControllerConfigs_Response) eq(b []CPublishedFile_SetPlaytimeForControllerConfigs_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_SetPlaytimeForControllerConfigs_Response) ne(b []CPublishedFile_SetPlaytimeForControllerConfigs_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_response() CPublishedFile_SetPlaytimeForControllerConfigs_Response {
	return CPublishedFile_SetPlaytimeForControllerConfigs_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_response(o CPublishedFile_SetPlaytimeForControllerConfigs_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_SetPlaytimeForControllerConfigs_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_setplaytimeforcontrollerconfigs_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddChild_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	publishedfileid       u64
	child_publishedfileid u64
}

pub fn (o &CPublishedFile_AddChild_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.child_publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.child_publishedfileid, 2)
	}
	return res
}

pub fn cpublishedfile_addchild_request_unpack(buf []byte) ?CPublishedFile_AddChild_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_addchild_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.child_publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_AddChild_Request) eq(b CPublishedFile_AddChild_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.child_publishedfileid == b.child_publishedfileid
}

[inline]
pub fn (a CPublishedFile_AddChild_Request) ne(b CPublishedFile_AddChild_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AddChild_Request) eq(b []CPublishedFile_AddChild_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AddChild_Request) ne(b []CPublishedFile_AddChild_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_addchild_request() CPublishedFile_AddChild_Request {
	return CPublishedFile_AddChild_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_addchild_request(o CPublishedFile_AddChild_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_addchild_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddChild_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addchild_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddChild_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_AddChild_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_addchild_response_unpack(buf []byte) ?CPublishedFile_AddChild_Response {
	res := zzz_vproto_internal_new_cpublishedfile_addchild_response()
	return res
}

[inline]
pub fn (a CPublishedFile_AddChild_Response) eq(b CPublishedFile_AddChild_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_AddChild_Response) ne(b CPublishedFile_AddChild_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_AddChild_Response) eq(b []CPublishedFile_AddChild_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_AddChild_Response) ne(b []CPublishedFile_AddChild_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_addchild_response() CPublishedFile_AddChild_Response {
	return CPublishedFile_AddChild_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_addchild_response(o CPublishedFile_AddChild_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_addchild_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddChild_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addchild_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveChild_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	publishedfileid       u64
	child_publishedfileid u64
}

pub fn (o &CPublishedFile_RemoveChild_Request) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.child_publishedfileid != u64(0) {
		res << vproto.pack_uint64_field(o.child_publishedfileid, 2)
	}
	return res
}

pub fn cpublishedfile_removechild_request_unpack(buf []byte) ?CPublishedFile_RemoveChild_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_removechild_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.child_publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_RemoveChild_Request) eq(b CPublishedFile_RemoveChild_Request) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.child_publishedfileid == b.child_publishedfileid
}

[inline]
pub fn (a CPublishedFile_RemoveChild_Request) ne(b CPublishedFile_RemoveChild_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_RemoveChild_Request) eq(b []CPublishedFile_RemoveChild_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_RemoveChild_Request) ne(b []CPublishedFile_RemoveChild_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_removechild_request() CPublishedFile_RemoveChild_Request {
	return CPublishedFile_RemoveChild_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_removechild_request(o CPublishedFile_RemoveChild_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_removechild_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveChild_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removechild_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveChild_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_RemoveChild_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_removechild_response_unpack(buf []byte) ?CPublishedFile_RemoveChild_Response {
	res := zzz_vproto_internal_new_cpublishedfile_removechild_response()
	return res
}

[inline]
pub fn (a CPublishedFile_RemoveChild_Response) eq(b CPublishedFile_RemoveChild_Response) bool {
	return true
}

[inline]
pub fn (a CPublishedFile_RemoveChild_Response) ne(b CPublishedFile_RemoveChild_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_RemoveChild_Response) eq(b []CPublishedFile_RemoveChild_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_RemoveChild_Response) ne(b []CPublishedFile_RemoveChild_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_removechild_response() CPublishedFile_RemoveChild_Response {
	return CPublishedFile_RemoveChild_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_removechild_response(o CPublishedFile_RemoveChild_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_removechild_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveChild_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removechild_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserVoteSummary_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	publishedfileids []u64
}

pub fn (o &CPublishedFile_GetUserVoteSummary_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_64bit_field(x, 1)
	}
	return res
}

pub fn cpublishedfile_getuservotesummary_request_unpack(buf []byte) ?CPublishedFile_GetUserVoteSummary_Request {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuservotesummary_request()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserVoteSummary_Request) eq(b CPublishedFile_GetUserVoteSummary_Request) bool {
	return true && a.publishedfileids == b.publishedfileids
}

[inline]
pub fn (a CPublishedFile_GetUserVoteSummary_Request) ne(b CPublishedFile_GetUserVoteSummary_Request) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserVoteSummary_Request) eq(b []CPublishedFile_GetUserVoteSummary_Request) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserVoteSummary_Request) ne(b []CPublishedFile_GetUserVoteSummary_Request) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuservotesummary_request() CPublishedFile_GetUserVoteSummary_Request {
	return CPublishedFile_GetUserVoteSummary_Request{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_request(o CPublishedFile_GetUserVoteSummary_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserVoteSummary_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuservotesummary_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	publishedfileid u64
	vote_for        bool
	vote_against    bool
	reported        bool
}

pub fn (o &CPublishedFile_GetUserVoteSummary_Response_VoteSummary) pack() []byte {
	mut res := []byte{}
	if o.publishedfileid != u64(0) {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.vote_for != bool(0) {
		res << vproto.pack_bool_field(o.vote_for, 2)
	}
	if o.vote_against != bool(0) {
		res << vproto.pack_bool_field(o.vote_against, 3)
	}
	if o.reported != bool(0) {
		res << vproto.pack_bool_field(o.reported, 4)
	}
	return res
}

pub fn cpublishedfile_getuservotesummary_response_votesummary_unpack(buf []byte) ?CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuservotesummary_response_votesummary()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vote_for = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vote_against = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reported = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserVoteSummary_Response_VoteSummary) eq(b CPublishedFile_GetUserVoteSummary_Response_VoteSummary) bool {
	return true && a.publishedfileid == b.publishedfileid &&
		a.vote_for == b.vote_for && a.vote_against == b.vote_against &&
		a.reported == b.reported
}

[inline]
pub fn (a CPublishedFile_GetUserVoteSummary_Response_VoteSummary) ne(b CPublishedFile_GetUserVoteSummary_Response_VoteSummary) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserVoteSummary_Response_VoteSummary) eq(b []CPublishedFile_GetUserVoteSummary_Response_VoteSummary) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserVoteSummary_Response_VoteSummary) ne(b []CPublishedFile_GetUserVoteSummary_Response_VoteSummary) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuservotesummary_response_votesummary() CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
	return CPublishedFile_GetUserVoteSummary_Response_VoteSummary{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_response_votesummary(o CPublishedFile_GetUserVoteSummary_Response_VoteSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_response_votesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserVoteSummary_Response_VoteSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuservotesummary_response_votesummary_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserVoteSummary_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	summaries      []CPublishedFile_GetUserVoteSummary_Response_VoteSummary
}

pub fn (o &CPublishedFile_GetUserVoteSummary_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.summaries {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_response_votesummary(x, 1)
	}
	return res
}

pub fn cpublishedfile_getuservotesummary_response_unpack(buf []byte) ?CPublishedFile_GetUserVoteSummary_Response {
	mut res := zzz_vproto_internal_new_cpublishedfile_getuservotesummary_response()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_response_votesummary(cur_buf,
					tag_wiretype.wire_type)?
				res.summaries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_GetUserVoteSummary_Response) eq(b CPublishedFile_GetUserVoteSummary_Response) bool {
	return true && a.summaries.eq(b.summaries)
}

[inline]
pub fn (a CPublishedFile_GetUserVoteSummary_Response) ne(b CPublishedFile_GetUserVoteSummary_Response) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_GetUserVoteSummary_Response) eq(b []CPublishedFile_GetUserVoteSummary_Response) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_GetUserVoteSummary_Response) ne(b []CPublishedFile_GetUserVoteSummary_Response) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_getuservotesummary_response() CPublishedFile_GetUserVoteSummary_Response {
	return CPublishedFile_GetUserVoteSummary_Response{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_response(o CPublishedFile_GetUserVoteSummary_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserVoteSummary_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuservotesummary_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileSubscribed_Notification_RevisionData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	revision       EPublishedFileRevision = .k_epublishedfilerevision_default
	file_hcontent  u64
	rtime_updated  u32
}

pub fn (o &CPublishedFile_FileSubscribed_Notification_RevisionData) pack() []byte {
	mut res := []byte{}
	if o.revision != zzz_vproto_internal_new_epublishedfilerevision() {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.revision, 1)
	}
	if o.file_hcontent != u64(0) {
		res << vproto.pack_64bit_field(o.file_hcontent, 2)
	}
	if o.rtime_updated != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_updated, 3)
	}
	return res
}

pub fn cpublishedfile_filesubscribed_notification_revisiondata_unpack(buf []byte) ?CPublishedFile_FileSubscribed_Notification_RevisionData {
	mut res := zzz_vproto_internal_new_cpublishedfile_filesubscribed_notification_revisiondata()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.file_hcontent = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_updated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_FileSubscribed_Notification_RevisionData) eq(b CPublishedFile_FileSubscribed_Notification_RevisionData) bool {
	return true && a.revision == b.revision &&
		a.file_hcontent == b.file_hcontent &&
		a.rtime_updated == b.rtime_updated
}

[inline]
pub fn (a CPublishedFile_FileSubscribed_Notification_RevisionData) ne(b CPublishedFile_FileSubscribed_Notification_RevisionData) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_FileSubscribed_Notification_RevisionData) eq(b []CPublishedFile_FileSubscribed_Notification_RevisionData) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_FileSubscribed_Notification_RevisionData) ne(b []CPublishedFile_FileSubscribed_Notification_RevisionData) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_filesubscribed_notification_revisiondata() CPublishedFile_FileSubscribed_Notification_RevisionData {
	return CPublishedFile_FileSubscribed_Notification_RevisionData{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_filesubscribed_notification_revisiondata(o CPublishedFile_FileSubscribed_Notification_RevisionData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_filesubscribed_notification_revisiondata(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileSubscribed_Notification_RevisionData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_filesubscribed_notification_revisiondata_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileSubscribed_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	published_file_id u64
	app_id            u32
	file_hcontent     u64
	file_size         u32
	rtime_subscribed  u32
	is_depot_content  bool
	rtime_updated     u32
	revisions         []CPublishedFile_FileSubscribed_Notification_RevisionData
}

pub fn (o &CPublishedFile_FileSubscribed_Notification) pack() []byte {
	mut res := []byte{}
	if o.published_file_id != u64(0) {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.file_hcontent != u64(0) {
		res << vproto.pack_64bit_field(o.file_hcontent, 3)
	}
	if o.file_size != u32(0) {
		res << vproto.pack_uint32_field(o.file_size, 4)
	}
	if o.rtime_subscribed != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_subscribed, 5)
	}
	if o.is_depot_content != bool(0) {
		res << vproto.pack_bool_field(o.is_depot_content, 6)
	}
	if o.rtime_updated != u32(0) {
		res << vproto.pack_uint32_field(o.rtime_updated, 7)
	}
	// [packed=false]
	for _, x in o.revisions {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_filesubscribed_notification_revisiondata(x, 8)
	}
	return res
}

pub fn cpublishedfile_filesubscribed_notification_unpack(buf []byte) ?CPublishedFile_FileSubscribed_Notification {
	mut res := zzz_vproto_internal_new_cpublishedfile_filesubscribed_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.file_hcontent = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_subscribed = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_depot_content = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_updated = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_filesubscribed_notification_revisiondata(cur_buf,
					tag_wiretype.wire_type)?
				res.revisions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_FileSubscribed_Notification) eq(b CPublishedFile_FileSubscribed_Notification) bool {
	return true && a.published_file_id == b.published_file_id &&
		a.app_id == b.app_id && a.file_hcontent == b.file_hcontent &&
		a.file_size == b.file_size && a.rtime_subscribed == b.rtime_subscribed &&
		a.is_depot_content == b.is_depot_content &&
		a.rtime_updated == b.rtime_updated && a.revisions.eq(b.revisions)
}

[inline]
pub fn (a CPublishedFile_FileSubscribed_Notification) ne(b CPublishedFile_FileSubscribed_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_FileSubscribed_Notification) eq(b []CPublishedFile_FileSubscribed_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_FileSubscribed_Notification) ne(b []CPublishedFile_FileSubscribed_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_filesubscribed_notification() CPublishedFile_FileSubscribed_Notification {
	return CPublishedFile_FileSubscribed_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_filesubscribed_notification(o CPublishedFile_FileSubscribed_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_filesubscribed_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileSubscribed_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_filesubscribed_notification_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileUnsubscribed_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	published_file_id u64
	app_id            u32
}

pub fn (o &CPublishedFile_FileUnsubscribed_Notification) pack() []byte {
	mut res := []byte{}
	if o.published_file_id != u64(0) {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cpublishedfile_fileunsubscribed_notification_unpack(buf []byte) ?CPublishedFile_FileUnsubscribed_Notification {
	mut res := zzz_vproto_internal_new_cpublishedfile_fileunsubscribed_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_FileUnsubscribed_Notification) eq(b CPublishedFile_FileUnsubscribed_Notification) bool {
	return true && a.published_file_id == b.published_file_id && a.app_id == b.app_id
}

[inline]
pub fn (a CPublishedFile_FileUnsubscribed_Notification) ne(b CPublishedFile_FileUnsubscribed_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_FileUnsubscribed_Notification) eq(b []CPublishedFile_FileUnsubscribed_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_FileUnsubscribed_Notification) ne(b []CPublishedFile_FileUnsubscribed_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_fileunsubscribed_notification() CPublishedFile_FileUnsubscribed_Notification {
	return CPublishedFile_FileUnsubscribed_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_fileunsubscribed_notification(o CPublishedFile_FileUnsubscribed_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_fileunsubscribed_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileUnsubscribed_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_fileunsubscribed_notification_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileDeleted_Client_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	published_file_id u64
	app_id            u32
}

pub fn (o &CPublishedFile_FileDeleted_Client_Notification) pack() []byte {
	mut res := []byte{}
	if o.published_file_id != u64(0) {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.app_id != u32(0) {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cpublishedfile_filedeleted_client_notification_unpack(buf []byte) ?CPublishedFile_FileDeleted_Client_Notification {
	mut res := zzz_vproto_internal_new_cpublishedfile_filedeleted_client_notification()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CPublishedFile_FileDeleted_Client_Notification) eq(b CPublishedFile_FileDeleted_Client_Notification) bool {
	return true && a.published_file_id == b.published_file_id && a.app_id == b.app_id
}

[inline]
pub fn (a CPublishedFile_FileDeleted_Client_Notification) ne(b CPublishedFile_FileDeleted_Client_Notification) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CPublishedFile_FileDeleted_Client_Notification) eq(b []CPublishedFile_FileDeleted_Client_Notification) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CPublishedFile_FileDeleted_Client_Notification) ne(b []CPublishedFile_FileDeleted_Client_Notification) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cpublishedfile_filedeleted_client_notification() CPublishedFile_FileDeleted_Client_Notification {
	return CPublishedFile_FileDeleted_Client_Notification{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cpublishedfile_filedeleted_client_notification(o CPublishedFile_FileDeleted_Client_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cpublishedfile_filedeleted_client_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileDeleted_Client_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_filedeleted_client_notification_unpack(v)?
	return i, unpacked
}
