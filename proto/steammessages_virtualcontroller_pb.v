// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EInputMode {
	k_einputmodeunknown = 0
	k_einputmodemouse = 1
	k_einputmodecontroller = 2
	k_einputmodemouseandcontroller = 3
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_einputmode() EInputMode {
	return .k_einputmodeunknown
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_einputmode(e EInputMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_einputmode_packed(e []EInputMode, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_einputmode(buf []byte, tag_wiretype vproto.WireType) ?(int, EInputMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EInputMode(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_einputmode_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EInputMode) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EMouseMode {
	k_emousemodeunknown = 0
	k_emousemoderelativecursor = 1
	k_emousemodeabsolutecursor = 2
	k_emousemodetouch = 3
	k_emousemoderelative = 4
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_emousemode() EMouseMode {
	return .k_emousemodeunknown
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_emousemode(e EMouseMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_emousemode_packed(e []EMouseMode, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_emousemode(buf []byte, tag_wiretype vproto.WireType) ?(int, EMouseMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EMouseMode(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_emousemode_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EMouseMode) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EControllerElementType {
	k_econtrollerelementtypenone = -1
	k_econtrollerelementtypethumb = 0
	k_econtrollerelementtypebuttonsteam = 1
	k_econtrollerelementtypejoystickleft = 2
	k_econtrollerelementtypebuttonjoystickleft = 3
	k_econtrollerelementtypejoystickright = 4
	k_econtrollerelementtypebuttonjoystickright = 5
	k_econtrollerelementtypedpad = 6
	k_econtrollerelementtypebuttona = 7
	k_econtrollerelementtypebuttonb = 8
	k_econtrollerelementtypebuttonx = 9
	k_econtrollerelementtypebuttony = 10
	k_econtrollerelementtypebuttonselect = 11
	k_econtrollerelementtypebuttonstart = 12
	k_econtrollerelementtypebuttontriggerleft = 13
	k_econtrollerelementtypebuttontriggerright = 14
	k_econtrollerelementtypebuttonbumperleft = 15
	k_econtrollerelementtypebuttonbumperright = 16
	k_econtrollerelementtypebuttonmacro0 = 17
	k_econtrollerelementtypebuttonmacro1 = 18
	k_econtrollerelementtypebuttonmacro2 = 19
	k_econtrollerelementtypebuttonmacro3 = 20
	k_econtrollerelementtypebuttonmacro4 = 21
	k_econtrollerelementtypebuttonmacro5 = 22
	k_econtrollerelementtypebuttonmacro6 = 23
	k_econtrollerelementtypebuttonmacro7 = 24
	k_econtrollerelementtypetrackpadcenter = 25
	k_econtrollerelementtypetrackpadleft = 26
	k_econtrollerelementtypetrackpadright = 27
	k_econtrollerelementtypekeyboard = 28
	k_econtrollerelementtypemagnifyingglass = 29
	k_econtrollerelementtypebuttonmacro1finger = 30
	k_econtrollerelementtypebuttonmacro2finger = 31
	k_econtrollerelementtyperecordinput = 32
	k_econtrollerelementtypeplaybackinput = 33
	k_econtrollerelementtypepaste = 34
	k_econtrollerelementtypemax = 35
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_econtrollerelementtype() EControllerElementType {
	return .k_econtrollerelementtypenone
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_econtrollerelementtype(e EControllerElementType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_econtrollerelementtype_packed(e []EControllerElementType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_econtrollerelementtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EControllerElementType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EControllerElementType(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_econtrollerelementtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EControllerElementType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CVirtualControllerElement {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          EControllerElementType = .k_econtrollerelementtypenone
	visible        bool
	x_position     f32
	y_position     f32
	x_scale        f32 = 1
	y_scale        f32 = 1
}

pub fn (o &CVirtualControllerElement) pack() []byte {
	mut res := []byte{}
	if o.@type != zzz_vproto_internal_new_econtrollerelementtype() {
		res << zzz_vproto_internal_pack_econtrollerelementtype(o.@type, 1)
	}
	if o.visible != bool(0) {
		res << vproto.pack_bool_field(o.visible, 2)
	}
	if o.x_position != f32(0) {
		res << vproto.pack_float_field(o.x_position, 3)
	}
	if o.y_position != f32(0) {
		res << vproto.pack_float_field(o.y_position, 4)
	}
	if o.x_scale != f32(0) {
		res << vproto.pack_float_field(o.x_scale, 5)
	}
	if o.y_scale != f32(0) {
		res << vproto.pack_float_field(o.y_scale, 6)
	}
	return res
}

pub fn cvirtualcontrollerelement_unpack(buf []byte) ?CVirtualControllerElement {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerelement()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_econtrollerelementtype(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.visible = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_position = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_position = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_scale = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_scale = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerElement) eq(b CVirtualControllerElement) bool {
	return true && a.@type == b.@type &&
		a.visible == b.visible && a.x_position == b.x_position &&
		a.y_position == b.y_position && a.x_scale == b.x_scale &&
		a.y_scale == b.y_scale
}

[inline]
pub fn (a CVirtualControllerElement) ne(b CVirtualControllerElement) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerElement) eq(b []CVirtualControllerElement) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerElement) ne(b []CVirtualControllerElement) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerelement() CVirtualControllerElement {
	return CVirtualControllerElement{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerelement(o CVirtualControllerElement, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerElement) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerelement_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerColor {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	r              f32 = 1
	g              f32 = 1
	b              f32 = 1
	a              f32 = 1
}

pub fn (o &CVirtualControllerColor) pack() []byte {
	mut res := []byte{}
	if o.r != f32(0) {
		res << vproto.pack_float_field(o.r, 1)
	}
	if o.g != f32(0) {
		res << vproto.pack_float_field(o.g, 2)
	}
	if o.b != f32(0) {
		res << vproto.pack_float_field(o.b, 3)
	}
	if o.a != f32(0) {
		res << vproto.pack_float_field(o.a, 4)
	}
	return res
}

pub fn cvirtualcontrollercolor_unpack(buf []byte) ?CVirtualControllerColor {
	mut res := zzz_vproto_internal_new_cvirtualcontrollercolor()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.r = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.g = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.b = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.a = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerColor) eq(b CVirtualControllerColor) bool {
	return true && a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a
}

[inline]
pub fn (a CVirtualControllerColor) ne(b CVirtualControllerColor) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerColor) eq(b []CVirtualControllerColor) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerColor) ne(b []CVirtualControllerColor) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollercolor() CVirtualControllerColor {
	return CVirtualControllerColor{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollercolor(o CVirtualControllerColor, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollercolor(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerColor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollercolor_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerLayout {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	layout_version int
	actionset_id   int
	elements       []CVirtualControllerElement
	color          CVirtualControllerColor
}

pub fn (o &CVirtualControllerLayout) pack() []byte {
	mut res := []byte{}
	if o.layout_version != int(0) {
		res << vproto.pack_int32_field(o.layout_version, 1)
	}
	if o.actionset_id != int(0) {
		res << vproto.pack_int32_field(o.actionset_id, 2)
	}
	// [packed=false]
	for _, x in o.elements {
		res << zzz_vproto_internal_pack_cvirtualcontrollerelement(x, 4)
	}
	if o.color.ne(zzz_vproto_internal_new_cvirtualcontrollercolor()) {
		res << zzz_vproto_internal_pack_cvirtualcontrollercolor(o.color, 5)
	}
	return res
}

pub fn cvirtualcontrollerlayout_unpack(buf []byte) ?CVirtualControllerLayout {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerlayout()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.layout_version = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.actionset_id = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerelement(cur_buf,
					tag_wiretype.wire_type)?
				res.elements << v
				i = ii
			}
			5 {
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollercolor(cur_buf, tag_wiretype.wire_type)?
				res.color = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerLayout) eq(b CVirtualControllerLayout) bool {
	return true && a.layout_version == b.layout_version &&
		a.actionset_id == b.actionset_id && a.elements.eq(b.elements) && a.color.eq(b.color)
}

[inline]
pub fn (a CVirtualControllerLayout) ne(b CVirtualControllerLayout) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerLayout) eq(b []CVirtualControllerLayout) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerLayout) ne(b []CVirtualControllerLayout) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerlayout() CVirtualControllerLayout {
	return CVirtualControllerLayout{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerlayout(o CVirtualControllerLayout, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerlayout(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerLayout) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerlayout_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerLayouts {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	layouts              []CVirtualControllerLayout
	input_mode           EInputMode = .k_einputmodecontroller
	mouse_mode           EMouseMode = .k_emousemodeunknown
	trackpad_sensitivity f32 = 1
	pinch_zoom_enabled   bool = false
	pinch_zoom_x         f32 = 0
	pinch_zoom_y         f32 = 0
	pinch_zoom_scale     f32 = 1
	shaken               bool
	mouse_offscreen      bool
}

pub fn (o &CVirtualControllerLayouts) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.layouts {
		res << zzz_vproto_internal_pack_cvirtualcontrollerlayout(x, 1)
	}
	if o.input_mode != zzz_vproto_internal_new_einputmode() {
		res << zzz_vproto_internal_pack_einputmode(o.input_mode, 2)
	}
	if o.mouse_mode != zzz_vproto_internal_new_emousemode() {
		res << zzz_vproto_internal_pack_emousemode(o.mouse_mode, 3)
	}
	if o.trackpad_sensitivity != f32(0) {
		res << vproto.pack_float_field(o.trackpad_sensitivity, 4)
	}
	if o.pinch_zoom_enabled != bool(0) {
		res << vproto.pack_bool_field(o.pinch_zoom_enabled, 5)
	}
	if o.pinch_zoom_x != f32(0) {
		res << vproto.pack_float_field(o.pinch_zoom_x, 6)
	}
	if o.pinch_zoom_y != f32(0) {
		res << vproto.pack_float_field(o.pinch_zoom_y, 7)
	}
	if o.pinch_zoom_scale != f32(0) {
		res << vproto.pack_float_field(o.pinch_zoom_scale, 8)
	}
	if o.shaken != bool(0) {
		res << vproto.pack_bool_field(o.shaken, 9)
	}
	if o.mouse_offscreen != bool(0) {
		res << vproto.pack_bool_field(o.mouse_offscreen, 10)
	}
	return res
}

pub fn cvirtualcontrollerlayouts_unpack(buf []byte) ?CVirtualControllerLayouts {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerlayouts()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerlayout(cur_buf,
					tag_wiretype.wire_type)?
				res.layouts << v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_einputmode(cur_buf, tag_wiretype.wire_type)?
				res.input_mode = v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_emousemode(cur_buf, tag_wiretype.wire_type)?
				res.mouse_mode = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.trackpad_sensitivity = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.pinch_zoom_enabled = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pinch_zoom_x = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pinch_zoom_y = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pinch_zoom_scale = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.shaken = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_offscreen = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerLayouts) eq(b CVirtualControllerLayouts) bool {
	return true && a.layouts.eq(b.layouts) &&
		a.input_mode == b.input_mode && a.mouse_mode == b.mouse_mode &&
		a.trackpad_sensitivity == b.trackpad_sensitivity &&
		a.pinch_zoom_enabled == b.pinch_zoom_enabled &&
		a.pinch_zoom_x == b.pinch_zoom_x &&
		a.pinch_zoom_y == b.pinch_zoom_y &&
		a.pinch_zoom_scale == b.pinch_zoom_scale &&
		a.shaken == b.shaken && a.mouse_offscreen == b.mouse_offscreen
}

[inline]
pub fn (a CVirtualControllerLayouts) ne(b CVirtualControllerLayouts) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerLayouts) eq(b []CVirtualControllerLayouts) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerLayouts) ne(b []CVirtualControllerLayouts) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerlayouts() CVirtualControllerLayouts {
	return CVirtualControllerLayouts{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerlayouts(o CVirtualControllerLayouts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerlayouts(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerLayouts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerlayouts_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerConfig_Control {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	name                             string
	icon                             string
	input_source                     int
	input_mode                       int
	input_element                    int
	output_gamepad                   int
	output_keyboard                  int
	output_mouse                     int
	icon_foreground                  string
	icon_background                  string
	input_toggle                     bool
	input_activate_stick_or_trackpad int
	activation_type                  int
	long_press_ms                    int
	double_press_ms                  int
}

pub fn (o &CVirtualControllerConfig_Control) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.icon != '' {
		res << vproto.pack_string_field(o.icon, 2)
	}
	if o.input_source != int(0) {
		res << vproto.pack_int32_field(o.input_source, 3)
	}
	if o.input_mode != int(0) {
		res << vproto.pack_int32_field(o.input_mode, 4)
	}
	if o.input_element != int(0) {
		res << vproto.pack_int32_field(o.input_element, 5)
	}
	if o.output_gamepad != int(0) {
		res << vproto.pack_int32_field(o.output_gamepad, 6)
	}
	if o.output_keyboard != int(0) {
		res << vproto.pack_int32_field(o.output_keyboard, 7)
	}
	if o.output_mouse != int(0) {
		res << vproto.pack_int32_field(o.output_mouse, 8)
	}
	if o.icon_foreground != '' {
		res << vproto.pack_string_field(o.icon_foreground, 9)
	}
	if o.icon_background != '' {
		res << vproto.pack_string_field(o.icon_background, 10)
	}
	if o.input_toggle != bool(0) {
		res << vproto.pack_bool_field(o.input_toggle, 11)
	}
	if o.input_activate_stick_or_trackpad != int(0) {
		res << vproto.pack_int32_field(o.input_activate_stick_or_trackpad, 12)
	}
	if o.activation_type != int(0) {
		res << vproto.pack_int32_field(o.activation_type, 13)
	}
	if o.long_press_ms != int(0) {
		res << vproto.pack_int32_field(o.long_press_ms, 14)
	}
	if o.double_press_ms != int(0) {
		res << vproto.pack_int32_field(o.double_press_ms, 15)
	}
	return res
}

pub fn cvirtualcontrollerconfig_control_unpack(buf []byte) ?CVirtualControllerConfig_Control {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerconfig_control()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_source = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mode = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_element = v
				i = ii
			}
			6 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.output_gamepad = v
				i = ii
			}
			7 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.output_keyboard = v
				i = ii
			}
			8 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.output_mouse = v
				i = ii
			}
			9 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_foreground = v
				i = ii
			}
			10 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_background = v
				i = ii
			}
			11 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.input_toggle = v
				i = ii
			}
			12 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_activate_stick_or_trackpad = v
				i = ii
			}
			13 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.activation_type = v
				i = ii
			}
			14 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.long_press_ms = v
				i = ii
			}
			15 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.double_press_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerConfig_Control) eq(b CVirtualControllerConfig_Control) bool {
	return true && a.name == b.name &&
		a.icon == b.icon && a.input_source == b.input_source &&
		a.input_mode == b.input_mode && a.input_element == b.input_element &&
		a.output_gamepad == b.output_gamepad &&
		a.output_keyboard == b.output_keyboard &&
		a.output_mouse == b.output_mouse &&
		a.icon_foreground == b.icon_foreground &&
		a.icon_background == b.icon_background &&
		a.input_toggle == b.input_toggle &&
		a.input_activate_stick_or_trackpad == b.input_activate_stick_or_trackpad &&
		a.activation_type == b.activation_type &&
		a.long_press_ms == b.long_press_ms &&
		a.double_press_ms == b.double_press_ms
}

[inline]
pub fn (a CVirtualControllerConfig_Control) ne(b CVirtualControllerConfig_Control) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerConfig_Control) eq(b []CVirtualControllerConfig_Control) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerConfig_Control) ne(b []CVirtualControllerConfig_Control) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerconfig_control() CVirtualControllerConfig_Control {
	return CVirtualControllerConfig_Control{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerconfig_control(o CVirtualControllerConfig_Control, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerconfig_control(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerConfig_Control) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerconfig_control_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerConfig_ActionSet {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	id             int
	parent_id      int
	name           string
	controls       []CVirtualControllerConfig_Control
}

pub fn (o &CVirtualControllerConfig_ActionSet) pack() []byte {
	mut res := []byte{}
	if o.id != int(0) {
		res << vproto.pack_int32_field(o.id, 1)
	}
	if o.parent_id != int(0) {
		res << vproto.pack_int32_field(o.parent_id, 2)
	}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 3)
	}
	// [packed=false]
	for _, x in o.controls {
		res << zzz_vproto_internal_pack_cvirtualcontrollerconfig_control(x, 4)
	}
	return res
}

pub fn cvirtualcontrollerconfig_actionset_unpack(buf []byte) ?CVirtualControllerConfig_ActionSet {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerconfig_actionset()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.parent_id = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerconfig_control(cur_buf,
					tag_wiretype.wire_type)?
				res.controls << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerConfig_ActionSet) eq(b CVirtualControllerConfig_ActionSet) bool {
	return true && a.id == b.id &&
		a.parent_id == b.parent_id && a.name == b.name && a.controls.eq(b.controls)
}

[inline]
pub fn (a CVirtualControllerConfig_ActionSet) ne(b CVirtualControllerConfig_ActionSet) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerConfig_ActionSet) eq(b []CVirtualControllerConfig_ActionSet) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerConfig_ActionSet) ne(b []CVirtualControllerConfig_ActionSet) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerconfig_actionset() CVirtualControllerConfig_ActionSet {
	return CVirtualControllerConfig_ActionSet{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerconfig_actionset(o CVirtualControllerConfig_ActionSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerconfig_actionset(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerConfig_ActionSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerconfig_actionset_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerConfig {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	name               string
	actionsets         []CVirtualControllerConfig_ActionSet
	default_mouse_mode EMouseMode = .k_emousemoderelative
}

pub fn (o &CVirtualControllerConfig) pack() []byte {
	mut res := []byte{}
	if o.name != '' {
		res << vproto.pack_string_field(o.name, 1)
	}
	// [packed=false]
	for _, x in o.actionsets {
		res << zzz_vproto_internal_pack_cvirtualcontrollerconfig_actionset(x, 2)
	}
	if o.default_mouse_mode != zzz_vproto_internal_new_emousemode() {
		res << zzz_vproto_internal_pack_emousemode(o.default_mouse_mode, 3)
	}
	return res
}

pub fn cvirtualcontrollerconfig_unpack(buf []byte) ?CVirtualControllerConfig {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerconfig()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerconfig_actionset(cur_buf,
					tag_wiretype.wire_type)?
				res.actionsets << v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_emousemode(cur_buf, tag_wiretype.wire_type)?
				res.default_mouse_mode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerConfig) eq(b CVirtualControllerConfig) bool {
	return true && a.name == b.name && a.actionsets.eq(b.actionsets) &&
		a.default_mouse_mode == b.default_mouse_mode
}

[inline]
pub fn (a CVirtualControllerConfig) ne(b CVirtualControllerConfig) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerConfig) eq(b []CVirtualControllerConfig) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerConfig) ne(b []CVirtualControllerConfig) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerconfig() CVirtualControllerConfig {
	return CVirtualControllerConfig{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerconfig(o CVirtualControllerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerconfig_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerLayoutPackage {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	creator          u64
	initial_revision u32
	saved_revision   u32
	config           CVirtualControllerConfig
	layouts          CVirtualControllerLayouts
}

pub fn (o &CVirtualControllerLayoutPackage) pack() []byte {
	mut res := []byte{}
	if o.appid != u32(0) {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.creator != u64(0) {
		res << vproto.pack_uint64_field(o.creator, 2)
	}
	if o.initial_revision != u32(0) {
		res << vproto.pack_uint32_field(o.initial_revision, 3)
	}
	if o.saved_revision != u32(0) {
		res << vproto.pack_uint32_field(o.saved_revision, 4)
	}
	if o.config.ne(zzz_vproto_internal_new_cvirtualcontrollerconfig()) {
		res << zzz_vproto_internal_pack_cvirtualcontrollerconfig(o.config, 5)
	}
	if o.layouts.ne(zzz_vproto_internal_new_cvirtualcontrollerlayouts()) {
		res << zzz_vproto_internal_pack_cvirtualcontrollerlayouts(o.layouts, 6)
	}
	return res
}

pub fn cvirtualcontrollerlayoutpackage_unpack(buf []byte) ?CVirtualControllerLayoutPackage {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerlayoutpackage()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.creator = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_revision = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.saved_revision = v
				i = ii
			}
			5 {
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerconfig(cur_buf,
					tag_wiretype.wire_type)?
				res.config = v
				i = ii
			}
			6 {
				ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerlayouts(cur_buf,
					tag_wiretype.wire_type)?
				res.layouts = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerLayoutPackage) eq(b CVirtualControllerLayoutPackage) bool {
	return true && a.appid == b.appid &&
		a.creator == b.creator && a.initial_revision == b.initial_revision &&
		a.saved_revision == b.saved_revision && a.config.eq(b.config) && a.layouts.eq(b.layouts)
}

[inline]
pub fn (a CVirtualControllerLayoutPackage) ne(b CVirtualControllerLayoutPackage) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerLayoutPackage) eq(b []CVirtualControllerLayoutPackage) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerLayoutPackage) ne(b []CVirtualControllerLayoutPackage) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerlayoutpackage() CVirtualControllerLayoutPackage {
	return CVirtualControllerLayoutPackage{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerlayoutpackage(o CVirtualControllerLayoutPackage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerlayoutpackage(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerLayoutPackage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerlayoutpackage_unpack(v)?
	return i, unpacked
}

pub struct CVirtualControllerGlobalConfig {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	feedback_enabled   bool
	gyroscope_enabled  bool = true
	auto_fade_enabled  bool = true
	rumble_enabled     bool = true
	shake_fade_enabled bool
}

pub fn (o &CVirtualControllerGlobalConfig) pack() []byte {
	mut res := []byte{}
	if o.feedback_enabled != bool(0) {
		res << vproto.pack_bool_field(o.feedback_enabled, 1)
	}
	if o.gyroscope_enabled != bool(0) {
		res << vproto.pack_bool_field(o.gyroscope_enabled, 2)
	}
	if o.auto_fade_enabled != bool(0) {
		res << vproto.pack_bool_field(o.auto_fade_enabled, 3)
	}
	if o.rumble_enabled != bool(0) {
		res << vproto.pack_bool_field(o.rumble_enabled, 4)
	}
	if o.shake_fade_enabled != bool(0) {
		res << vproto.pack_bool_field(o.shake_fade_enabled, 5)
	}
	return res
}

pub fn cvirtualcontrollerglobalconfig_unpack(buf []byte) ?CVirtualControllerGlobalConfig {
	mut res := zzz_vproto_internal_new_cvirtualcontrollerglobalconfig()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.feedback_enabled = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.gyroscope_enabled = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.auto_fade_enabled = v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.rumble_enabled = v
				i = ii
			}
			5 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.shake_fade_enabled = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a CVirtualControllerGlobalConfig) eq(b CVirtualControllerGlobalConfig) bool {
	return true && a.feedback_enabled == b.feedback_enabled &&
		a.gyroscope_enabled == b.gyroscope_enabled &&
		a.auto_fade_enabled == b.auto_fade_enabled &&
		a.rumble_enabled == b.rumble_enabled &&
		a.shake_fade_enabled == b.shake_fade_enabled
}

[inline]
pub fn (a CVirtualControllerGlobalConfig) ne(b CVirtualControllerGlobalConfig) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []CVirtualControllerGlobalConfig) eq(b []CVirtualControllerGlobalConfig) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []CVirtualControllerGlobalConfig) ne(b []CVirtualControllerGlobalConfig) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_cvirtualcontrollerglobalconfig() CVirtualControllerGlobalConfig {
	return CVirtualControllerGlobalConfig{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_cvirtualcontrollerglobalconfig(o CVirtualControllerGlobalConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerglobalconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerGlobalConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualcontrollerglobalconfig_unpack(v)?
	return i, unpacked
}
